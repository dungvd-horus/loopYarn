if ( TRACE ) { TRACE( JSON.parse( '["AlertFullSlotAnim#init","AlertFullSlotAnim#Awake","AlertFullSlotAnim#PlayAlertAnim","AlertFullSlotAnim#OnDestroy","AutoTextureScale#init","AutoTextureScale#Awake","AutoTextureScale#LateUpdate","AutoTextureScale#UpdateTextureUV","AutoTextureScale#ActiveScaler","AutoTextureScale#DeActiveTextureScaler","BigBlockObjectConfigSetup#init","BigBlockObjectConfigSetup#Awake","BigBlockObjectConfigSetup#AddWallSetup","BigBlockObjectConfigSetup#RemoveWallSetup","BigBlockObjectConfigSetup#RemoveWallObjectAndItConfig","BigBlockObjectConfigSetup#RemoveWallObjectAndItConfig$1","BigBlockObjectConfigSetup#ClearWallSetups","BigBlockObjectConfigSetup#CreateBigBlock","BigBlockObjectConfigSetup#CreateBigBlock$1","BigBlockObjectConfigSetup#GetPixelsBetweenRectangle","BigBlockObjectConfigSetup#SetupNewWallInScene","BigBlockObjectConfigSetup#IsValidWallOrientation$1","BigBlockObjectConfigSetup#IsValidWallOrientation","BigBlockObjectConfigSetup#GetCenterByBoundingBox","BigBlockObjectConfigSetup#ImportWallsToPaintingConfig","BigBlockObjectConfigSetup#Reload","BigBlockObjectConfigSetup#Save","BulletDisplayHandler#init","BulletDisplayHandler#Awake","BulletDisplayHandler#Update","BulletDisplayHandler#UpdateBulletDisplay","BulletDisplayHandler#UpdateRotateText","BulletDisplayHandler#SetUpdateText","BulletDisplayHandler#SetFadeText","BulletDisplayHandler#ScaleText","CachedSplineTransformPath#init","CachedSplineTransformPath#IsValid","CachedSplineTransformPath#GetPositionAtTF","CachedSplineTransformPath#GetTangentAtTF","CachedSplineTransformPath#GetUpVectorAtTF","CachedSplineTransformPath#GetPositionAtDistance","CachedSplineTransformPath#GetTangentAtDistance","CachedSplineTransformPath#GetUpVectorAtDistance","CachedSplineTransformPath#GetTransformPosition","CachedSplineTransformPath#GetTransformUpVector","CachedSplineTransformPath#GetTransformForwardVector","CachedSplineTransformPath#MarkDistanceCacheDirty","CachedSplineTransformPath#CalculateTotalDistance","CachedSplineTransformPath#CalculateCumulativeDistances","CachedSplineTransformPath#ConvertTfToDistance","CachedSplineTransformPath#ConvertDistanceToTf","CachedSplineTransformPath#GetTrueTfFromNormalizedTf","CachedTransformPathMover#Path#get","CachedTransformPathMover#init","CachedTransformPathMover#Start","CachedTransformPathMover#Update","CachedTransformPathMover#Initialize","CachedTransformPathMover#PauseMovement","CachedTransformPathMover#MoveAlongPath","CachedTransformPathMover#SetPositionByTF","CachedTransformPathMover#SetPositionByDistance","CachedTransformPathMover#UpdatePositionByTF","CachedTransformPathMover#UpdatePositionByDistance","CachedTransformPathMover#GetPositionAtTF","CachedTransformPathMover#GetTangentAtTF","CachedTransformPathMover#GetUpVectorAtTF","CachedTransformPathMover#GetPositionAtDistance","CachedTransformPathMover#GetTangentAtDistance","CachedTransformPathMover#GetUpVectorAtDistance","CachedTransformPathMover#HandleSelectCollector","CachedTransformPathMover#StartMovementByTF","CachedTransformPathMover#StartMovement","CachedTransformPathMover#StopMovementAtCurrentPosition","CachedTransformPathMover#StopMovement","CachedTransformPathMover#SetMovementDirection","CachedTransformPathMover#IsPathValid","CachedTransformPathMover#SetSpeed","CachedTransformPathMover#SetDirection","CachedTransformPathMover#ChangeMovementType","CollectorAnimation#init","CollectorAnimation#Awake","CollectorAnimation#Start","CollectorAnimation#OnEnable","CollectorAnimation#Update","CollectorAnimation#OnDisable","CollectorAnimation#OnDestroy","CollectorAnimation#RegisterEvents","CollectorAnimation#UnRegisterEvents","CollectorAnimation#OnCollectorMoveToBelt","CollectorAnimation#OnCollectorStartMove","CollectorAnimation#OnCollectorMoveToFirstLine","CollectorAnimation#OnClickACollector","CollectorAnimation#PlayAnim","CollectorAnimation#MoveToQueuePosition","CollectorAnimation#MoveToQueueRotateBack","CollectorAnimation#MoveToDeadPosition","CollectorAnimation#MoveToBeltPosition","CollectorAnimation#PushForwardAnimation","CollectorAnimation#PushForwardOnQueue","CollectorAnimation#CompleteColorPixelsAnimation","CollectorAnimation#UnlockLockObjectAnimation","CollectorAnimation#CreateSquashTween","CollectorAnimation#PlaySquash","CollectorAnimation#CreateJumpTween","CollectorAnimation#PlayJump","CollectorAnimation#PlayBoxReveal","CollectorAnimation#StopJump","CollectorAnimation#StartEarIdleAnimation","CollectorAnimation#CacheBreathTween","CollectorAnimation#StartBreathing","CollectorAnimation#DelayStartBreathing","CollectorAnimation#StopBreathing","CollectorAnimation#PlayShootAnimation","CollectorAnimation#CacheStretchTween","CollectorAnimation#PlayStretch","CollectorAnimation#StopStretch","CollectorAnimation#StopAnimation","CollectorColumn#ctor","CollectorColumnController#init","CollectorColumnController#init","CollectorColumnController#Awake","CollectorColumnController#CacheSystemReferences","CollectorColumnController#RegisterEvents","CollectorColumnController#OnCollectorStartMove","CollectorColumnController#OnDestroy","CollectorColumnController#UpdatePosition","CollectorColumnController#GetLockReadyToUnlock","CollectorColumnController#OnAKeyReadyToBeCollected","CollectorColumnController#UpdateHiddenCollectorsState","CollectorColumnController#RemoveAllCollectorWithColor","CollectorColumnController#RemoveAndRePositionCollectors","CollectorColumnController#HighlightRows","CollectorColumnController#DeHighlightRows","CollectorController#init","CollectorController#init","CollectorController#Awake","CollectorController#OnDestroy","CollectorController#PauseMovement","CollectorController#ResumeMovement","CollectorController#StartMovement","CollectorController#StopMovementAtCurrentPosition","CollectorController#OnCollectorMoveFinished","CollectorController#DeUpdateText","CollectorController#CanMove","CollectorController#GetStartPosition","CollectorController#GetPositionByTF","CollectorController#GetCurrentTF","CollectorController#MoveToPos","CollectorController#HandleCompleteColorPixelsDirect","CollectorController#HandleCompleteColorPixels","CollectorController#OnCompletePixel","CollectorController#UnlockCollector","CollectorController#SetFadeBulletText","CollectorController#UpdateVisiblityBasedOnRow","CollectorController#OnAbsoluteWin","CollectorController#OnDisable","CollectorGameManager#init","CollectorGameManager#ActiveMovingControllers#get","CollectorGameManager#init","CollectorGameManager#Awake","CollectorGameManager#OnDestroy","CollectorGameManager#RequestMoveCollector","CollectorGameManager#ForceMoveCollector","CollectorGameManager#MoveCollectorCoroutine","CollectorGameManager#ProcessPendingQueueCoroutine","CollectorGameManager#ForceRemoveCollector","CollectorGameManager#HandleStartMoveCollector","CollectorGameManager#CanMoveCollectorPath","CollectorGameManager#OnCollectorFinished","CollectorGameManager#OnCompleteColor","CollectorGameManager#PauseGame","CollectorGameManager#OnPauseGame","CollectorGameManager#OnResumeGame","CollectorMachanicObjectBase#init","CollectorMoveLimiter#init","CollectorMoveLimiter#Awake","CollectorMoveLimiter#TryStartMove","CollectorMoveLimiter#GetAllCollectorsInChain","CollectorMoveLimiter#OnCollectorMoveFinished","CollectorMoveLimiter#GetAndRemoveFreePad","CollectorMoveLimiter#ReturnPadToPool","CollectorMoveLimiter#EnsurePoolSize","CollectorMoveLimiter#UpdatePoolLayout","CollectorMoveLimiter#GetAvailableSlots","CollectorMoveLimiter#SetMaxActiveMoving","CollectorMoveLimiter#AddMaxActiveMoving","CollectorMoveLimiter#IsFullSlots","CollectorMoveLimiter#UpdateText","CollectorMoveLimiter#TextAnimScale","CollectorMoveLimiter#TextAnimShakeOnFull","CollectorMoveLimiter#GetMaxActiveMoving","CollectorProjectileController#init","CollectorProjectileController#Awake","CollectorProjectileController#Update","CollectorProjectileController#OnDisable","CollectorProjectileController#RotateToTarget","CollectorProjectileController#StartProjectile","CollectorProjectileController#StartProjectile$1","CollectorProjectileController#SetPosition","CollectorProjectileController#SetColor","CollectorProjectileController#SetBulletMeshColor","CollectorProjectileController#OnStop","CollectorProjectileController#SetReturnToPoolCallback","CollectorProjectileController#Despawn","CollectorProjectilePool#init","CollectorProjectilePool#Awake","CollectorProjectilePool#InitializePool","CollectorProjectilePool#CreateProjectile","CollectorProjectilePool#GetProjectile","CollectorProjectilePool#ReturnToPool","CollectorQueueManager#init","CollectorQueueManager#Awake","CollectorQueueManager#AddMaxSlot","CollectorQueueManager#SetMaxSlot","CollectorQueueManager#IsQueueFull","CollectorQueueManager#EnqueueCollector","CollectorQueueManager#RemoveCollectorFromDeadQueue","CollectorQueueManager#RemoveCollectorFromQueue","CollectorQueueManager#IsInQueue","CollectorQueueManager#GetLastCollectorInQueue","CollectorQueueManager#MoveCollectorToQueuePosition","CollectorQueueManager#MoveCollectorToDeadPosition","CollectorQueueManager#PushForwardCollectorOnQueue","CollectorQueueManager#HasEnoughSlotsFor","CollectorVisualHandler#init","CollectorVisualHandler#Awake","CollectorVisualHandler#OnEnable","CollectorVisualHandler#OnDisable","CollectorVisualHandler#OnDestroy","CollectorVisualHandler#RegisterEvents","CollectorVisualHandler#UnRegisterEvents","CollectorVisualHandler#OnACollectorRevealed","CollectorVisualHandler#SetColor","CollectorVisualHandler#SetMaterial","CollectorVisualHandler#SetMeshMaterial","CollectorVisualHandler#SetMeshColor","CollectorVisualHandler#SetRopeColor","CollectorVisualHandler#SetupRope","CollectorVisualHandler#HideRope","CollectorVisualHandler#UpdateRopeColor","CollectorVisualHandler#RefreshColor","CollectorVisualHandler#SetBulletText","CollectorVisualHandler#SetLockedIcon","CollectorVisualHandler#SetHiddenState","CollectorVisualHandler#DelayReveal","CollectorVisualHandler#SetMuzzleColor","CollectorVisualHandler#PlayMuzzleEffect","CollectorVisualHandler#StartHighlight","CollectorVisualHandler#StopHighlight","CollectorVisualHandler#StartRimBlink","CollectorVisualHandler#SetFloat","CollectorVisualHandler#StartTrailHighSpeed","CollectorVisualHandler#StopTrailHighSpeed","CollectorVisualHandler#SetVisisble","ColorPalleteData#init","ColorPalleteData#GetColorByCode","ColorPalleteData#GetMaterialByCode","ColorPalleteData#FindKeyByColor","ColorPalleteData#SetupColor","ColorPalleteData#SetupMaterials","ColorPalleteData#OnValidate","ColorPalleteData#OnEnable","ColumnOfCollectorConfig#ctor","ColumnOfCollectorConfig#$ctor1","CombinesCollector#OnValidate","CombinesCollector#Combine","CombinesCollector#Combine$1","ConnectCollectors#OnValidate","ConnectCollectors#Connect","ConnectCollectors#Connect$1","CullableObject#init","CullableObject#Start","CullableObject#Update","CullableObject#CheckVisibility","CullableObject#SetRenderers","CullableObject#OnBecameVisible","CullableObject#OnBecameInvisible","CullableObject#ForceEnable","CullableObject#ForceDisable","CullableObject#IsVisible","CullableObject#SetMaxDistance","CullableObject#OnDrawGizmosSelected","DG.Tweening.DOTweenCYInstruction.WaitForCompletion#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForCompletion#ctor","DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#ctor","DG.Tweening.DOTweenCYInstruction.WaitForKill#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForKill#ctor","DG.Tweening.DOTweenCYInstruction.WaitForPosition#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForPosition#ctor","DG.Tweening.DOTweenCYInstruction.WaitForRewind#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForRewind#ctor","DG.Tweening.DOTweenCYInstruction.WaitForStart#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForStart#ctor","DG.Tweening.DOTweenModuleAudio#DOFade","DG.Tweening.DOTweenModuleAudio#DOPitch","DG.Tweening.DOTweenModuleAudio#DOSetFloat","DG.Tweening.DOTweenModuleAudio#DOComplete","DG.Tweening.DOTweenModuleAudio#DOKill","DG.Tweening.DOTweenModuleAudio#DOFlip","DG.Tweening.DOTweenModuleAudio#DOGoto","DG.Tweening.DOTweenModuleAudio#DOPause","DG.Tweening.DOTweenModuleAudio#DOPlay","DG.Tweening.DOTweenModuleAudio#DOPlayBackwards","DG.Tweening.DOTweenModuleAudio#DOPlayForward","DG.Tweening.DOTweenModuleAudio#DORestart","DG.Tweening.DOTweenModuleAudio#DORewind","DG.Tweening.DOTweenModuleAudio#DOSmoothRewind","DG.Tweening.DOTweenModuleAudio#DOTogglePause","DG.Tweening.DOTweenModulePhysics#DOMove","DG.Tweening.DOTweenModulePhysics#DOMoveX","DG.Tweening.DOTweenModulePhysics#DOMoveY","DG.Tweening.DOTweenModulePhysics#DOMoveZ","DG.Tweening.DOTweenModulePhysics#DORotate","DG.Tweening.DOTweenModulePhysics#DOLookAt","DG.Tweening.DOTweenModulePhysics#DOJump","DG.Tweening.DOTweenModulePhysics#DOPath","DG.Tweening.DOTweenModulePhysics#DOPath$1","DG.Tweening.DOTweenModulePhysics#DOLocalPath","DG.Tweening.DOTweenModulePhysics#DOLocalPath$1","DG.Tweening.DOTweenModulePhysics2D#DOMove","DG.Tweening.DOTweenModulePhysics2D#DOMoveX","DG.Tweening.DOTweenModulePhysics2D#DOMoveY","DG.Tweening.DOTweenModulePhysics2D#DORotate","DG.Tweening.DOTweenModulePhysics2D#DOJump","DG.Tweening.DOTweenModulePhysics2D#DOPath","DG.Tweening.DOTweenModulePhysics2D#DOPath$1","DG.Tweening.DOTweenModulePhysics2D#DOLocalPath","DG.Tweening.DOTweenModulePhysics2D#DOLocalPath$1","DG.Tweening.DOTweenModuleSprite#DOColor","DG.Tweening.DOTweenModuleSprite#DOFade","DG.Tweening.DOTweenModuleSprite#DOGradientColor","DG.Tweening.DOTweenModuleSprite#DOBlendableColor","DG.Tweening.DOTweenModuleUI#DOFade","DG.Tweening.DOTweenModuleUI#DOFade$1","DG.Tweening.DOTweenModuleUI#DOFade$2","DG.Tweening.DOTweenModuleUI#DOFade$3","DG.Tweening.DOTweenModuleUI#DOFade$4","DG.Tweening.DOTweenModuleUI#DOColor","DG.Tweening.DOTweenModuleUI#DOColor$1","DG.Tweening.DOTweenModuleUI#DOColor$2","DG.Tweening.DOTweenModuleUI#DOColor$3","DG.Tweening.DOTweenModuleUI#DOFillAmount","DG.Tweening.DOTweenModuleUI#DOGradientColor","DG.Tweening.DOTweenModuleUI#DOFlexibleSize","DG.Tweening.DOTweenModuleUI#DOMinSize","DG.Tweening.DOTweenModuleUI#DOPreferredSize","DG.Tweening.DOTweenModuleUI#DOScale","DG.Tweening.DOTweenModuleUI#DOAnchorPos","DG.Tweening.DOTweenModuleUI#DOAnchorPosX","DG.Tweening.DOTweenModuleUI#DOAnchorPosY","DG.Tweening.DOTweenModuleUI#DOAnchorPos3D","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DX","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DY","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DZ","DG.Tweening.DOTweenModuleUI#DOAnchorMax","DG.Tweening.DOTweenModuleUI#DOAnchorMin","DG.Tweening.DOTweenModuleUI#DOPivot","DG.Tweening.DOTweenModuleUI#DOPivotX","DG.Tweening.DOTweenModuleUI#DOPivotY","DG.Tweening.DOTweenModuleUI#DOSizeDelta","DG.Tweening.DOTweenModuleUI#DOPunchAnchorPos","DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos","DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos$1","DG.Tweening.DOTweenModuleUI#DOJumpAnchorPos","DG.Tweening.DOTweenModuleUI#DONormalizedPos","DG.Tweening.DOTweenModuleUI#DOHorizontalNormalizedPos","DG.Tweening.DOTweenModuleUI#DOVerticalNormalizedPos","DG.Tweening.DOTweenModuleUI#DOValue","DG.Tweening.DOTweenModuleUI#DOCounter","DG.Tweening.DOTweenModuleUI#DOText","DG.Tweening.DOTweenModuleUI#DOBlendableColor","DG.Tweening.DOTweenModuleUI#DOBlendableColor$1","DG.Tweening.DOTweenModuleUI#DOBlendableColor$2","DG.Tweening.DOTweenModuleUI#DOShapeCircle","DG.Tweening.DOTweenModuleUI.Utils#SwitchToRectTransform","DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor","DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor$1","DG.Tweening.DOTweenModuleUnityVersion#WaitForCompletion","DG.Tweening.DOTweenModuleUnityVersion#WaitForRewind","DG.Tweening.DOTweenModuleUnityVersion#WaitForKill","DG.Tweening.DOTweenModuleUnityVersion#WaitForElapsedLoops","DG.Tweening.DOTweenModuleUnityVersion#WaitForPosition","DG.Tweening.DOTweenModuleUnityVersion#WaitForStart","DG.Tweening.DOTweenModuleUnityVersion#DOOffset","DG.Tweening.DOTweenModuleUnityVersion#DOTiling","DG.Tweening.DOTweenModuleUtils#Init","DG.Tweening.DOTweenModuleUtils#Preserver","DG.Tweening.DOTweenModuleUtils.Physics#SetOrientationOnPath","DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody2D","DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody","DG.Tweening.DOTweenModuleUtils.Physics#CreateDOTweenPathTween","EnableRandomRotate#init","EnableRandomRotate#OnEnable","EnableRandomRotate#RandomRotate","GameplayEventsManager#InstallFullGame","GameplayManager#LevelId#get","GameplayManager#IsStoreLimitForFirstLevelEnabled#get","GameplayManager#init","GameplayManager#IsFirstLevelAndNotLast","GameplayManager#StartGame","GameplayManager#OnEnable","GameplayManager#Start","GameplayManager#OnDestroy","GameplayManager#OnEndGameAction","GameplayManager#OnCollectorDead","GamePlaySound#PlayClickCat","GogoGaga.OptimizedRopesAndCables.Rope#init","GogoGaga.OptimizedRopesAndCables.Rope#StartPoint#get","GogoGaga.OptimizedRopesAndCables.Rope#MidPoint#get","GogoGaga.OptimizedRopesAndCables.Rope#EndPoint#get","GogoGaga.OptimizedRopesAndCables.Rope#IsPrefab#get","GogoGaga.OptimizedRopesAndCables.Rope#init","GogoGaga.OptimizedRopesAndCables.Rope#Start","GogoGaga.OptimizedRopesAndCables.Rope#OnValidate","GogoGaga.OptimizedRopesAndCables.Rope#InitializeLineRenderer","GogoGaga.OptimizedRopesAndCables.Rope#Update","GogoGaga.OptimizedRopesAndCables.Rope#AreEndPointsValid","GogoGaga.OptimizedRopesAndCables.Rope#SetSplinePoint","GogoGaga.OptimizedRopesAndCables.Rope#CalculateYFactorAdjustment","GogoGaga.OptimizedRopesAndCables.Rope#GetMidPoint","GogoGaga.OptimizedRopesAndCables.Rope#GetRationalBezierPoint","GogoGaga.OptimizedRopesAndCables.Rope#GetPointAt","GogoGaga.OptimizedRopesAndCables.Rope#FixedUpdate","GogoGaga.OptimizedRopesAndCables.Rope#SimulatePhysics","GogoGaga.OptimizedRopesAndCables.Rope#OnDrawGizmos","GogoGaga.OptimizedRopesAndCables.Rope#SetStartPoint","GogoGaga.OptimizedRopesAndCables.Rope#SetMidPoint","GogoGaga.OptimizedRopesAndCables.Rope#SetEndPoint","GogoGaga.OptimizedRopesAndCables.Rope#RecalculateRope","GogoGaga.OptimizedRopesAndCables.Rope#NotifyPointsChanged","GogoGaga.OptimizedRopesAndCables.Rope#IsPointsMoved","GogoGaga.OptimizedRopesAndCables.Rope#IsRopeSettingsChanged","GogoGaga.OptimizedRopesAndCables.RopeMesh#init","GogoGaga.OptimizedRopesAndCables.RopeMesh#init","GogoGaga.OptimizedRopesAndCables.RopeMesh#Awake","GogoGaga.OptimizedRopesAndCables.RopeMesh#OnEnable","GogoGaga.OptimizedRopesAndCables.RopeMesh#OnDisable","GogoGaga.OptimizedRopesAndCables.RopeMesh#InitializeComponents","GogoGaga.OptimizedRopesAndCables.RopeMesh#CheckEndPoints","GogoGaga.OptimizedRopesAndCables.RopeMesh#SubscribeToRopeEvents","GogoGaga.OptimizedRopesAndCables.RopeMesh#UnsubscribeFromRopeEvents","GogoGaga.OptimizedRopesAndCables.RopeMesh#CreateRopeMesh","GogoGaga.OptimizedRopesAndCables.RopeMesh#GenerateMesh","GogoGaga.OptimizedRopesAndCables.RopeMesh#Update","GogoGaga.OptimizedRopesAndCables.RopeMesh#DelayedGenerateMesh","GogoGaga.OptimizedRopesAndCables.RopeMesh#OnDestroy","GogoGaga.OptimizedRopesAndCables.RopeMesh#CacheOverrideColorID","GogoGaga.OptimizedRopesAndCables.RopeMesh#TrySetSingleColor","GogoGaga.OptimizedRopesAndCables.RopeMesh#SetColor","GogoGaga.OptimizedRopesAndCables.RopeMesh#SetColor$1","GogoGaga.OptimizedRopesAndCables.RopeMesh#TestRandomColor","GogoGaga.OptimizedRopesAndCables.RopeMesh#ReOffsetTextureTwoHalf","GogoGaga.OptimizedRopesAndCables.RopeMesh#SetColorGreen","GogoGaga.OptimizedRopesAndCables.RopeMesh#SetColorRed","Grid3DLayout#init","Grid3DLayout#ArrangeChildren","GridGenerator#init","GridGenerator#Reset","GridGenerator#ContextGenerateGrid","GridGenerator#ContextClearGrid","GridGenerator#GenerateGrid","GridGenerator#ClearGrid","GridGenerator#GetTotalPixels","HelperCoroutine#init","HelperCoroutine#WaitSeconds","HelperCoroutine#ClearCache","HelperCoroutine#DelaySeconds","HelperCoroutine#DelayFrames","HelperCoroutine#RunOnSeconds","HelperCoroutine#RunOnFrames","HelperCoroutine#DelayCall$1","HelperCoroutine#DelayCall","HelperCoroutine#RunCall$1","HelperCoroutine#RunCall","IdleMoveUpDown#init","IdleMoveUpDown#Awake","IdleMoveUpDown#OnDisable","IdleMoveUpDown#CreateMoveTween","IdleMoveUpDown#PlayTween","IdleMoveUpDown#StopTween","IdleRotate#init","IdleRotate#OnEnable","IdleRotate#Update","IdleRotate#StartRotate","IdleRotate#StopRotate","IdleRotate#BoostSpeed","InGameEffectOptions#init","InputManager#init","InputManager#Awake","InputManager#OnDestroy","InputManager#Update","InputManager#CanProcessInput","InputManager#PerformRaycast","InputManager#HandleCollectorChoosenInput","InputManager#HandleBoosterCollectorChoosenInput","InputManager#HandleSuperRabbitBoosterInput","InputManager#UpdateLastClickTime","InputManager#BlockGameplayInput","InputManager#UnBlockGameplayInput","InputManager#StartAllowPlayerToChooseBlock","InputManager#StopAllowPlayerToChooseBlock","InputManager#StartAllowPlayerToFreelyPick","InputManager#StopAllowPlayerToFreePick","KeyObject#Locked#get","KeyObject#Collected#get","KeyObject#ReadyToCollected#get","KeyObject#init","KeyObject#Awake","KeyObject#OnDestroy","KeyObject#OnGridChange","KeyObject#Initialize","KeyObject#OnAPixelBorderDestroyed","KeyObject#OnCollectedByLock","KeyObject#OnCollected","KeyObject#SelfDestroy","KeyObject#BorderContains","KeyObjectConfigSetup#Awake","KeyObjectConfigSetup#AddKeySetup","KeyObjectConfigSetup#RemoveKeySetup","KeyObjectConfigSetup#RemoveKeyObjectAndItConfig","KeyObjectConfigSetup#RemoveKeyObjectAndItConfig$1","KeyObjectConfigSetup#ClearKeySetups","KeyObjectConfigSetup#ClearAllKeySetups","KeyObjectConfigSetup#CreateKey$1","KeyObjectConfigSetup#CreateKey","KeyObjectConfigSetup#CreateKey$2","KeyObjectConfigSetup#GetPixelsBetweenRectangle","KeyObjectConfigSetup#SetupNewKeyInScene","KeyObjectConfigSetup#IsValidKeyOrientation$1","KeyObjectConfigSetup#IsValidKeyOrientation","KeyObjectConfigSetup#GetCenterByBoundingBox","KeyObjectSetup#init","KeyObjectSetup#ctor","KeyObjectSetup#$ctor1","KeyObjectSetup#$ctor2","LevelCollectorsConfigSetup#init","LevelCollectorsConfigSetup#LoadConfigAsset","LevelCollectorsConfigSetup#ImportCollectorsFromScene","LevelCollectorsConfigSetup#EnsureBidirectionalConnections","LevelCollectorsConfigSetup#GenerateCollectorsFromPaintingConfig","LevelCollectorsConfigSetup#UpdateCollectorsFromPaintingConfig","LevelCollectorsConfigSetup#SumColorBullets","LevelCollectorsConfigSetup#Diff","LevelCollectorsConfigSetup#CleanupZeroCollectors","LevelCollectorsConfigSetup#ExtractOutlinesByDepth","LevelCollectorsConfigSetup#ExtractOutlinesByDepth_Custom","LevelCollectorsConfigSetup#SelectOutlinePixelsFromList","LevelCollectorsConfigSetup#FindNonHiddenPixelsAt","LevelCollectorsConfigSetup#StartUpTool","LevelCollectorsConfigSetup#CountGunnersAsSet","LevelCollectorsConfigSetup#BakeCollectorsPositionInTool","LevelCollectorsConfigSetup#ReApplyCollectorsPosition","LevelCollectorsConfigSetup#ReCountCollectors","LevelCollectorsConfigSetup#ReArrangeCollectorBullets","LevelCollectorsConfigSetup#SwapCollectors","LevelCollectorsConfigSetup#InsertAmongOtherCollector","LevelCollectorsConfigSetup#InsertNewToOtherCollector","LevelCollectorsConfigSetup#SplitACollector","LevelCollectorsConfigSetup#Save","LevelCollectorsSystem#init","LevelCollectorsSystem#init","LevelCollectorsSystem#Awake","LevelCollectorsSystem#OnDestroy","LevelCollectorsSystem#GetFirstCollector","LevelCollectorsSystem#SetupCollectorsAndMechanic","LevelCollectorsSystem#InitializeCollections","LevelCollectorsSystem#CreateLockObject","LevelCollectorsSystem#ClearExistingCollectors","LevelCollectorsSystem#SetupConnectedCollectors","LevelCollectorsSystem#SetupCollectorControllersConnect","LevelCollectorsSystem#FindConnectedGroup","LevelCollectorsSystem#FindCollectorControllerByID","LevelCollectorsSystem#SetUpAndArrangePosition","LevelCollectorsSystem#ReArrangePosition","LevelCollectorsSystem#OnPlayerCollectAKey","LevelCollectorsSystem#OnInitializedCollectors","LevelCollectorsSystem#GetFirstLockedCollectorMet","LevelCollectorsSystem#RemoveCollector","LevelCollectorsSystem#CloneNewFromCollector","LevelCollectorsSystem#GetCollectorByID","LevelCollectorsSystem#ClearExistingLocks","LevelCollectorsSystem#GetBulletsByColor","LevelColorCollectorsConfig#GetCollectorConfigByID","LevelColorCollectorsConfig#NumberOfColumns","LevelColorCollectorsConfig#NumberOfCollectors","LevelColorCollectorsConfig#GetAllCollectorConfigs","LevelColorCollectorsConfig#RemoveCollector","LevelColorCollectorsConfig#ReArrangeID","LevelColorCollectorsConfig#EnsureBidirectionalConnections","LevelColorCollectorsConfig#NumberOfLocks","LevelColorCollectorsConfig#ClearData","LevelColorCollectorsConfigBackUp#ctor","LevelConfig#init","LevelConfigGetAllColorCode#ExtractColorCodes","LevelConfigSetup#init","LevelConfigSetup#init","LevelConfigSetup#OnValidate","LevelConfigSetup#Start","LevelConfigSetup#LoadLevel$1","LevelConfigSetup#LoadLevel","LevelConfigSetup#ClearLevel","LevelConfigSetup#SetUpComponents","LevelConfigSetup#SelectGridObject","LevelGamePlayConfigSO#GetLevelConfigData","LevelGamePlayConfigSO#GetLevelToLoad","LockObjectConfig#init","LockObjectConfig#ctor","MathHr#Remap","MoveCollector#OnValidate","MoveCollector#Move","MoveCollector#Move$1","MoveCollector#IsInFrontOf","PadController#init","PadController#Start","PadController#OnDisable","PadController#OnCollectorEnterPad","PadController#SetPositionAfterDelay","PadController#ResetToDefault","PadController#DeferredSetParent","PadController#PushForwardPad","PaintingAdvancedSetup#init","PaintingConfig#init","PaintingConfig#HidePixelsUnderPipes","PaintingConfig#ReShowPixelsUnderPipe","PaintingConfig#GetAllWorkingPixels","PaintingConfig#GetAllWorkingPixelsExceptHearts","PaintingConfig#GetPipeSetup","PaintingConfig#GetWallSetup","PaintingConfig#GetKeySetup","PaintingConfig#ClearData","PaintingConfigBackUp#init","PaintingConfigBackUp#ctor","PaintingConfigSetup#init","PaintingConfigSetup#SamplePaintingToGrid","PaintingConfigSetup#GetTextureFromSprite","PaintingConfigSetup#ExtractColorCodesFromPainting","PaintingConfigSetup#FindClosestColorInPaletteIgnoreRules","PaintingConfigSetup#FindClosestColorInPalette","PaintingConfigSetup#ColorDistanceLAB","PaintingConfigSetup#RGBToLAB","PaintingConfigSetup#CreatePaintingConfigAsset","PaintingConfigSetup#CanSample","PaintingConfigSetup#Save","PaintingGridEffects#PlayBlockDestroyedAudio","PaintingGridObject#ApproximatelyEqual","PaintingGridObject#PixelsByRow#get","PaintingGridObject#PixelsByColumn#get","PaintingGridObject#PixelByColor#get","PaintingGridObject#ActivePalette#get","PaintingGridObject#init","PaintingGridObject#Awake","PaintingGridObject#OnDestroy","PaintingGridObject#InitializeLevel","PaintingGridObject#ApplyPaintingConfig","PaintingGridObject#SetUpMechanicDependencies","PaintingGridObject#RegisterEvent","PaintingGridObject#UnregisterEvent","PaintingGridObject#UpdateOutlinePixels","PaintingGridObject#OnAPixelDestroyed","PaintingGridObject#ShakeNeighborPixelsOnDestroyed","PaintingGridObject#OnCollectorsFormationChanged","PaintingGridObject#OnAPipePixelDestroyed","PaintingGridObject#OnBlockDissapear","PaintingGridObject#UpdatePixelDestroyedCount","PaintingGridObject#ShootPixel","PaintingGridObject#BatchSetColorByCode","PaintingGridObject#BatchSetColorsByCodes","PaintingGridObject#DestroyAllPixelsObjects","PaintingGridObject#SelectOutlinePixels","PaintingGridObject#SelectOutlinePixelsWithColor","PaintingGridObject#GenerateGrid","PaintingGridObject#InitializeGrid","PaintingGridObject#InitializePixelMappings","PaintingGridObject#SetupPixelObject","PaintingGridObject#AddPixelToMappings","PaintingGridObject#AddPixelToRowMapping","PaintingGridObject#AddPixelToColumnMapping","PaintingGridObject#AddPixelToColorsMapping","PaintingGridObject#GetMaterialByColorCode","PaintingGridObject#ClearColorCodeMaterials","PaintingGridObject#ApplyPipeConfigurations","PaintingGridObject#CreatePipeObject","PaintingGridObject#CreatePipePixel","PaintingGridObject#RemovePipeObject","PaintingGridObject#ClearAllPipes","PaintingGridObject#ApplyWallConfigurations","PaintingGridObject#CreateWallObject","PaintingGridObject#ClearAllWalls","PaintingGridObject#RemoveWallObject","PaintingGridObject#RemoveWallObject$1","PaintingGridObject#ApplyKeyConfigurations","PaintingGridObject#CreateKeyObject","PaintingGridObject#ClearAllKeys","PaintingGridObject#RemoveKeyObject","PaintingGridObject#RemoveKeyObject$1","PaintingGridObject#GetCenterByBoundingBox$1","PaintingGridObject#GetCenterByBoundingBox","PaintingGridObject#GetPixelComponentNeighbor","PaintingGridObject#GetShapeSize","PaintingGridObject#GetPixelAtGridPosition","PaintingGridObject#GetOriginalPixelAt","PaintingGridObject#GetPixelsInRow","PaintingGridObject#GetPixelsInColumn","PaintingGridObject#ApplyColorVariation","PaintingGridObject#GetTotalPixels","PaintingGridObject#ClearToWhite","PaintingGridObject#CalculatePixelPosition","PaintingGridObject#CalculatePixelPositionAbstract","PaintingGridObject#CreateNewPaintingPixelAbstract","PaintingGridObject#CreateNewPaintingPixelReal","PaintingGridObject#ClearAllAdditionPixels","PaintingGridObject#GetLocalBorderPositions","PaintingGridObject#PixelExists","PaintingGridObject#IsPixelDestroyed","PaintingGridObject#GetPixelBasedOnPosition","PaintingGridObject#GetPixelBasedOnPositionNewNeeded","PaintingGridObject#GetPredictedPixel","PaintingGridObject#UpdatePixelWorldPos","PaintingLayoutAdjustModule#init","PaintingLayoutAdjustModule#SetColor","PaintingLayoutAdjustModule#SetHideSelected","PaintingLayoutAdjustModule#AddLineAbove","PaintingLayoutAdjustModule#AddLineBelow","PaintingLayoutAdjustModule#AddLineLeft","PaintingLayoutAdjustModule#AddLineRight","PaintingLayoutAdjustModule#AddPixel","PaintingLayoutAdjustModule#AddPixel$1","PaintingLayoutAdjustModule#HidePixel","PaintingLayoutAdjustModule#SetActivePaintingTool","PaintingLayoutAdjustModule#SetActiveDeleteTool","PaintingLayoutAdjustModule#GetBounds","PaintingLayoutAdjustModule#GetCurrentColor","PaintingLayoutAdjustModule#Save","PaintingPixel#init","PaintingPixel#ctor","PaintingPixel#$ctor2","PaintingPixel#$ctor1","PaintingPixel#SetUp","PaintingPixel#SetPosition","PaintingPixel#DestroyPixel","PaintingPixel#DestroyObject","PaintingPixel#ShowPixelObject","PaintingPixel#InCount","PaintingPixel#IsCompleteHidden","PaintingPixelComponent#init","PaintingPixelComponent#Awake","PaintingPixelComponent#OnEnable","PaintingPixelComponent#SetRendererMaterial","PaintingPixelComponent#ApplyColorOverride","PaintingPixelComponent#ColorEqual","PaintingPixelComponent#SetUp","PaintingPixelComponent#ApplyVisual","PaintingPixelComponent#SetColor","PaintingPixelComponent#ClearColorOverride","PaintingPixelComponent#IsDestroyed","PaintingPixelComponent#Destroyed$1","PaintingPixelComponent#ApplyPosition","PaintingPixelComponent#ShowVisualOnly","PaintingPixelComponent#HideVisualOnly","PaintingPixelComponent#GetWorldPosition","PaintingPixelComponent#DestroyPixelVisually","PaintingPixelComponent#SelfDestroy","PaintingPixelComponent#CreatePumpTween","PaintingPixelComponent#PlayPumpAndDisable","PaintingPixelComponent#CreateShakeTween","PaintingPixelComponent#PlayShake","PaintingPixelComponent#StopShake","PaintingPixelComponent#OnDisable","PaintingPixelConfig#init","PaintingPixelConfig#ctor","PaintingPixelConfig#$ctor2","PaintingPixelConfig#$ctor1","PaintingSharedAttributes#init","PaintingSharedAttributes#MoveRelative","PaintingSharedAttributes#InsertRelative","PaintingSharedAttributes#GetCollectorConfigByID","PaintingSharedAttributes#Shuffle","PaintingSharedAttributes.ColorPixelListPair#ctor","PaintingSharedAttributes.IntPixelListPair#ctor","PathTransformBasedCached#init","PathTransformBasedCached#Awake","PathTransformBasedCached#IsValid","PathTransformBasedCached#GetPositionAtTF","PathTransformBasedCached#GetTangentAtTF","PathTransformBasedCached#GetUpVectorAtTF","PathTransformBasedCached#GetPositionAtDistance","PathTransformBasedCached#GetTangentAtDistance","PathTransformBasedCached#GetUpVectorAtDistance","PathTransformBasedCached#GetTransformPosition","PathTransformBasedCached#GetTransformUpVector","PathTransformBasedCached#GetTransformForwardVector","PathTransformBasedCached#MarkDistanceCacheDirty","PathTransformBasedCached#CalculateTotalDistance","PathTransformBasedCached#CalculateCumulativeDistances","PathTransformBasedCached#ConvertTfToDistance","PathTransformBasedCached#ConvertDistanceToTf","PathTransformBasedCached#GetTrueTfFromNormalizedTf","PipeObject#init","PipeObject#Awake","PipeObject#OnDisable","PipeObject#Initialize","PipeObject#ApplyOrientationRotation","PipeObject#OnAPixelDestroyed","PipeObject#SelfDestroy","PipeObject#SelfDestroyGameobject","PipeObject#ApplyPosition","PipeObjectConfigSetup#init","PipeObjectConfigSetup#Awake","PipeObjectConfigSetup#AddPipeSetup","PipeObjectConfigSetup#RemovePipeSetup","PipeObjectConfigSetup#ClearPipeSetups","PipeObjectConfigSetup#ClearAllPipeSetups","PipeObjectConfigSetup#CreatePipe$1","PipeObjectConfigSetup#CreatePipe","PipeObjectConfigSetup#GetPaintingPixelsInBetween","PipeObjectConfigSetup#GetPaintingPixelsInBetweenithSpace","PipeObjectConfigSetup#SetupNewPipeInScene","PipeObjectConfigSetup#IsValidPipeOrientation","PipeObjectConfigSetup#IsValidPipeOrientation$1","PipeObjectConfigSetup#ImportPipesToPaintingConfig","PipeObjectConfigSetup#Reload","PipeObjectConfigSetup#Save","PipeObjectSetup#init","PipeObjectSetup#ctor","PipeObjectSetup#$ctor2","PipeObjectSetup#$ctor1","PipePartVisualHandle#init","PipePartVisualHandle#Awake","PipePartVisualHandle#OnDisable","PipePartVisualHandle#SetColor","PipePartVisualHandle#CacheFlashTween","PipePartVisualHandle#PlayFlash","PipePartVisualHandle#StopFlash","PipePartVisualHandle#SetBrightness","PixelMaterialFallbackProvider#GlobalFallback#get","PixelMaterialFallbackProvider#Awake","PlayNowButtonAnim#init","PlayNowButtonAnim#Start","PlayNowButtonAnim#OnDestroy","PlayNowButtonAnim#GotoStore","PlayNowButtonAnim#StartScalingAnimation","SingleColorCollectorConfig#init","SingleColorCollectorConfig#ctor","SingleColorCollectorConfig#$ctor2","SingleColorCollectorConfig#$ctor1","Singleton$1#init","Singleton$1#Awake","SoundDefine#getDefaultValue","SoundDefine#ctor","SoundDefine#Dispose","SoundDefine#getHashCode","SoundDefine#equals","SoundDefine#$clone","SoundUIElement#button#get","SoundUIElement#init","SoundUIElement#OnEnable","SoundUIElement#OnDisable","SoundUIElement#OnDestroy","SoundUIElement#PlayBGM","SoundUIElement#OnPointerClick","SoundUIElement#OnSubmit","SplineDataContainer#init","SplineDataContainer#InitializeArrays","SplineDataContainer#IsValid","SplineDataContainerToTransformConverter#init","SplitCollector#OnValidate","SplitCollector#Split","SplitCollector#Split$1","SplitCollector#IsInFrontOf","SwapCollectors#OnValidate","SwapCollectors#Swap","SwapCollectors#Swap$1","TutorialLayer#OnEnable","TutorialLayer#OnDisable","TutorialLayer#Start","TutorialLayer#InitLayer","TutorialLayer#ShowLayer","TutorialLayer#HideLayer","TutorialLayer#SwapHandSpriteCoroutine","TutorialLayer#FlareEffectCoroutine","TutorialLayer#StartScaleText","TutorialLayer#OnCollectorStartMove","TutorialLayer#StopAllCoroutinesSafe","TutorialLayer#WorldToCanvasLocalPosition","WallObject#init","WallObject#Initialize","WallObject#OnAPixelDestroyed","WallObject#OnDestroyed","WallObject#SelfDestroy","WallObject#SelfDestroyGameObject","WallObject#ApplyPosition","WallObject#AssignPaletteSharedMaterial","WallObject#RefreshPaletteMaterial","WallObjectSetup#ctor","WallObjectSetup#$ctor1","WallObjectSetup#$ctor2","ColorPixelsCollectorObject#Available#get","ColorPixelsCollectorObject#init","ColorPixelsCollectorObject#Awake","ColorPixelsCollectorObject#Start","ColorPixelsCollectorObject#OnDisable","ColorPixelsCollectorObject#OnDestroy","ColorPixelsCollectorObject#Update","ColorPixelsCollectorObject#RegisterEvents","ColorPixelsCollectorObject#UnregisterEvents","ColorPixelsCollectorObject#OnGridPixelsChanged","ColorPixelsCollectorObject#OnGridPaintingObjectInitialized","ColorPixelsCollectorObject#OnAbsoluteWin","ColorPixelsCollectorObject#SetCollectorActive","ColorPixelsCollectorObject#SetStatusAttributes","ColorPixelsCollectorObject#Unlock","ColorPixelsCollectorObject#OnStartMove","ColorPixelsCollectorObject#Reveal","ColorPixelsCollectorObject#InitializeCollector","ColorPixelsCollectorObject#SetActiveCollector","ColorPixelsCollectorObject#CheckMovementDirectionChange","ColorPixelsCollectorObject#DetermineMovementDirection","ColorPixelsCollectorObject#IsHorizontalDirection","ColorPixelsCollectorObject#IsVerticalDirection","ColorPixelsCollectorObject#UpdatePossibleTargets","ColorPixelsCollectorObject#OnRunOutOfBulletDestroyed","ColorPixelsCollectorObject#CheckAndDestroyNearbyPixels","ColorPixelsCollectorObject#RotateMesh","ColorPixelsCollectorObject#ShootPixel","ColorPixelsCollectorObject#SetBullet","ColorPixelsCollectorObject#CheckForObstaclesInRow","ColorPixelsCollectorObject#CheckForObstaclesInColumn","ColorPixelsCollectorObject#CheckTargetOnAbsoluteWin","ColorPixelsCollectorObject#SelfDestroy","ColorPixelsCollectorObject#ApplyLockedState","ColorPixelsCollectorObject#ApplyHiddenState","LockObject#init","LockObject#Awake","LockObject#Unlock","LockObject#UnlockWithVisual","SoundManager#inherits","SoundManager#init","SoundManager#PlaySound","SoundManager#StopSound","SoundManager#PlayRandomBGM","SoundManager#init","SoundManager#Start","SoundManager#Update","SoundManager#OnPlaySoundBG","SoundManager#OnSoundFxChange","SoundManager#OnSoundChange","SoundManager#ChangeVolumeSpecialBgmSound","SoundManager#OnMainSoundChange","SoundManager#OnEnableShowFxInGame","SoundManager#SetSpeedAudioGroup","SoundManager#PlayOneShotFx","SoundManager#PlayOneShot","SoundManager#PlayOneShotDelayed","SoundManager#PlayDelayed","SoundManager#PlaySpecialSoundLoop","SoundManager#LoopSpecialSound","SoundManager#StopSpecialSoundLoop","SoundManager#SetBoolEndGameUI","UiEndGame#inherits","UiEndGame#Start","UiEndGame#ShowEndGameWin","UiEndGame#ShowEndGameLose","UiEndGame#StartLevelTransition","UiEndGame#FadeInEndGame","UiEndGame#StartLoadingDots","UiEndGame#StopLoadingDots","UiEndGame#LoadingDotsCoroutine","UIEndGameXmas#Start","UIEndGameXmas#ShowEndGameWin","UIEndGameXmas#ShowEndGameLose"]' ) ); }
/**
 * @version 1.0.9483.21698
 * @copyright anton
 * @compiler Bridge.NET 17.9.42-luna
 */
Bridge.assembly("UnityScriptsCompiler", function ($asm, globals) {
    "use strict";

    /*AlertFullSlotAnim start.*/
    Bridge.define("AlertFullSlotAnim", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            alertImages: null,
            animDuration: 0,
            timeDelayShow: 0,
            cachedSequences: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "AlertFullSlotAnim#init", this ); }

                this.animDuration = 0.5;
            }
        },
        methods: {
            /*AlertFullSlotAnim.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "AlertFullSlotAnim#Awake", this ); }

                // Pre-initialize cached sequences to avoid allocation during runtime
                if (this.alertImages != null && this.alertImages.length > 0) {
                    this.cachedSequences = System.Array.init(this.alertImages.length, null, DG.Tweening.Sequence);
                }
            },
            /*AlertFullSlotAnim.Awake end.*/

            /*AlertFullSlotAnim.PlayAlertAnim start.*/
            PlayAlertAnim: function () {
if ( TRACE ) { TRACE( "AlertFullSlotAnim#PlayAlertAnim", this ); }

                if (UnityEngine.Time.time - this.timeDelayShow < this.animDuration * 2) {
                    return;
                }
                this.timeDelayShow = UnityEngine.Time.time;

                for (var i = 0; i < this.alertImages.length; i = (i + 1) | 0) {
                    var img = this.alertImages[i];

                    // Kill any existing animation on this image to prevent conflicts
                    if (this.cachedSequences[i] != null) {
                        DG.Tweening.TweenExtensions.Kill(this.cachedSequences[i]);
                    }

                    // Create and cache the sequence
                    this.cachedSequences[i] = DG.Tweening.DOTween.Sequence();
                    DG.Tweening.TweenSettingsExtensions.Append(this.cachedSequences[i], DG.Tweening.DOTweenModuleUI.DOFade$2(img, 1.0, this.animDuration * 0.5));
                    DG.Tweening.TweenSettingsExtensions.Append(this.cachedSequences[i], DG.Tweening.DOTweenModuleUI.DOFade$2(img, 0.0, this.animDuration * 0.5));
                    DG.Tweening.TweenSettingsExtensions.Append(this.cachedSequences[i], DG.Tweening.DOTweenModuleUI.DOFade$2(img, 1.0, this.animDuration * 0.5));
                    DG.Tweening.TweenSettingsExtensions.Append(this.cachedSequences[i], DG.Tweening.DOTweenModuleUI.DOFade$2(img, 0.0, this.animDuration * 0.5));
                }
            },
            /*AlertFullSlotAnim.PlayAlertAnim end.*/

            /*AlertFullSlotAnim.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "AlertFullSlotAnim#OnDestroy", this ); }

                if (this.cachedSequences != null) {
                    for (var i = 0; i < this.cachedSequences.length; i = (i + 1) | 0) {
                        if (this.cachedSequences[i] != null) {
                            DG.Tweening.TweenExtensions.Kill(this.cachedSequences[i]);
                            this.cachedSequences[i] = null;
                        }
                    }
                }
            },
            /*AlertFullSlotAnim.OnDestroy end.*/


        }
    });
    /*AlertFullSlotAnim end.*/

    /*AutoTextureScale start.*/
    Bridge.define("AutoTextureScale", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            Active: false,
            referenceScale: null,
            referenceTiling: null,
            rend: null,
            block: null,
            frameCounter: 0,
            updateEveryNFrames: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "AutoTextureScale#init", this ); }

                this.referenceScale = new UnityEngine.Vector3();
                this.referenceTiling = new UnityEngine.Vector2();
                this.Active = false;
                this.referenceScale = new pc.Vec3( 0.5, 0.16, 0.5 );
                this.referenceTiling = new pc.Vec2( 0.5, 2.5 );
                this.frameCounter = 0;
                this.updateEveryNFrames = 10;
            }
        },
        methods: {
            /*AutoTextureScale.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "AutoTextureScale#Awake", this ); }

                if (UnityEngine.Component.op_Equality(this.rend, null)) {
                    this.rend = this.GetComponent(UnityEngine.Renderer);
                }
                this.block = new UnityEngine.MaterialPropertyBlock();
            },
            /*AutoTextureScale.Awake end.*/

            /*AutoTextureScale.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "AutoTextureScale#LateUpdate", this ); }

                if (!this.Active) {
                    return;
                }

                this.frameCounter = (this.frameCounter + 1) | 0;
                if (this.frameCounter < this.updateEveryNFrames) {
                    return;
                }
                this.frameCounter = 0;

                this.UpdateTextureUV();
            },
            /*AutoTextureScale.LateUpdate end.*/

            /*AutoTextureScale.UpdateTextureUV start.*/
            UpdateTextureUV: function () {
if ( TRACE ) { TRACE( "AutoTextureScale#UpdateTextureUV", this ); }

                if (UnityEngine.Component.op_Equality(this.rend, null)) {
                    return;
                }

                var s = this.transform.localScale.$clone();

                var ratioX = s.x / this.referenceScale.x;
                var ratioY = s.z / this.referenceScale.z;

                var tiling = new pc.Vec2( this.referenceTiling.x * ratioX, this.referenceTiling.y * ratioY );
                if (UnityEngine.Component.op_Equality(this.rend, null)) {
                    this.rend = this.GetComponent(UnityEngine.Renderer);
                }
                if (this.block == null) {
                    this.block = new UnityEngine.MaterialPropertyBlock();
                }
                this.rend.GetPropertyBlock(this.block);
                this.block.SetVector$1("_MainTex_ST", new pc.Vec4( tiling.x, tiling.y, 0, 0 ));
                this.rend.SetPropertyBlock(this.block);
            },
            /*AutoTextureScale.UpdateTextureUV end.*/

            /*AutoTextureScale.ActiveScaler start.*/
            ActiveScaler: function () {
if ( TRACE ) { TRACE( "AutoTextureScale#ActiveScaler", this ); }

                this.Active = true;
                this.UpdateTextureUV();
            },
            /*AutoTextureScale.ActiveScaler end.*/

            /*AutoTextureScale.DeActiveTextureScaler start.*/
            DeActiveTextureScaler: function () {
if ( TRACE ) { TRACE( "AutoTextureScale#DeActiveTextureScaler", this ); }

                this.Active = false;
                this.UpdateTextureUV();
            },
            /*AutoTextureScale.DeActiveTextureScaler end.*/


        }
    });
    /*AutoTextureScale end.*/

    /*BigBlockObjectConfigSetup start.*/
    Bridge.define("BigBlockObjectConfigSetup", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            PaintingSetupModule: null,
            CurrentLevelWallObjectSetups: null,
            wallObjectSetups: null,
            ColorCode: null,
            WallHearts: 0,
            WallSpaceFromGrid: 0,
            WallPixelComponents: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "BigBlockObjectConfigSetup#init", this ); }

                this.ColorCode = "Default";
                this.WallHearts = 1;
                this.WallSpaceFromGrid = 1;
            }
        },
        methods: {
            /*BigBlockObjectConfigSetup.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "BigBlockObjectConfigSetup#Awake", this ); }

                if (this.wallObjectSetups == null) {
                    this.wallObjectSetups = new (System.Collections.Generic.List$1(WallObjectSetup)).ctor();
                }
            },
            /*BigBlockObjectConfigSetup.Awake end.*/

            /*BigBlockObjectConfigSetup.AddWallSetup start.*/
            /**
             * Add a wall setup to the list
             *
             * @instance
             * @public
             * @this BigBlockObjectConfigSetup
             * @memberof BigBlockObjectConfigSetup
             * @param   {WallObjectSetup}    wallSetup    The wall setup to add
             * @return  {void}
             */
            AddWallSetup: function (wallSetup) {
if ( TRACE ) { TRACE( "BigBlockObjectConfigSetup#AddWallSetup", this ); }

                if (this.wallObjectSetups == null) {
                    this.wallObjectSetups = new (System.Collections.Generic.List$1(WallObjectSetup)).ctor();
                }
                if (wallSetup != null && !this.wallObjectSetups.contains(wallSetup)) {
                    this.wallObjectSetups.add(wallSetup);
                }
            },
            /*BigBlockObjectConfigSetup.AddWallSetup end.*/

            /*BigBlockObjectConfigSetup.RemoveWallSetup start.*/
            /**
             * Remove a wall setup from the list
             *
             * @instance
             * @public
             * @this BigBlockObjectConfigSetup
             * @memberof BigBlockObjectConfigSetup
             * @param   {WallObjectSetup}    wallSetup    The wall setup to remove
             * @return  {void}
             */
            RemoveWallSetup: function (wallSetup) {
if ( TRACE ) { TRACE( "BigBlockObjectConfigSetup#RemoveWallSetup", this ); }

                if (wallSetup != null) {
                    this.wallObjectSetups.remove(wallSetup);
                }
            },
            /*BigBlockObjectConfigSetup.RemoveWallSetup end.*/

            /*BigBlockObjectConfigSetup.RemoveWallObjectAndItConfig start.*/
            RemoveWallObjectAndItConfig: function (_object, save) {
if ( TRACE ) { TRACE( "BigBlockObjectConfigSetup#RemoveWallObjectAndItConfig", this ); }

                if (this.PaintingSetupModule.CurrentGridObject.WallObjects != null && this.PaintingSetupModule.CurrentGridObject.WallObjects.Count > 0) {
                    this.PaintingSetupModule.CurrentGridObject.RemoveWallObject(_object);

                    var _wallConfig = this.PaintingSetupModule.CurrentPaintingConfig.GetWallSetup(_object.PaintingPixelsCovered.getItem(0), _object.PaintingPixelsCovered.getItem(((_object.PaintingPixelsCovered.Count - 1) | 0)));
                    if (_wallConfig != null) {
                        this.PaintingSetupModule.CurrentPaintingConfig.WallSetups.remove(_wallConfig);
                        this.RemoveWallSetup(_wallConfig);
                        if (save) {
                            this.PaintingSetupModule.Save();
                        }

                    }
                }
            },
            /*BigBlockObjectConfigSetup.RemoveWallObjectAndItConfig end.*/

            /*BigBlockObjectConfigSetup.RemoveWallObjectAndItConfig$1 start.*/
            RemoveWallObjectAndItConfig$1: function (_wallSetup, save) {
if ( TRACE ) { TRACE( "BigBlockObjectConfigSetup#RemoveWallObjectAndItConfig$1", this ); }

                if (this.PaintingSetupModule.CurrentGridObject.WallObjects != null && this.PaintingSetupModule.CurrentGridObject.WallObjects.Count > 0) {
                    this.PaintingSetupModule.CurrentGridObject.RemoveWallObject$1(_wallSetup);

                    if (_wallSetup != null) {
                        this.PaintingSetupModule.CurrentPaintingConfig.WallSetups.remove(_wallSetup);
                        this.RemoveWallSetup(_wallSetup);
                        if (save) {
                            this.PaintingSetupModule.Save();
                        }

                    }
                }
            },
            /*BigBlockObjectConfigSetup.RemoveWallObjectAndItConfig$1 end.*/

            /*BigBlockObjectConfigSetup.ClearWallSetups start.*/
            /**
             * Clear all wall setups
             *
             * @instance
             * @public
             * @this BigBlockObjectConfigSetup
             * @memberof BigBlockObjectConfigSetup
             * @return  {void}
             */
            ClearWallSetups: function () {
if ( TRACE ) { TRACE( "BigBlockObjectConfigSetup#ClearWallSetups", this ); }

                this.wallObjectSetups.clear();
            },
            /*BigBlockObjectConfigSetup.ClearWallSetups end.*/

            /*BigBlockObjectConfigSetup.CreateBigBlock start.*/
            /**
             * Create a wall between StartPixel and EndPixel based on current settings
             *
             * @instance
             * @public
             * @this BigBlockObjectConfigSetup
             * @memberof BigBlockObjectConfigSetup
             * @return  {void}
             */
            CreateBigBlock: function () {
if ( TRACE ) { TRACE( "BigBlockObjectConfigSetup#CreateBigBlock", this ); }

                var $t;
                this.wallObjectSetups = new (System.Collections.Generic.List$1(WallObjectSetup)).$ctor1(this.CurrentLevelWallObjectSetups);
                if (this.WallPixelComponents == null || this.WallPixelComponents.Count <= 1) {
                    UnityEngine.Debug.LogWarning$1("WallPixelComponents is not valid. Cannot create wall.");
                    return;
                }

                // Validate that the wall should be straight (horizontal or vertical)
                if (!this.IsValidWallOrientation$1(this.WallPixelComponents)) {
                    UnityEngine.Debug.LogWarning$1("Wall must be either horizontal (same row) or vertical (same column). Cannot create wall.");
                    return;
                }

                // Create and setup the wall in the scene - this will also create the wall pixels
                var wallPixelConfigs = new (System.Collections.Generic.List$1(PaintingPixelConfig)).ctor();
                $t = Bridge.getEnumerator(this.WallPixelComponents);
                try {
                    while ($t.moveNext()) {
                        var pixelComponent = $t.Current;
                        wallPixelConfigs.add(new PaintingPixelConfig.$ctor1(pixelComponent.PixelData));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                var wallSetup = new WallObjectSetup.$ctor1(wallPixelConfigs, this.ColorCode, this.WallHearts);

                var newWallObject = this.SetupNewWallInScene(wallSetup);

                if (UnityEngine.MonoBehaviour.op_Inequality(newWallObject, null)) {
                    this.AddWallSetup(wallSetup);
                }
            },
            /*BigBlockObjectConfigSetup.CreateBigBlock end.*/

            /*BigBlockObjectConfigSetup.CreateBigBlock$1 start.*/
            CreateBigBlock$1: function (_startPixel, _endPixel, colorCode, hearts) {
if ( TRACE ) { TRACE( "BigBlockObjectConfigSetup#CreateBigBlock$1", this ); }

                var $t;
                this.wallObjectSetups = new (System.Collections.Generic.List$1(WallObjectSetup)).$ctor1(this.CurrentLevelWallObjectSetups);
                var _listBlocks = new (System.Collections.Generic.List$1(PaintingPixel)).ctor();
                _listBlocks = this.GetPixelsBetweenRectangle(_startPixel, _endPixel);
                if (_listBlocks == null || _listBlocks.Count <= 1) {
                    UnityEngine.Debug.LogWarning$1("WallPixelComponents is not valid. Cannot create wall.");
                    return null;
                }

                // Validate that the wall should be straight (horizontal or vertical)
                if (!this.IsValidWallOrientation(_listBlocks)) {
                    UnityEngine.Debug.LogWarning$1("Wall must be either horizontal (same row) or vertical (same column). Cannot create wall.");
                    return null;
                }

                // Create and setup the wall in the scene - this will also create the wall pixels
                var wallPixelConfigs = new (System.Collections.Generic.List$1(PaintingPixelConfig)).ctor();
                $t = Bridge.getEnumerator(_listBlocks);
                try {
                    while ($t.moveNext()) {
                        var pixel = $t.Current;
                        wallPixelConfigs.add(new PaintingPixelConfig.$ctor1(pixel));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                var wallSetup = new WallObjectSetup.$ctor1(wallPixelConfigs, colorCode, hearts);

                var newWallObject = this.SetupNewWallInScene(wallSetup);

                if (UnityEngine.MonoBehaviour.op_Inequality(newWallObject, null)) {
                    this.AddWallSetup(wallSetup);
                }
                return wallSetup;
            },
            /*BigBlockObjectConfigSetup.CreateBigBlock$1 end.*/

            /*BigBlockObjectConfigSetup.GetPixelsBetweenRectangle start.*/
            GetPixelsBetweenRectangle: function (a, b) {
if ( TRACE ) { TRACE( "BigBlockObjectConfigSetup#GetPixelsBetweenRectangle", this ); }

                var $t;
                var result = new (System.Collections.Generic.List$1(PaintingPixel)).ctor();

                var minRow = UnityEngine.Mathf.Min(a.row, b.row);
                var maxRow = UnityEngine.Mathf.Max(a.row, b.row);
                var minCol = UnityEngine.Mathf.Min(a.column, b.column);
                var maxCol = UnityEngine.Mathf.Max(a.column, b.column);

                for (var r = minRow; r <= maxRow; r = (r + 1) | 0) {
                    for (var c = minCol; c <= maxCol; c = (c + 1) | 0) {
                        result.add(($t = new PaintingPixel.ctor(), $t.row = r, $t.column = c, $t.worldPos = this.PaintingSetupModule.CurrentGridObject.CalculatePixelPosition(c, r, this.PaintingSetupModule.CurrentGridObject.YOffset), $t));
                    }
                }

                return result;
            },
            /*BigBlockObjectConfigSetup.GetPixelsBetweenRectangle end.*/

            /*BigBlockObjectConfigSetup.SetupNewWallInScene start.*/
            /**
             * Set up the actual wall object in the scene
             *
             * @instance
             * @private
             * @this BigBlockObjectConfigSetup
             * @memberof BigBlockObjectConfigSetup
             * @param   {WallObjectSetup}    setup
             * @return  {WallObject}                  Tuple with the created WallObject component and list of new wall pixels
             */
            SetupNewWallInScene: function (setup) {
if ( TRACE ) { TRACE( "BigBlockObjectConfigSetup#SetupNewWallInScene", this ); }

                var wallObject = this.PaintingSetupModule.CurrentGridObject.CreateWallObject(setup);

                return wallObject;
            },
            /*BigBlockObjectConfigSetup.SetupNewWallInScene end.*/

            /*BigBlockObjectConfigSetup.IsValidWallOrientation$1 start.*/
            /**
             * Validates if the wall orientation is valid (horizontal or vertical only)
             *
             * @instance
             * @public
             * @this BigBlockObjectConfigSetup
             * @memberof BigBlockObjectConfigSetup
             * @param   {System.Collections.Generic.List$1}    _wallPixels
             * @return  {boolean}                                             True if wall orientation is valid, false otherwise
             */
            IsValidWallOrientation$1: function (_wallPixels) {
if ( TRACE ) { TRACE( "BigBlockObjectConfigSetup#IsValidWallOrientation$1", this ); }

                if (_wallPixels == null || _wallPixels.Count === 0) {
                    return false;
                }

                var minRow = System.Linq.Enumerable.from(_wallPixels, PaintingPixelComponent).min(function (p) {
                        return p.PixelData.row;
                    });
                var maxRow = System.Linq.Enumerable.from(_wallPixels, PaintingPixelComponent).max(function (p) {
                        return p.PixelData.row;
                    });
                var minCol = System.Linq.Enumerable.from(_wallPixels, PaintingPixelComponent).min(function (p) {
                        return p.PixelData.column;
                    });
                var maxCol = System.Linq.Enumerable.from(_wallPixels, PaintingPixelComponent).max(function (p) {
                        return p.PixelData.column;
                    });

                var width = (((maxCol - minCol) | 0) + 1) | 0;
                var height = (((maxRow - minRow) | 0) + 1) | 0;
                var expectedCount = Bridge.Int.mul(width, height);

                if (_wallPixels.Count !== expectedCount) {
                    return false;
                }

                // HashSet<(int, int)> pointSet = _wallPixels
                //     .Select(p => (p.PixelData.row, p.PixelData.column))
                //     .ToHashSet();
                var pointSet = new (System.Collections.Generic.HashSet$1(System.ValueTuple$2(System.Int32,System.Int32))).$ctor1(System.Linq.Enumerable.from(_wallPixels, PaintingPixelComponent).select(function (p) {
                        return new (System.ValueTuple$2(System.Int32,System.Int32)).$ctor1(p.PixelData.row, p.PixelData.column);
                    }));


                for (var r = minRow; r <= maxRow; r = (r + 1) | 0) {
                    for (var c = minCol; c <= maxCol; c = (c + 1) | 0) {
                        if (!pointSet.contains(new (System.ValueTuple$2(System.Int32,System.Int32)).$ctor1(r, c))) {
                            return false;
                        }
                    }
                }

                return true;
            },
            /*BigBlockObjectConfigSetup.IsValidWallOrientation$1 end.*/

            /*BigBlockObjectConfigSetup.IsValidWallOrientation start.*/
            IsValidWallOrientation: function (_wallPixels) {
if ( TRACE ) { TRACE( "BigBlockObjectConfigSetup#IsValidWallOrientation", this ); }

                if (_wallPixels == null || _wallPixels.Count === 0) {
                    return false;
                }

                var minRow = System.Linq.Enumerable.from(_wallPixels, PaintingPixel).min(function (p) {
                        return p.row;
                    });
                var maxRow = System.Linq.Enumerable.from(_wallPixels, PaintingPixel).max(function (p) {
                        return p.row;
                    });
                var minCol = System.Linq.Enumerable.from(_wallPixels, PaintingPixel).min(function (p) {
                        return p.column;
                    });
                var maxCol = System.Linq.Enumerable.from(_wallPixels, PaintingPixel).max(function (p) {
                        return p.column;
                    });

                var width = (((maxCol - minCol) | 0) + 1) | 0;
                var height = (((maxRow - minRow) | 0) + 1) | 0;
                var expectedCount = Bridge.Int.mul(width, height);

                if (_wallPixels.Count !== expectedCount) {
                    return false;
                }

                // HashSet<(int, int)> pointSet = _wallPixels
                //     .Select(p => (p.row, p.column))
                //     .ToHashSet();

                var pointSet = new (System.Collections.Generic.HashSet$1(System.ValueTuple$2(System.Int32,System.Int32))).$ctor1(System.Linq.Enumerable.from(_wallPixels, PaintingPixel).select(function (p) {
                        return new (System.ValueTuple$2(System.Int32,System.Int32)).$ctor1(p.row, p.column);
                    }));

                for (var r = minRow; r <= maxRow; r = (r + 1) | 0) {
                    for (var c = minCol; c <= maxCol; c = (c + 1) | 0) {
                        if (!pointSet.contains(new (System.ValueTuple$2(System.Int32,System.Int32)).$ctor1(r, c))) {
                            return false;
                        }
                    }
                }

                return true;
            },
            /*BigBlockObjectConfigSetup.IsValidWallOrientation end.*/

            /*BigBlockObjectConfigSetup.GetCenterByBoundingBox start.*/
            GetCenterByBoundingBox: function (points) {
if ( TRACE ) { TRACE( "BigBlockObjectConfigSetup#GetCenterByBoundingBox", this ); }

                if (points == null || points.Count === 0) {
                    return pc.Vec3.ZERO.clone();
                }

                var minX = System.Linq.Enumerable.from(points, PaintingPixelComponent).min(function (p) {
                        return p.PixelData.worldPos.x;
                    });
                var maxX = System.Linq.Enumerable.from(points, PaintingPixelComponent).max(function (p) {
                        return p.PixelData.worldPos.x;
                    });
                var minY = System.Linq.Enumerable.from(points, PaintingPixelComponent).min(function (p) {
                        return p.PixelData.worldPos.y;
                    });
                var maxY = System.Linq.Enumerable.from(points, PaintingPixelComponent).max(function (p) {
                        return p.PixelData.worldPos.y;
                    });
                var minZ = System.Linq.Enumerable.from(points, PaintingPixelComponent).min(function (p) {
                        return p.PixelData.worldPos.z;
                    });
                var maxZ = System.Linq.Enumerable.from(points, PaintingPixelComponent).max(function (p) {
                        return p.PixelData.worldPos.z;
                    });

                // trung tm bounding box
                return new pc.Vec3( (minX + maxX) * 0.5, (minY + maxY) * 0.5, (minZ + maxZ) * 0.5 );
            },
            /*BigBlockObjectConfigSetup.GetCenterByBoundingBox end.*/

            /*BigBlockObjectConfigSetup.ImportWallsToPaintingConfig start.*/
            /**
             * Import all wall configurations from this setup to a PaintingConfig asset
             *
             * @instance
             * @public
             * @this BigBlockObjectConfigSetup
             * @memberof BigBlockObjectConfigSetup
             * @param   {PaintingConfig}    paintingConfig    The PaintingConfig to import to
             * @return  {void}
             */
            ImportWallsToPaintingConfig: function (paintingConfig) {
if ( TRACE ) { TRACE( "BigBlockObjectConfigSetup#ImportWallsToPaintingConfig", this ); }

                var $t;
                if (paintingConfig == null) {
                    UnityEngine.Debug.LogError$2("PaintingConfig is null. Cannot import walls.");
                    return;
                }

                // Clear existing wall setups in the config
                if (paintingConfig.WallSetups == null) {
                    paintingConfig.WallSetups = new (System.Collections.Generic.List$1(WallObjectSetup)).ctor();
                } else {
                    paintingConfig.WallSetups.clear();
                }

                // Copy all wall setups from this component to the config
                $t = Bridge.getEnumerator(this.wallObjectSetups);
                try {
                    while ($t.moveNext()) {
                        var wallSetup = $t.Current;
                        if (wallSetup != null) {
                            // Add the wall setup to the painting config
                            paintingConfig.WallSetups.add(wallSetup);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                paintingConfig.HidePixelsUnderPipes();

                UnityEngine.Debug.Log$1(System.String.format("Imported {0} wall setups to PaintingConfig.", [Bridge.box(this.wallObjectSetups.Count, System.Int32)]));
            },
            /*BigBlockObjectConfigSetup.ImportWallsToPaintingConfig end.*/

            /*BigBlockObjectConfigSetup.Reload start.*/
            Reload: function () {
if ( TRACE ) { TRACE( "BigBlockObjectConfigSetup#Reload", this ); }

                var $t;
                this.PaintingSetupModule.CurrentGridObject.ClearAllWalls();
                this.CurrentLevelWallObjectSetups = this.PaintingSetupModule.CurrentPaintingConfig.WallSetups;
                this.wallObjectSetups = new (System.Collections.Generic.List$1(WallObjectSetup)).$ctor1(this.CurrentLevelWallObjectSetups);
                //return;
                $t = Bridge.getEnumerator(this.CurrentLevelWallObjectSetups);
                try {
                    while ($t.moveNext()) {
                        var wall = $t.Current;
                        this.PaintingSetupModule.CurrentGridObject.CreateWallObject(wall);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*BigBlockObjectConfigSetup.Reload end.*/

            /*BigBlockObjectConfigSetup.Save start.*/
            Save: function () {
if ( TRACE ) { TRACE( "BigBlockObjectConfigSetup#Save", this ); }

                this.ImportWallsToPaintingConfig(this.PaintingSetupModule.CurrentPaintingConfig);
                this.PaintingSetupModule.Save();
            },
            /*BigBlockObjectConfigSetup.Save end.*/


        },
        overloads: {
            "RemoveWallObjectAndItConfig(WallObjectSetup, bool)": "RemoveWallObjectAndItConfig$1",
            "CreateBigBlock(PaintingPixel, PaintingPixel, string, int)": "CreateBigBlock$1",
            "IsValidWallOrientation(List<PaintingPixelComponent>)": "IsValidWallOrientation$1"
        }
    });
    /*BigBlockObjectConfigSetup end.*/

    /*BulletDisplayHandler start.*/
    Bridge.define("BulletDisplayHandler", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            Collector: null,
            text: null,
            cachedWorldForward: null,
            _textTransform: null,
            camTrans: null,
            needUpdateText: false,
            scaleTwween: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "BulletDisplayHandler#init", this ); }

                this.cachedWorldForward = new UnityEngine.Quaternion();
                this.needUpdateText = false;
            }
        },
        methods: {
            /*BulletDisplayHandler.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "BulletDisplayHandler#Awake", this ); }

                this.cachedWorldForward = new pc.Quat().lookRotation( new pc.Vec3( 0, 0, 1 ), pc.Vec3.UP.clone() );
                if (UnityEngine.MonoBehaviour.op_Inequality(this.text, null)) {
                    this._textTransform = this.text.transform$1;
                }
                this.camTrans = UnityEngine.Camera.main.transform;
            },
            /*BulletDisplayHandler.Awake end.*/

            /*BulletDisplayHandler.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "BulletDisplayHandler#Update", this ); }

                if (!this.needUpdateText) {
                    return;
                }

                this.UpdateRotateText();
            },
            /*BulletDisplayHandler.Update end.*/

            /*BulletDisplayHandler.UpdateBulletDisplay start.*/
            UpdateBulletDisplay: function (bulletLeft) {
if ( TRACE ) { TRACE( "BulletDisplayHandler#UpdateBulletDisplay", this ); }

                this.text.enabled = !this.Collector.IsHidden && bulletLeft > 0;
                this.text.text = Bridge.toString(bulletLeft);
            },
            /*BulletDisplayHandler.UpdateBulletDisplay end.*/

            /*BulletDisplayHandler.UpdateRotateText start.*/
            UpdateRotateText: function () {
if ( TRACE ) { TRACE( "BulletDisplayHandler#UpdateRotateText", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.text, null)) {
                    UnityEngine.Debug.LogError$2("BulletDisplayHandler: text is not assigned.");
                    return;
                }
                if (UnityEngine.Component.op_Equality(this._textTransform, null)) {
                    this._textTransform = this.text.transform$1;
                    //_textTransform.LookAt(camTrans);
                }

                if (UnityEngine.Component.op_Inequality(this.camTrans, null)) {
                    this._textTransform.forward = this.camTrans.forward.$clone();
                    //_textTransform.localScale = Vector3.one * 1.25f;
                }

            },
            /*BulletDisplayHandler.UpdateRotateText end.*/

            /*BulletDisplayHandler.SetUpdateText start.*/
            SetUpdateText: function (enable) {
if ( TRACE ) { TRACE( "BulletDisplayHandler#SetUpdateText", this ); }

                this.needUpdateText = enable;
            },
            /*BulletDisplayHandler.SetUpdateText end.*/

            /*BulletDisplayHandler.SetFadeText start.*/
            SetFadeText: function (isFaded) {
if ( TRACE ) { TRACE( "BulletDisplayHandler#SetFadeText", this ); }

                this.text.color = isFaded ? new pc.Color( 1.0, 1.0, 1.0, 0.6 ) : new pc.Color( 1, 1, 1, 1 );
            },
            /*BulletDisplayHandler.SetFadeText end.*/

            /*BulletDisplayHandler.ScaleText start.*/
            ScaleText: function (isScale) {
if ( TRACE ) { TRACE( "BulletDisplayHandler#ScaleText", this ); }

                if (this.scaleTwween != null && DG.Tweening.TweenExtensions.IsActive(this.scaleTwween)) {
                    DG.Tweening.TweenExtensions.Kill(this.scaleTwween);
                }
                this.scaleTwween = DG.Tweening.ShortcutExtensions.DOScale(this._textTransform, isScale ? 1.25 : 1.0, 0.2);
            },
            /*BulletDisplayHandler.ScaleText end.*/


        }
    });
    /*BulletDisplayHandler end.*/

    /*CachedSplineTransformPath start.*/
    Bridge.define("CachedSplineTransformPath", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            pathTransforms: null,
            totalDistance: 0,
            sampleCount: 0,
            resolution: 0,
            isLocalSpace: false,
            spaceReference: null,
            version: null,
            cumulativeDistances: null,
            isDistanceCacheDirty: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "CachedSplineTransformPath#init", this ); }

                this.pathTransforms = new (System.Collections.Generic.List$1(UnityEngine.Transform)).ctor();
                this.isLocalSpace = false;
                this.version = "1.0";
                this.isDistanceCacheDirty = true;
            }
        },
        methods: {
            /*CachedSplineTransformPath.IsValid start.*/
            IsValid: function () {
if ( TRACE ) { TRACE( "CachedSplineTransformPath#IsValid", this ); }

                // Check if the path transforms count has changed, which means cache should be refreshed
                if (this.pathTransforms != null && this.cumulativeDistances != null) {
                    if (this.pathTransforms.Count !== this.cumulativeDistances.Count) {
                        this.isDistanceCacheDirty = true;
                    }
                }

                return this.pathTransforms != null && this.pathTransforms.Count > 0;
            },
            /*CachedSplineTransformPath.IsValid end.*/

            /*CachedSplineTransformPath.GetPositionAtTF start.*/
            GetPositionAtTF: function (tf) {
if ( TRACE ) { TRACE( "CachedSplineTransformPath#GetPositionAtTF", this ); }

                if (!this.IsValid() || this.pathTransforms.Count < 2) {
                    return pc.Vec3.ZERO.clone();
                }

                tf = Math.max(0, Math.min(1, tf));

                // Convert TF to true position using arc-length parameterization
                var truePosition = this.GetTrueTfFromNormalizedTf(tf);

                // Find the two closest transforms
                var index1 = Math.floor(truePosition);
                var index2 = UnityEngine.Mathf.Min(((index1 + 1) | 0), ((this.pathTransforms.Count - 1) | 0));

                var lerpFactor = (truePosition - index1);

                var pos1 = this.GetTransformPosition(this.pathTransforms.getItem(index1));
                var pos2 = this.GetTransformPosition(this.pathTransforms.getItem(index2));

                return new pc.Vec3().lerp( pos1, pos2, lerpFactor );
            },
            /*CachedSplineTransformPath.GetPositionAtTF end.*/

            /*CachedSplineTransformPath.GetTangentAtTF start.*/
            GetTangentAtTF: function (tf) {
if ( TRACE ) { TRACE( "CachedSplineTransformPath#GetTangentAtTF", this ); }

                if (!this.IsValid() || this.pathTransforms.Count < 2) {
                    return new pc.Vec3( 0, 0, 1 );
                }

                tf = Math.max(0, Math.min(1, tf));

                // Convert TF to true position using arc-length parameterization
                var truePosition = this.GetTrueTfFromNormalizedTf(tf);

                // Find the two closest transforms
                var index1 = Math.floor(truePosition);
                var index2 = UnityEngine.Mathf.Min(((index1 + 1) | 0), ((this.pathTransforms.Count - 1) | 0));

                var pos1 = this.GetTransformPosition(this.pathTransforms.getItem(index1));
                var pos2 = this.GetTransformPosition(this.pathTransforms.getItem(index2));

                var tangent = (pos2.$clone().sub( pos1 )).clone().normalize().$clone();

                return !pc.Vec3.equals( tangent, pc.Vec3.ZERO.clone() ) ? tangent.$clone() : new pc.Vec3( 0, 0, 1 );
            },
            /*CachedSplineTransformPath.GetTangentAtTF end.*/

            /*CachedSplineTransformPath.GetUpVectorAtTF start.*/
            GetUpVectorAtTF: function (tf) {
if ( TRACE ) { TRACE( "CachedSplineTransformPath#GetUpVectorAtTF", this ); }

                if (!this.IsValid() || this.pathTransforms.Count < 2) {
                    return pc.Vec3.UP.clone();
                }

                tf = Math.max(0, Math.min(1, tf));

                // Convert TF to true position using arc-length parameterization
                var truePosition = this.GetTrueTfFromNormalizedTf(tf);

                // Find the two closest transforms
                var index1 = Math.floor(truePosition);
                var index2 = UnityEngine.Mathf.Min(((index1 + 1) | 0), ((this.pathTransforms.Count - 1) | 0));

                var lerpFactor = (truePosition - index1);

                var up1 = this.GetTransformUpVector(this.pathTransforms.getItem(index1));
                var up2 = this.GetTransformUpVector(this.pathTransforms.getItem(index2));

                var upVector = new pc.Vec3().lerp( up1, up2, lerpFactor );

                return !pc.Vec3.equals( upVector, pc.Vec3.ZERO.clone() ) ? upVector.clone().normalize().$clone() : pc.Vec3.UP.clone();
            },
            /*CachedSplineTransformPath.GetUpVectorAtTF end.*/

            /*CachedSplineTransformPath.GetPositionAtDistance start.*/
            GetPositionAtDistance: function (distance) {
if ( TRACE ) { TRACE( "CachedSplineTransformPath#GetPositionAtDistance", this ); }

                if (!this.IsValid() || this.totalDistance <= 0) {
                    return pc.Vec3.ZERO.clone();
                }

                var tf = Math.max(0, Math.min(1, distance / this.totalDistance));
                return this.GetPositionAtTF(tf);
            },
            /*CachedSplineTransformPath.GetPositionAtDistance end.*/

            /*CachedSplineTransformPath.GetTangentAtDistance start.*/
            GetTangentAtDistance: function (distance) {
if ( TRACE ) { TRACE( "CachedSplineTransformPath#GetTangentAtDistance", this ); }

                if (!this.IsValid() || this.totalDistance <= 0) {
                    return new pc.Vec3( 0, 0, 1 );
                }

                var tf = Math.max(0, Math.min(1, distance / this.totalDistance));
                return this.GetTangentAtTF(tf);
            },
            /*CachedSplineTransformPath.GetTangentAtDistance end.*/

            /*CachedSplineTransformPath.GetUpVectorAtDistance start.*/
            GetUpVectorAtDistance: function (distance) {
if ( TRACE ) { TRACE( "CachedSplineTransformPath#GetUpVectorAtDistance", this ); }

                if (!this.IsValid() || this.totalDistance <= 0) {
                    return pc.Vec3.UP.clone();
                }

                var tf = Math.max(0, Math.min(1, distance / this.totalDistance));
                return this.GetUpVectorAtTF(tf);
            },
            /*CachedSplineTransformPath.GetUpVectorAtDistance end.*/

            /*CachedSplineTransformPath.GetTransformPosition start.*/
            GetTransformPosition: function (t) {
if ( TRACE ) { TRACE( "CachedSplineTransformPath#GetTransformPosition", this ); }

                if (UnityEngine.Component.op_Equality(t, null)) {
                    return pc.Vec3.ZERO.clone();
                }
                return t.position.$clone();
            },
            /*CachedSplineTransformPath.GetTransformPosition end.*/

            /*CachedSplineTransformPath.GetTransformUpVector start.*/
            GetTransformUpVector: function (t) {
if ( TRACE ) { TRACE( "CachedSplineTransformPath#GetTransformUpVector", this ); }

                if (UnityEngine.Component.op_Equality(t, null)) {
                    return pc.Vec3.UP.clone();
                }
                return t.up.$clone();
            },
            /*CachedSplineTransformPath.GetTransformUpVector end.*/

            /*CachedSplineTransformPath.GetTransformForwardVector start.*/
            GetTransformForwardVector: function (t) {
if ( TRACE ) { TRACE( "CachedSplineTransformPath#GetTransformForwardVector", this ); }

                if (UnityEngine.Component.op_Equality(t, null)) {
                    return new pc.Vec3( 0, 0, 1 );
                }
                return t.forward.$clone();
            },
            /*CachedSplineTransformPath.GetTransformForwardVector end.*/

            /*CachedSplineTransformPath.MarkDistanceCacheDirty start.*/
            MarkDistanceCacheDirty: function () {
if ( TRACE ) { TRACE( "CachedSplineTransformPath#MarkDistanceCacheDirty", this ); }

                this.isDistanceCacheDirty = true;
            },
            /*CachedSplineTransformPath.MarkDistanceCacheDirty end.*/

            /*CachedSplineTransformPath.CalculateTotalDistance start.*/
            CalculateTotalDistance: function () {
if ( TRACE ) { TRACE( "CachedSplineTransformPath#CalculateTotalDistance", this ); }

                if (!this.IsValid() || this.pathTransforms.Count < 2) {
                    return 0.0;
                }

                var distance = 0.0;
                for (var i = 1; i < this.pathTransforms.Count; i = (i + 1) | 0) {
                    if (UnityEngine.Component.op_Inequality(this.pathTransforms.getItem(i), null) && UnityEngine.Component.op_Inequality(this.pathTransforms.getItem(((i - 1) | 0)), null)) {
                        distance += pc.Vec3.distance( this.GetTransformPosition(this.pathTransforms.getItem(((i - 1) | 0))), this.GetTransformPosition(this.pathTransforms.getItem(i)) );
                    }
                }

                return distance;
            },
            /*CachedSplineTransformPath.CalculateTotalDistance end.*/

            /*CachedSplineTransformPath.CalculateCumulativeDistances start.*/
            CalculateCumulativeDistances: function () {
if ( TRACE ) { TRACE( "CachedSplineTransformPath#CalculateCumulativeDistances", this ); }

                if (!this.IsValid() || this.pathTransforms.Count < 2) {
                    this.cumulativeDistances = null;
                    return;
                }

                this.cumulativeDistances = new (System.Collections.Generic.List$1(System.Single)).ctor();
                this.cumulativeDistances.add(0.0); // Start at 0

                var cumulativeDistance = 0.0;
                for (var i = 1; i < this.pathTransforms.Count; i = (i + 1) | 0) {
                    if (UnityEngine.Component.op_Inequality(this.pathTransforms.getItem(i), null) && UnityEngine.Component.op_Inequality(this.pathTransforms.getItem(((i - 1) | 0)), null)) {
                        var segmentDistance = pc.Vec3.distance( this.GetTransformPosition(this.pathTransforms.getItem(((i - 1) | 0))), this.GetTransformPosition(this.pathTransforms.getItem(i)) );
                        cumulativeDistance += segmentDistance;
                        this.cumulativeDistances.add(cumulativeDistance);
                    } else {
                        // If a transform is null, maintain the same distance value
                        this.cumulativeDistances.add(cumulativeDistance);
                    }
                }

                this.totalDistance = cumulativeDistance;
                this.isDistanceCacheDirty = false;
            },
            /*CachedSplineTransformPath.CalculateCumulativeDistances end.*/

            /*CachedSplineTransformPath.ConvertTfToDistance start.*/
            ConvertTfToDistance: function (tf) {
if ( TRACE ) { TRACE( "CachedSplineTransformPath#ConvertTfToDistance", this ); }

                if (!this.IsValid() || this.cumulativeDistances == null || this.cumulativeDistances.Count === 0) {
                    return 0.0;
                }

                tf = Math.max(0, Math.min(1, tf));
                var targetDistance = tf * this.totalDistance;

                // Find the segment that contains the target distance
                for (var i = 0; i < ((this.cumulativeDistances.Count - 1) | 0); i = (i + 1) | 0) {
                    if (targetDistance >= this.cumulativeDistances.getItem(i) && targetDistance <= this.cumulativeDistances.getItem(((i + 1) | 0))) {
                        if (this.cumulativeDistances.getItem(((i + 1) | 0)) === this.cumulativeDistances.getItem(i)) {
                            return i;
                        } // Handle case where distances are the same

                        var segmentT = (targetDistance - this.cumulativeDistances.getItem(i)) / (this.cumulativeDistances.getItem(((i + 1) | 0)) - this.cumulativeDistances.getItem(i));
                        return i + segmentT;
                    }
                }

                // Handle edge cases (end of path)
                return ((this.pathTransforms.Count - 1) | 0);
            },
            /*CachedSplineTransformPath.ConvertTfToDistance end.*/

            /*CachedSplineTransformPath.ConvertDistanceToTf start.*/
            ConvertDistanceToTf: function (distance) {
if ( TRACE ) { TRACE( "CachedSplineTransformPath#ConvertDistanceToTf", this ); }

                if (!this.IsValid() || this.cumulativeDistances == null || this.cumulativeDistances.Count === 0) {
                    return 0.0;
                }

                distance = Math.max(0.0, Math.min(distance, this.totalDistance));

                // Find the segment that contains the target distance
                for (var i = 0; i < ((this.cumulativeDistances.Count - 1) | 0); i = (i + 1) | 0) {
                    if (distance >= this.cumulativeDistances.getItem(i) && distance <= this.cumulativeDistances.getItem(((i + 1) | 0))) {
                        if (this.cumulativeDistances.getItem(((i + 1) | 0)) === this.cumulativeDistances.getItem(i)) {
                            return i / (((this.pathTransforms.Count - 1) | 0));
                        } // Handle case where distances are the same

                        var segmentT = (distance - this.cumulativeDistances.getItem(i)) / (this.cumulativeDistances.getItem(((i + 1) | 0)) - this.cumulativeDistances.getItem(i));
                        return Math.max(0, Math.min(1, (i + segmentT) / (((this.pathTransforms.Count - 1) | 0))));
                    }
                }

                // Handle edge cases (end of path)
                return 1.0;
            },
            /*CachedSplineTransformPath.ConvertDistanceToTf end.*/

            /*CachedSplineTransformPath.GetTrueTfFromNormalizedTf start.*/
            GetTrueTfFromNormalizedTf: function (normalizedTf) {
if ( TRACE ) { TRACE( "CachedSplineTransformPath#GetTrueTfFromNormalizedTf", this ); }

                if (this.isDistanceCacheDirty || this.cumulativeDistances == null) {
                    this.CalculateCumulativeDistances();
                }

                if (this.cumulativeDistances == null || this.cumulativeDistances.Count < 2) {
                    // Fall back to linear parameterization if arc-length is not available
                    return normalizedTf * (((this.pathTransforms.Count - 1) | 0));
                }

                // Convert the normalized TF (0-1) to the true position based on arc-length
                var truePosition = this.ConvertTfToDistance(normalizedTf);
                return truePosition;
            },
            /*CachedSplineTransformPath.GetTrueTfFromNormalizedTf end.*/


        }
    });
    /*CachedSplineTransformPath end.*/

    /*CachedTransformPathMover start.*/
    Bridge.define("CachedTransformPathMover", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            speed: 0,
            currentTF: 0,
            endTF: 0,
            direction: 0,
            useDistanceBasedMovement: false,
            currentDistance: 0,
            movementType: 0,
            PingPongClamp: null,
            LoopClamp: null,
            autoMove: false,
            orientToPath: false,
            orientationSpace: 0,
            smoothOrientation: false,
            orientationSpeed: 0,
            rotationInterpolation: 0,
            targetRotation: null,
            previousTargetRotation: null,
            pathValid: false,
            moverTransform: null,
            cachedDeltaTime: 0,
            cachedOrientationSpeedDeltaTime: 0,
            cachedSmoothOrientation: false,
            cachedPosition: null,
            cachedTangent: null,
            cachedUpVector: null,
            cachedNewRotation: null,
            shouldUpdateOrientation: false,
            startDelayTimer: 0,
            isWaitingToStart: false,
            isInitialized: false,
            OnMoveFinished: null
        },
        props: {
            Path: {
                get: function () {
if ( TRACE ) { TRACE( "CachedTransformPathMover#Path#get", this ); }

                    return PathTransformBasedCached.Instance;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "CachedTransformPathMover#init", this ); }

                this.PingPongClamp = new UnityEngine.Vector2();
                this.LoopClamp = new UnityEngine.Vector2();
                this.targetRotation = new UnityEngine.Quaternion();
                this.previousTargetRotation = new UnityEngine.Quaternion();
                this.cachedPosition = new UnityEngine.Vector3();
                this.cachedTangent = new UnityEngine.Vector3();
                this.cachedUpVector = new UnityEngine.Vector3();
                this.cachedNewRotation = new UnityEngine.Quaternion();
                this.speed = 1.0;
                this.currentTF = 0.0;
                this.endTF = 1.0;
                this.direction = 1;
                this.useDistanceBasedMovement = false;
                this.currentDistance = 0.0;
                this.movementType = CachedTransformPathMover.MovementType.Clamp;
                this.PingPongClamp = new pc.Vec2( 0.0, 1.0 );
                this.LoopClamp = new pc.Vec2( 0.0, 1.0 );
                this.autoMove = true;
                this.orientToPath = true;
                this.orientationSpace = UnityEngine.Space.World;
                this.smoothOrientation = true;
                this.orientationSpeed = 5.0;
                this.rotationInterpolation = CachedTransformPathMover.RotationInterpolationType.Spherical;
                this.pathValid = false;
                this.shouldUpdateOrientation = false;
                this.startDelayTimer = 0.2;
                this.isWaitingToStart = true;
                this.isInitialized = false;
            }
        },
        methods: {
            /*CachedTransformPathMover.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "CachedTransformPathMover#Start", this ); }

                this.Initialize();
                this.moverTransform = this.transform;
                this.targetRotation = this.moverTransform.rotation.$clone();
                this.previousTargetRotation = this.moverTransform.rotation.$clone();
            },
            /*CachedTransformPathMover.Start end.*/

            /*CachedTransformPathMover.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "CachedTransformPathMover#Update", this ); }


                if (this.autoMove && this.pathValid) {
                    // Logic ch Delay
                    if (this.isWaitingToStart) {
                        this.startDelayTimer -= UnityEngine.Time.deltaTime;
                        if (this.startDelayTimer <= 0) {
                            this.isWaitingToStart = false;
                        }
                        return; // Cha lm g c trong lc ch
                    }
                    this.MoveAlongPath();
                }
            },
            /*CachedTransformPathMover.Update end.*/

            /*CachedTransformPathMover.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "CachedTransformPathMover#Initialize", this ); }

                this.pathValid = false;
                if (!this.Path.IsValid()) {
                    UnityEngine.Debug.LogError$2("CachedSplineTransformPath contains invalid data!", this);
                    return;
                }

                // Mark the distance cache as dirty to trigger recalculation
                this.Path.MarkDistanceCacheDirty();

                // Calculate total distance if not already set
                if (this.Path.totalDistance <= 0) {
                    this.Path.totalDistance = this.Path.CalculateTotalDistance();
                }

                if (this.autoMove) {
                    this.SetPositionByTF(this.currentTF);
                }

                this.pathValid = true;
                this.isInitialized = true;
            },
            /*CachedTransformPathMover.Initialize end.*/

            /*CachedTransformPathMover.PauseMovement start.*/
            PauseMovement: function () {
if ( TRACE ) { TRACE( "CachedTransformPathMover#PauseMovement", this ); }

                this.SetSpeed(0.0);
                //movementHandle.PauseMovement();
            },
            /*CachedTransformPathMover.PauseMovement end.*/

            /*CachedTransformPathMover.MoveAlongPath start.*/
            MoveAlongPath: function () {
if ( TRACE ) { TRACE( "CachedTransformPathMover#MoveAlongPath", this ); }

                if (!this.isInitialized || !this.pathValid) {
                    return;
                }

                // Cache deltaTime to avoid multiple calls to Time.deltaTime per frame
                this.cachedDeltaTime = UnityEngine.Time.deltaTime;
                var movementDelta = this.speed * this.cachedDeltaTime * this.direction;

                if (this.useDistanceBasedMovement) {
                    // Update distance-based position
                    this.currentDistance += movementDelta;

                    // Handle movement type based on distance
                    switch (this.movementType) {
                        case CachedTransformPathMover.MovementType.Clamp: 
                            var maxDistance = this.endTF * this.Path.totalDistance;
                            this.currentDistance = Math.max(0.0, Math.min(this.currentDistance, maxDistance));
                            // Update TF to match distance
                            this.currentTF = this.currentDistance / this.Path.totalDistance;
                            if ((this.direction > 0 && UnityEngine.Mathf.Approximately(this.currentTF, this.endTF)) || (this.direction < 0 && UnityEngine.Mathf.Approximately(this.currentTF, 0.0))) {
                                this.StopMovement();
                                return;
                            }
                            break;
                        case CachedTransformPathMover.MovementType.Loop: 
                            if (this.currentDistance > this.Path.totalDistance) {
                                this.currentDistance = 0.0;
                            } else {
                                if (this.currentDistance < 0.0) {
                                    this.currentDistance = this.Path.totalDistance;
                                }
                            }
                            // Update TF to match distance
                            this.currentTF = (this.currentDistance < 0) ? 0 : this.currentDistance / this.Path.totalDistance;
                            if (this.currentDistance < 0) {
                                this.currentTF = 1.0 + this.currentTF;
                            } // For negative values
                            this.currentTF = this.currentTF - Math.floor(this.currentTF / 1.0) * 1.0;
                            break;
                        case CachedTransformPathMover.MovementType.PingPong: 
                            var pingPongMaxDistance = this.endTF * this.Path.totalDistance;
                            if (this.currentDistance > pingPongMaxDistance) {
                                this.currentDistance = pingPongMaxDistance;
                                this.direction = -1; // Reverse direction to go backward
                            } else if (this.currentDistance < 0.0) {
                                this.currentDistance = 0.0;
                                this.direction = 1; // Reverse direction to go forward
                            }
                            // Update TF to match distance
                            this.currentTF = this.currentDistance / this.Path.totalDistance;
                            break;
                    }

                    // Update position based on current distance
                    this.UpdatePositionByDistance(this.currentDistance);
                } else {
                    // Update TF-based position - movementDelta already includes direction
                    this.currentTF += movementDelta / this.Path.totalDistance;

                    // Handle movement type based on TF
                    switch (this.movementType) {
                        case CachedTransformPathMover.MovementType.Clamp: 
                            this.currentTF = Math.max(0.0, Math.min(this.currentTF, this.endTF));
                            this.currentDistance = this.currentTF * this.Path.totalDistance;
                            if ((this.direction > 0 && UnityEngine.Mathf.Approximately(this.currentTF, this.endTF)) || (this.direction < 0 && UnityEngine.Mathf.Approximately(this.currentTF, 0.0))) {
                                this.StopMovement();
                                return;
                            }
                            break;
                        case CachedTransformPathMover.MovementType.Loop: 
                            this.currentTF = this.currentTF - Math.floor(this.currentTF / 1.0) * 1.0;
                            this.currentDistance = this.currentTF * this.Path.totalDistance;
                            break;
                        case CachedTransformPathMover.MovementType.PingPong: 
                            if (this.currentTF > this.PingPongClamp.y) {
                                this.currentTF = this.endTF;
                                this.direction = -1; // Reverse direction to go backward
                            } else if (this.currentTF < this.PingPongClamp.x) {
                                this.currentTF = 0.0;
                                this.direction = 1; // Reverse direction to go forward
                            }
                            this.currentDistance = this.currentTF * this.Path.totalDistance;
                            break;
                        case CachedTransformPathMover.MovementType.LoopClamp: 
                            if (this.currentTF > this.LoopClamp.y) {
                                this.currentTF = this.LoopClamp.x;
                                this.direction = -1; // Reverse direction to go backward
                            }
                            this.currentDistance = this.currentTF * this.Path.totalDistance;
                            break;
                    }

                    // Update position based on current TF
                    this.UpdatePositionByTF(this.currentTF);
                }
            },
            /*CachedTransformPathMover.MoveAlongPath end.*/

            /*CachedTransformPathMover.SetPositionByTF start.*/
            SetPositionByTF: function (tf) {
if ( TRACE ) { TRACE( "CachedTransformPathMover#SetPositionByTF", this ); }

                if (!this.pathValid) {
                    return;
                }

                if (this.movementType === CachedTransformPathMover.MovementType.Clamp) {
                    this.currentTF = Math.max(0.0, Math.min(tf, this.endTF));
                } else {
                    this.currentTF = Math.max(0, Math.min(1, tf));
                }

                this.currentDistance = this.currentTF * this.Path.totalDistance;
                this.UpdatePositionByTF(this.currentTF);
            },
            /*CachedTransformPathMover.SetPositionByTF end.*/

            /*CachedTransformPathMover.SetPositionByDistance start.*/
            SetPositionByDistance: function (distance) {
if ( TRACE ) { TRACE( "CachedTransformPathMover#SetPositionByDistance", this ); }

                if (!this.pathValid) {
                    return;
                }

                if (this.movementType === CachedTransformPathMover.MovementType.Clamp) {
                    var maxDistance = this.endTF * this.Path.totalDistance;
                    this.currentDistance = Math.max(0.0, Math.min(distance, maxDistance));
                } else {
                    this.currentDistance = Math.max(0.0, Math.min(distance, this.Path.totalDistance));
                }

                this.currentTF = this.currentDistance / this.Path.totalDistance;
                this.UpdatePositionByDistance(this.currentDistance);
            },
            /*CachedTransformPathMover.SetPositionByDistance end.*/

            /*CachedTransformPathMover.UpdatePositionByTF start.*/
            UpdatePositionByTF: function (tf) {
if ( TRACE ) { TRACE( "CachedTransformPathMover#UpdatePositionByTF", this ); }

                if (!this.pathValid) {
                    return;
                }

                // Get interpolated position, tangent, and up-vector at the given TF
                // Using cached values to reduce allocations
                this.cachedPosition = this.Path.GetPositionAtTF(tf);
                this.cachedTangent = this.Path.GetTangentAtTF(tf);
                this.cachedUpVector = this.Path.GetUpVectorAtTF(tf);

                // Update the transform position
                this.moverTransform.position = this.cachedPosition.$clone();

                // Update orientation if enabled
                if (this.orientToPath) {
                    if (!pc.Vec3.equals( this.cachedTangent, pc.Vec3.ZERO.clone() )) {
                        // Pre-calculate orientation speed * deltaTime to avoid repeated calculations
                        this.cachedOrientationSpeedDeltaTime = this.orientationSpeed * this.cachedDeltaTime;
                        this.cachedSmoothOrientation = this.smoothOrientation;

                        if (this.orientationSpace === UnityEngine.Space.Self) {
                            // Convert to local space if needed
                            this.cachedNewRotation = UnityEngine.Object.op_Implicit(this.moverTransform.parent) ? this.moverTransform.parent.rotation.clone().mul( new pc.Quat().lookRotation( this.cachedTangent, this.cachedUpVector ) ) : new pc.Quat().lookRotation( this.cachedTangent, this.cachedUpVector );
                        } else {
                            this.cachedNewRotation = new pc.Quat().lookRotation( this.cachedTangent, this.cachedUpVector );
                        }

                        if (this.cachedSmoothOrientation) {
                            // Only interpolate if the target rotation has changed
                            if (( this.cachedNewRotation == null && this.previousTargetRotation != null ) || ( this.cachedNewRotation != null && this.previousTargetRotation == null ) || ( this.cachedNewRotation != null && !this.cachedNewRotation.equals( this.previousTargetRotation ) )) {
                                this.targetRotation = this.cachedNewRotation.$clone();
                                this.previousTargetRotation = this.cachedNewRotation.$clone();
                            }

                            // Smoothly interpolate to the target rotation using selected method
                            switch (this.rotationInterpolation) {
                                case CachedTransformPathMover.RotationInterpolationType.Spherical: 
                                    this.moverTransform.rotation = new pc.Quat().slerpUnclamped( this.moverTransform.rotation, this.targetRotation, pc.math.clamp( this.cachedOrientationSpeedDeltaTime, 0, 1 ) );
                                    break;
                                case CachedTransformPathMover.RotationInterpolationType.Linear: 
                                    this.moverTransform.rotation = new pc.Quat().lerpUnclamped( this.moverTransform.rotation, this.targetRotation, pc.math.clamp( this.cachedOrientationSpeedDeltaTime, 0, 1 ) );
                                    break;
                            }
                        } else {
                            // Instant orientation (original behavior)
                            this.moverTransform.rotation = this.cachedNewRotation.$clone();
                            this.targetRotation = this.cachedNewRotation.$clone();
                            this.previousTargetRotation = this.cachedNewRotation.$clone();
                        }
                    }
                }
            },
            /*CachedTransformPathMover.UpdatePositionByTF end.*/

            /*CachedTransformPathMover.UpdatePositionByDistance start.*/
            UpdatePositionByDistance: function (distance) {
if ( TRACE ) { TRACE( "CachedTransformPathMover#UpdatePositionByDistance", this ); }

                if (!this.pathValid) {
                    return;
                }

                // Convert distance to TF and call the TF-based update
                var tf = distance / this.Path.totalDistance;
                this.UpdatePositionByTF(tf);
            },
            /*CachedTransformPathMover.UpdatePositionByDistance end.*/

            /*CachedTransformPathMover.GetPositionAtTF start.*/
            GetPositionAtTF: function (tf) {
if ( TRACE ) { TRACE( "CachedTransformPathMover#GetPositionAtTF", this ); }

                if (!this.pathValid) {
                    return this.moverTransform.position.$clone();
                }

                return this.Path.GetPositionAtTF(tf);
            },
            /*CachedTransformPathMover.GetPositionAtTF end.*/

            /*CachedTransformPathMover.GetTangentAtTF start.*/
            GetTangentAtTF: function (tf) {
if ( TRACE ) { TRACE( "CachedTransformPathMover#GetTangentAtTF", this ); }

                if (!this.pathValid) {
                    return new pc.Vec3( 0, 0, 1 );
                }

                return this.Path.GetTangentAtTF(tf);
            },
            /*CachedTransformPathMover.GetTangentAtTF end.*/

            /*CachedTransformPathMover.GetUpVectorAtTF start.*/
            GetUpVectorAtTF: function (tf) {
if ( TRACE ) { TRACE( "CachedTransformPathMover#GetUpVectorAtTF", this ); }

                if (!this.pathValid) {
                    return pc.Vec3.UP.clone();
                }

                return this.Path.GetUpVectorAtTF(tf);
            },
            /*CachedTransformPathMover.GetUpVectorAtTF end.*/

            /*CachedTransformPathMover.GetPositionAtDistance start.*/
            GetPositionAtDistance: function (distance) {
if ( TRACE ) { TRACE( "CachedTransformPathMover#GetPositionAtDistance", this ); }

                if (!this.pathValid) {
                    return this.moverTransform.position.$clone();
                }

                return this.Path.GetPositionAtDistance(distance);
            },
            /*CachedTransformPathMover.GetPositionAtDistance end.*/

            /*CachedTransformPathMover.GetTangentAtDistance start.*/
            GetTangentAtDistance: function (distance) {
if ( TRACE ) { TRACE( "CachedTransformPathMover#GetTangentAtDistance", this ); }

                if (!this.pathValid) {
                    return new pc.Vec3( 0, 0, 1 );
                }

                return this.Path.GetTangentAtDistance(distance);
            },
            /*CachedTransformPathMover.GetTangentAtDistance end.*/

            /*CachedTransformPathMover.GetUpVectorAtDistance start.*/
            GetUpVectorAtDistance: function (distance) {
if ( TRACE ) { TRACE( "CachedTransformPathMover#GetUpVectorAtDistance", this ); }

                if (!this.pathValid) {
                    return pc.Vec3.UP.clone();
                }

                return this.Path.GetUpVectorAtDistance(distance);
            },
            /*CachedTransformPathMover.GetUpVectorAtDistance end.*/

            /*CachedTransformPathMover.HandleSelectCollector start.*/
            HandleSelectCollector: function (tf, callbackOnFinish) {
if ( TRACE ) { TRACE( "CachedTransformPathMover#HandleSelectCollector", this ); }

                this.StartMovementByTF(tf);
                this.OnMoveFinished = callbackOnFinish;
            },
            /*CachedTransformPathMover.HandleSelectCollector end.*/

            /*CachedTransformPathMover.StartMovementByTF start.*/
            StartMovementByTF: function (targetTF) {
if ( TRACE ) { TRACE( "CachedTransformPathMover#StartMovementByTF", this ); }

                if (this.autoMove) {
                    return;
                }
                this.currentTF = targetTF;
                this.autoMove = true;
                //transform.localEulerAngles = new Vector3(0, 90, 0);
            },
            /*CachedTransformPathMover.StartMovementByTF end.*/

            /*CachedTransformPathMover.StartMovement start.*/
            StartMovement: function () {
if ( TRACE ) { TRACE( "CachedTransformPathMover#StartMovement", this ); }

                if (this.autoMove) {
                    return;
                }
                this.currentTF = 0.01;
                this.autoMove = true;
            },
            /*CachedTransformPathMover.StartMovement end.*/

            /*CachedTransformPathMover.StopMovementAtCurrentPosition start.*/
            StopMovementAtCurrentPosition: function () {
if ( TRACE ) { TRACE( "CachedTransformPathMover#StopMovementAtCurrentPosition", this ); }

                this.autoMove = false;
            },
            /*CachedTransformPathMover.StopMovementAtCurrentPosition end.*/

            /*CachedTransformPathMover.StopMovement start.*/
            StopMovement: function () {
if ( TRACE ) { TRACE( "CachedTransformPathMover#StopMovement", this ); }

                this.autoMove = false;
                !Bridge.staticEquals(this.OnMoveFinished, null) ? this.OnMoveFinished() : null;
                this.OnMoveFinished = null;
            },
            /*CachedTransformPathMover.StopMovement end.*/

            /*CachedTransformPathMover.SetMovementDirection start.*/
            SetMovementDirection: function (newDirection) {
if ( TRACE ) { TRACE( "CachedTransformPathMover#SetMovementDirection", this ); }

                this.direction = (newDirection >= 0) ? 1 : -1;
            },
            /*CachedTransformPathMover.SetMovementDirection end.*/

            /*CachedTransformPathMover.IsPathValid start.*/
            IsPathValid: function () {
if ( TRACE ) { TRACE( "CachedTransformPathMover#IsPathValid", this ); }

                return this.pathValid;
            },
            /*CachedTransformPathMover.IsPathValid end.*/

            /*CachedTransformPathMover.SetSpeed start.*/
            SetSpeed: function (newSpeed) {
if ( TRACE ) { TRACE( "CachedTransformPathMover#SetSpeed", this ); }

                this.speed = UnityEngine.Mathf.Max(0.0, newSpeed);
            },
            /*CachedTransformPathMover.SetSpeed end.*/

            /*CachedTransformPathMover.SetDirection start.*/
            SetDirection: function (newDirection) {
if ( TRACE ) { TRACE( "CachedTransformPathMover#SetDirection", this ); }

                this.direction = newDirection;
            },
            /*CachedTransformPathMover.SetDirection end.*/

            /*CachedTransformPathMover.ChangeMovementType start.*/
            ChangeMovementType: function (newType) {
if ( TRACE ) { TRACE( "CachedTransformPathMover#ChangeMovementType", this ); }

                this.movementType = newType;
            },
            /*CachedTransformPathMover.ChangeMovementType end.*/


        }
    });
    /*CachedTransformPathMover end.*/

    /*CachedTransformPathMover+MovementType start.*/
    Bridge.define("CachedTransformPathMover.MovementType", {
        $kind: 1006,
        statics: {
            fields: {
                Clamp: 0,
                Loop: 1,
                PingPong: 2,
                LoopClamp: 3
            }
        }
    });
    /*CachedTransformPathMover+MovementType end.*/

    /*CachedTransformPathMover+RotationInterpolationType start.*/
    Bridge.define("CachedTransformPathMover.RotationInterpolationType", {
        $kind: 1006,
        statics: {
            fields: {
                Spherical: 0,
                Linear: 1
            }
        }
    });
    /*CachedTransformPathMover+RotationInterpolationType end.*/

    /*CollectorAnimation start.*/
    Bridge.define("CollectorAnimation", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            CollectorController: null,
            CollectorInfoController: null,
            EffectOptions: null,
            RabbitAnimator: null,
            BoxAnimator: null,
            RootTransform: null,
            RabbitTransform: null,
            DefaultScale: 0,
            OnBeltScale: 0,
            OnDeadScale: 0,
            CollectorBody: null,
            jumpHeight: 0,
            jumpScaleY: 0,
            squashScaleY: 0,
            squashScaleX: 0,
            durationUp: 0,
            durationDown: 0,
            durationRecover: 0,
            upEase: 0,
            downEase: 0,
            recoverEase: 0,
            defaultRabbitRootScale: null,
            defaultCollectorScale: null,
            defaultPos: null,
            cachedJumpSeq: null,
            squashScaleY2: 0,
            squashScaleX2: 0,
            cachedSquashSeq: null,
            ShootAnimation: null,
            ShootRate: 0,
            shootTimer: 0,
            IdleAnimations: null,
            RareIdleAnimation: null,
            EarIdleAnimation: null,
            EarIdleRate: null,
            earIdleTimer: 0,
            earAnimCoroutine: null,
            RabbitRoot: null,
            breathScaleX: 0,
            breathScaleY: 0,
            duration: 0,
            breathTween: null,
            breathAnimCoroutine: null,
            stretchScaleY: 0,
            stretchDuration: 0,
            stretchTween: null,
            BoxJumpAnimation: null,
            BoxRevealAnimation: null,
            BoxRandomRotate: null,
            JumpingToBelt: false,
            tweenPushForward: null,
            tweenPushForwardOnQueue: null,
            tweenMoveToQueuePosition: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "CollectorAnimation#init", this ); }

                this.defaultRabbitRootScale = new UnityEngine.Vector3();
                this.defaultCollectorScale = new UnityEngine.Vector3();
                this.defaultPos = new UnityEngine.Vector3();
                this.EarIdleRate = new UnityEngine.Vector2();
                this.DefaultScale = 1.0;
                this.OnBeltScale = 0.7;
                this.OnDeadScale = 0.6;
                this.jumpHeight = 0.5;
                this.jumpScaleY = 1.4;
                this.squashScaleY = 0.6;
                this.squashScaleX = 0.6;
                this.durationUp = 0.15;
                this.durationDown = 0.1;
                this.durationRecover = 0.1;
                this.upEase = DG.Tweening.Ease.OutQuad;
                this.downEase = DG.Tweening.Ease.InQuad;
                this.recoverEase = DG.Tweening.Ease.OutBack;
                this.squashScaleY2 = 0.6;
                this.squashScaleX2 = 0.6;
                this.ShootRate = 0.2;
                this.shootTimer = 0;
                this.EarIdleRate = new pc.Vec2( 2.0, 6.0 );
                this.earIdleTimer = 0.0;
                this.breathScaleX = 0.9;
                this.breathScaleY = 1.1;
                this.duration = 0.6;
                this.stretchScaleY = 0.6;
                this.stretchDuration = 0.5;
            }
        },
        methods: {
            /*CollectorAnimation.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "CollectorAnimation#Awake", this ); }

                this.RootTransform = this.transform;
                this.RegisterEvents();
            },
            /*CollectorAnimation.Awake end.*/

            /*CollectorAnimation.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "CollectorAnimation#Start", this ); }

                if (UnityEngine.Object.op_Implicit(this.CollectorBody)) {
                    this.defaultRabbitRootScale = this.RabbitRoot.localScale.$clone();
                    this.defaultCollectorScale = this.CollectorBody.localScale.$clone();
                    this.defaultPos = this.CollectorBody.localPosition.$clone();
                    this.CreateJumpTween();
                    this.CacheBreathTween();
                    this.CreateSquashTween();
                    this.CacheStretchTween();
                }
            },
            /*CollectorAnimation.Start end.*/

            /*CollectorAnimation.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "CollectorAnimation#OnEnable", this ); }

                this.shootTimer = this.ShootRate;
                this.JumpingToBelt = false;
                this.earAnimCoroutine = this.StartCoroutine$1(this.StartEarIdleAnimation());
            },
            /*CollectorAnimation.OnEnable end.*/

            /*CollectorAnimation.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "CollectorAnimation#Update", this ); }

                if (this.shootTimer >= 0) {
                    this.shootTimer -= UnityEngine.Time.deltaTime;
                }
            },
            /*CollectorAnimation.Update end.*/

            /*CollectorAnimation.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "CollectorAnimation#OnDisable", this ); }

                this.StopAnimation();
            },
            /*CollectorAnimation.OnDisable end.*/

            /*CollectorAnimation.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "CollectorAnimation#OnDestroy", this ); }

                this.StopAnimation();
                this.UnRegisterEvents();
            },
            /*CollectorAnimation.OnDestroy end.*/

            /*CollectorAnimation.RegisterEvents start.*/
            RegisterEvents: function () {
if ( TRACE ) { TRACE( "CollectorAnimation#RegisterEvents", this ); }

                GameplayEventsManager.OnClickACollector = Bridge.fn.combine(GameplayEventsManager.OnClickACollector, Bridge.fn.cacheBind(this, this.OnClickACollector));
                GameplayEventsManager.OnCollectorStartMove = Bridge.fn.combine(GameplayEventsManager.OnCollectorStartMove, Bridge.fn.cacheBind(this, this.OnCollectorStartMove));
                GameplayEventsManager.OnACollectorMoveToQueue = Bridge.fn.combine(GameplayEventsManager.OnACollectorMoveToQueue, Bridge.fn.cacheBind(this, this.OnCollectorStartMove));
                GameplayEventsManager.OnCollectorMoveToConveyor = Bridge.fn.combine(GameplayEventsManager.OnCollectorMoveToConveyor, Bridge.fn.cacheBind(this, this.OnCollectorMoveToBelt));
                GameplayEventsManager.OnCollectorMoveToFirstLine = Bridge.fn.combine(GameplayEventsManager.OnCollectorMoveToFirstLine, Bridge.fn.cacheBind(this, this.OnCollectorMoveToFirstLine));
            },
            /*CollectorAnimation.RegisterEvents end.*/

            /*CollectorAnimation.UnRegisterEvents start.*/
            UnRegisterEvents: function () {
if ( TRACE ) { TRACE( "CollectorAnimation#UnRegisterEvents", this ); }

                GameplayEventsManager.OnClickACollector = Bridge.fn.remove(GameplayEventsManager.OnClickACollector, Bridge.fn.cacheBind(this, this.OnClickACollector));
                GameplayEventsManager.OnCollectorStartMove = Bridge.fn.remove(GameplayEventsManager.OnCollectorStartMove, Bridge.fn.cacheBind(this, this.OnCollectorStartMove));
                GameplayEventsManager.OnACollectorMoveToQueue = Bridge.fn.remove(GameplayEventsManager.OnACollectorMoveToQueue, Bridge.fn.cacheBind(this, this.OnCollectorStartMove));
                GameplayEventsManager.OnCollectorMoveToConveyor = Bridge.fn.remove(GameplayEventsManager.OnCollectorMoveToConveyor, Bridge.fn.cacheBind(this, this.OnCollectorMoveToBelt));
                GameplayEventsManager.OnCollectorMoveToFirstLine = Bridge.fn.remove(GameplayEventsManager.OnCollectorMoveToFirstLine, Bridge.fn.cacheBind(this, this.OnCollectorMoveToFirstLine));
            },
            /*CollectorAnimation.UnRegisterEvents end.*/

            /*CollectorAnimation.OnCollectorMoveToBelt start.*/
            OnCollectorMoveToBelt: function (_collector) {
if ( TRACE ) { TRACE( "CollectorAnimation#OnCollectorMoveToBelt", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.CollectorController, null) || UnityEngine.MonoBehaviour.op_Equality(_collector, null)) {
                    return;
                }
                if (this.CollectorController.ID !== _collector.ColorCollector.ID) {
                    return;
                }
                this.StopJump();
                this.StopBreathing();
            },
            /*CollectorAnimation.OnCollectorMoveToBelt end.*/

            /*CollectorAnimation.OnCollectorStartMove start.*/
            OnCollectorStartMove: function (_collector) {
if ( TRACE ) { TRACE( "CollectorAnimation#OnCollectorStartMove", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.CollectorController, null) || UnityEngine.MonoBehaviour.op_Equality(_collector, null)) {
                    return;
                }
                if (this.CollectorController.ID !== _collector.ColorCollector.ID) {
                    return;
                }
                this.StopBreathing();
            },
            /*CollectorAnimation.OnCollectorStartMove end.*/

            /*CollectorAnimation.OnCollectorMoveToFirstLine start.*/
            OnCollectorMoveToFirstLine: function (_collector, hidden) {
if ( TRACE ) { TRACE( "CollectorAnimation#OnCollectorMoveToFirstLine", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.CollectorController, null) || UnityEngine.MonoBehaviour.op_Equality(_collector, null)) {
                    return;
                }
                if (this.CollectorController.ID !== _collector.ColorCollector.ID) {
                    return;
                }
                this.StartCoroutine$1(this.DelayStartBreathing(hidden ? 1.0 : 0.0));
            },
            /*CollectorAnimation.OnCollectorMoveToFirstLine end.*/

            /*CollectorAnimation.OnClickACollector start.*/
            OnClickACollector: function (_collector, canBeMoved) {
if ( TRACE ) { TRACE( "CollectorAnimation#OnClickACollector", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.CollectorController, null) || UnityEngine.MonoBehaviour.op_Equality(_collector, null)) {
                    return;
                }
                if (this.CollectorController.ID !== _collector.ColorCollector.ID) {
                    return;
                }
                UnityEngine.Component.op_Inequality(this.RabbitAnimator, null) ? this.RabbitAnimator.Rebind() : null;
                if (canBeMoved) {

                } else {
                    this.PlaySquash();
                }
            },
            /*CollectorAnimation.OnClickACollector end.*/

            /*CollectorAnimation.PlayAnim start.*/
            PlayAnim: function (vector3, animState, actionOnComplete) {
if ( TRACE ) { TRACE( "CollectorAnimation#PlayAnim", this ); }

                if (actionOnComplete === void 0) { actionOnComplete = null; }

                switch (animState) {
                    case CollectorAnimState.Idle: 
                        break;
                    case CollectorAnimState.MoveToQueue: 
                        this.MoveToQueuePosition(vector3, actionOnComplete);
                        break;
                    case CollectorAnimState.MoveToConveyorBelt: 
                        this.MoveToBeltPosition(vector3, actionOnComplete);
                        break;
                    case CollectorAnimState.PushForward: 
                        this.PushForwardAnimation(vector3, actionOnComplete);
                        if (UnityEngine.MonoBehaviour.op_Inequality(this.CollectorController, null) && this.CollectorController.VisualHandler.CattonBox.activeSelf) {
                            UnityEngine.MonoBehaviour.op_Inequality(this.BoxRandomRotate, null) ? this.BoxRandomRotate.RandomRotate() : null;
                            this.BoxAnimator.Play$2(this.BoxJumpAnimation);
                        }
                        break;
                    case CollectorAnimState.CompleteColorPixels: 
                        this.CollectorController.VisualHandler.HideRope();
                        this.CompleteColorPixelsAnimation(actionOnComplete);
                        break;
                    case CollectorAnimState.PushForwardOnConveyorBelt: 
                        this.PushForwardOnQueue(vector3, actionOnComplete);
                        break;
                    case CollectorAnimState.UnlockLockObject: 
                        this.UnlockLockObjectAnimation(vector3, actionOnComplete);
                        break;
                    case CollectorAnimState.MoveToDeadPosition: 
                        this.MoveToDeadPosition(vector3, actionOnComplete);
                        break;
                    case CollectorAnimState.MoveToQueueRotateBack: 
                        this.MoveToQueueRotateBack(vector3, actionOnComplete);
                        break;
                    default: 
                        DG.Tweening.ShortcutExtensions.DOMove(this.RootTransform, vector3.$clone(), 0.5);
                        break;
                }
            },
            /*CollectorAnimation.PlayAnim end.*/

            /*CollectorAnimation.MoveToQueuePosition start.*/
            MoveToQueuePosition: function (newPos, actionOnComplete) {
if ( TRACE ) { TRACE( "CollectorAnimation#MoveToQueuePosition", this ); }

                if (actionOnComplete === void 0) { actionOnComplete = null; }
                this.PlayStretch();
                if (this.tweenMoveToQueuePosition != null && DG.Tweening.TweenExtensions.IsActive(this.tweenMoveToQueuePosition)) {
                    DG.Tweening.TweenExtensions.Kill(this.tweenMoveToQueuePosition);
                }
                this.tweenMoveToQueuePosition = DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.ShortcutExtensions.DOJump(this.RootTransform, newPos.$clone(), 2, 1, 0.4), DG.Tweening.Ease.InOutSine), Bridge.fn.bind(this, function () {
                    !Bridge.staticEquals(actionOnComplete, null) ? actionOnComplete() : null;
                    this.tweenMoveToQueuePosition = null;
                    this.PlaySquash();
                    this.StopStretch();
                    this.StartCoroutine$1(this.DelayStartBreathing());
                }));
                DG.Tweening.ShortcutExtensions.DOScale(this.RabbitTransform, this.DefaultScale, 0.5);
                DG.Tweening.ShortcutExtensions.DOLocalRotate(this.RootTransform, pc.Vec3.ZERO.clone(), 0.3);
            },
            /*CollectorAnimation.MoveToQueuePosition end.*/

            /*CollectorAnimation.MoveToQueueRotateBack start.*/
            MoveToQueueRotateBack: function (newPos, actionOnComplete) {
if ( TRACE ) { TRACE( "CollectorAnimation#MoveToQueueRotateBack", this ); }

                if (actionOnComplete === void 0) { actionOnComplete = null; }
                this.PlayStretch();
                if (this.tweenMoveToQueuePosition != null && DG.Tweening.TweenExtensions.IsActive(this.tweenMoveToQueuePosition)) {
                    DG.Tweening.TweenExtensions.Kill(this.tweenMoveToQueuePosition);
                }
                this.tweenMoveToQueuePosition = DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.ShortcutExtensions.DOJump(this.RootTransform, newPos.$clone(), 2, 1, 0.4), DG.Tweening.Ease.InOutSine), Bridge.fn.bind(this, function () {
                    !Bridge.staticEquals(actionOnComplete, null) ? actionOnComplete() : null;
                    this.tweenMoveToQueuePosition = null;
                    this.PlaySquash();
                    this.StopStretch();
                    this.StartCoroutine$1(this.DelayStartBreathing());
                }));
                DG.Tweening.ShortcutExtensions.DOScale(this.RabbitTransform, this.DefaultScale, 0.5);
                //RootTransform.DOLocalRotate(new Vector3(0, 180, 0), 0.3f);
            },
            /*CollectorAnimation.MoveToQueueRotateBack end.*/

            /*CollectorAnimation.MoveToDeadPosition start.*/
            MoveToDeadPosition: function (newPos, actionOnComplete) {
if ( TRACE ) { TRACE( "CollectorAnimation#MoveToDeadPosition", this ); }

                if (actionOnComplete === void 0) { actionOnComplete = null; }
                this.StopBreathing();
                if (this.tweenMoveToQueuePosition != null && DG.Tweening.TweenExtensions.IsActive(this.tweenMoveToQueuePosition)) {
                    DG.Tweening.TweenExtensions.Kill(this.tweenMoveToQueuePosition);
                }
                this.tweenMoveToQueuePosition = DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.ShortcutExtensions.DOJump(this.RootTransform, newPos.$clone(), 2, 1, 0.3), DG.Tweening.Ease.InOutSine), Bridge.fn.bind(this, function () {
                    !Bridge.staticEquals(actionOnComplete, null) ? actionOnComplete() : null;
                    this.tweenMoveToQueuePosition = null;
                    this.PlaySquash();
                    this.StartCoroutine$1(this.DelayStartBreathing());
                }));
                DG.Tweening.ShortcutExtensions.DOScale(this.RabbitTransform, this.OnDeadScale, 0.5);
                DG.Tweening.ShortcutExtensions.DOLocalRotate(this.RootTransform, pc.Vec3.ZERO.clone(), 0.3);
                //RabbitTransform.DOLocalRotate(new Vector3(0, 180, 0), 0.3f);
            },
            /*CollectorAnimation.MoveToDeadPosition end.*/

            /*CollectorAnimation.MoveToBeltPosition start.*/
            MoveToBeltPosition: function (newPos, actionOnComplete) {
if ( TRACE ) { TRACE( "CollectorAnimation#MoveToBeltPosition", this ); }

                if (actionOnComplete === void 0) { actionOnComplete = null; }
                this.JumpingToBelt = true;
                this.PlayStretch();
                if (this.tweenMoveToQueuePosition != null && DG.Tweening.TweenExtensions.IsActive(this.tweenMoveToQueuePosition)) {
                    DG.Tweening.TweenExtensions.Kill(this.tweenMoveToQueuePosition);
                }
                this.tweenMoveToQueuePosition = DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.ShortcutExtensions.DOJump(this.RootTransform, newPos.$clone(), 2, 1, 0.4), DG.Tweening.Ease.InOutSine), Bridge.fn.bind(this, function () {
                    !Bridge.staticEquals(actionOnComplete, null) ? actionOnComplete() : null;
                    this.tweenMoveToQueuePosition = null;
                    this.PlaySquash();
                    this.StopStretch();
                }));
                DG.Tweening.ShortcutExtensions.DOScale(this.RabbitTransform, this.OnBeltScale, 0.5);
                DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.ShortcutExtensions.DOLocalRotate(this.RootTransform, pc.Vec3.ZERO.clone(), 0.3), Bridge.fn.bind(this, function () {
                    this.JumpingToBelt = false;
                }));
            },
            /*CollectorAnimation.MoveToBeltPosition end.*/

            /*CollectorAnimation.PushForwardAnimation start.*/
            PushForwardAnimation: function (newPos, actionOnComplete) {
if ( TRACE ) { TRACE( "CollectorAnimation#PushForwardAnimation", this ); }

                if (actionOnComplete === void 0) { actionOnComplete = null; }
                if (this.tweenPushForward != null && DG.Tweening.TweenExtensions.IsActive(this.tweenPushForward)) {
                    DG.Tweening.TweenExtensions.Kill(this.tweenPushForward);
                }
                this.tweenPushForward = DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMove(this.RootTransform, newPos.$clone(), 0.3), DG.Tweening.Ease.OutBack), function () {
                    !Bridge.staticEquals(actionOnComplete, null) ? actionOnComplete() : null;
                });
            },
            /*CollectorAnimation.PushForwardAnimation end.*/

            /*CollectorAnimation.PushForwardOnQueue start.*/
            PushForwardOnQueue: function (newPos, actionOnComplete) {
if ( TRACE ) { TRACE( "CollectorAnimation#PushForwardOnQueue", this ); }

                if (actionOnComplete === void 0) { actionOnComplete = null; }
                if (this.tweenPushForwardOnQueue != null && DG.Tweening.TweenExtensions.IsActive(this.tweenPushForwardOnQueue)) {
                    DG.Tweening.TweenExtensions.Kill(this.tweenPushForwardOnQueue);
                }

                this.tweenPushForwardOnQueue = DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMove(this.RootTransform, newPos.$clone(), 0.1), DG.Tweening.Ease.OutBack), function () {
                    !Bridge.staticEquals(actionOnComplete, null) ? actionOnComplete() : null;
                });
            },
            /*CollectorAnimation.PushForwardOnQueue end.*/

            /*CollectorAnimation.CompleteColorPixelsAnimation start.*/
            CompleteColorPixelsAnimation: function (actionOnComplete) {
if ( TRACE ) { TRACE( "CollectorAnimation#CompleteColorPixelsAnimation", this ); }

                if (actionOnComplete === void 0) { actionOnComplete = null; }
                DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.RabbitTransform, pc.Vec3.ZERO.clone(), 0.3), DG.Tweening.Ease.InOutSine), Bridge.fn.bind(this, function () {
                    !Bridge.staticEquals(actionOnComplete, null) ? actionOnComplete() : null;
                    this.gameObject.SetActive(false);
                    this.RabbitTransform.localScale = new pc.Vec3( 1, 1, 1 );

                }));
                DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.ShortcutExtensions.DOLocalRotate(this.RootTransform, new pc.Vec3( 0, 360, 0 ), 0.3, DG.Tweening.RotateMode.FastBeyond360), DG.Tweening.Ease.Linear);

            },
            /*CollectorAnimation.CompleteColorPixelsAnimation end.*/

            /*CollectorAnimation.UnlockLockObjectAnimation start.*/
            UnlockLockObjectAnimation: function (newPos, actionOnComplete) {
if ( TRACE ) { TRACE( "CollectorAnimation#UnlockLockObjectAnimation", this ); }

                if (actionOnComplete === void 0) { actionOnComplete = null; }
                this.gameObject.SetActive(false);
                !Bridge.staticEquals(actionOnComplete, null) ? actionOnComplete() : null;
            },
            /*CollectorAnimation.UnlockLockObjectAnimation end.*/

            /*CollectorAnimation.CreateSquashTween start.*/
            CreateSquashTween: function () {
if ( TRACE ) { TRACE( "CollectorAnimation#CreateSquashTween", this ); }

                // ensure any previous one is killed
                if (this.cachedSquashSeq != null) {
                    DG.Tweening.TweenExtensions.Kill(this.cachedSquashSeq);
                    this.cachedSquashSeq = null;
                }
                this.cachedSquashSeq = DG.Tweening.TweenExtensions.Pause(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetAutoKill$1(DG.Tweening.Sequence, DG.Tweening.DOTween.Sequence(), false));

                DG.Tweening.TweenSettingsExtensions.Append(this.cachedSquashSeq, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(DG.Tweening.DOTween.Sequence(), DG.Tweening.ShortcutExtensions.DOScaleY(this.CollectorBody, this.defaultCollectorScale.y * this.squashScaleY, this.durationDown * 0.6)), DG.Tweening.ShortcutExtensions.DOScaleX(this.CollectorBody, this.defaultCollectorScale.x * this.squashScaleX, this.durationDown * 0.6)));

                // 3) Recover scale back to default
                DG.Tweening.TweenSettingsExtensions.Append(this.cachedSquashSeq, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(DG.Tweening.DOTween.Sequence(), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScaleX(this.CollectorBody, this.defaultCollectorScale.x, this.durationRecover), DG.Tweening.Ease.OutBack)), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScaleY(this.CollectorBody, this.defaultCollectorScale.y, this.durationRecover), DG.Tweening.Ease.OutBack)));
                DG.Tweening.TweenSettingsExtensions.OnRewind(DG.Tweening.Sequence, this.cachedSquashSeq, Bridge.fn.bind(this, function () {
                    this.CollectorBody.localScale = this.defaultCollectorScale.$clone();
                }));
                DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Sequence, this.cachedSquashSeq, Bridge.fn.bind(this, function () {
                    this.CollectorBody.localScale = this.defaultCollectorScale.$clone();
                    // note: we keep sequence alive (SetAutoKill(false)) so it can be restarted
                }));
            },
            /*CollectorAnimation.CreateSquashTween end.*/

            /*CollectorAnimation.PlaySquash start.*/
            PlaySquash: function () {
if ( TRACE ) { TRACE( "CollectorAnimation#PlaySquash", this ); }

                if (this.cachedSquashSeq == null) {
                    return;
                }
                DG.Tweening.TweenExtensions.Restart(this.cachedSquashSeq);
            },
            /*CollectorAnimation.PlaySquash end.*/

            /*CollectorAnimation.CreateJumpTween start.*/
            CreateJumpTween: function () {
if ( TRACE ) { TRACE( "CollectorAnimation#CreateJumpTween", this ); }

                // ensure any previous one is killed
                if (this.cachedJumpSeq != null) {
                    DG.Tweening.TweenExtensions.Kill(this.cachedJumpSeq);
                    this.cachedJumpSeq = null;
                }

                var upY = this.defaultPos.y + this.jumpHeight;

                this.cachedJumpSeq = DG.Tweening.TweenExtensions.Pause(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetAutoKill$1(DG.Tweening.Sequence, DG.Tweening.DOTween.Sequence(), false));

                // 1) Jump up: move up + stretch on Y
                DG.Tweening.TweenSettingsExtensions.Append(this.cachedJumpSeq, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOLocalMoveY(this.CollectorBody, upY, this.durationUp), this.upEase));
                DG.Tweening.TweenSettingsExtensions.Join(this.cachedJumpSeq, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScaleY(this.CollectorBody, this.defaultCollectorScale.y * this.jumpScaleY, this.durationUp), this.upEase));

                // 2) Fall down: move down + squash on landing (we use slightly shorter time)
                DG.Tweening.TweenSettingsExtensions.Append(this.cachedJumpSeq, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOLocalMoveY(this.CollectorBody, this.defaultPos.y, this.durationDown), this.downEase));
                DG.Tweening.TweenSettingsExtensions.Append(this.cachedJumpSeq, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(DG.Tweening.DOTween.Sequence(), DG.Tweening.ShortcutExtensions.DOScaleY(this.CollectorBody, this.defaultCollectorScale.y * this.squashScaleY, this.durationDown * 0.6)), DG.Tweening.ShortcutExtensions.DOScaleX(this.CollectorBody, this.defaultCollectorScale.x * this.squashScaleX, this.durationDown * 0.6)));

                // 3) Recover scale back to default
                DG.Tweening.TweenSettingsExtensions.Append(this.cachedJumpSeq, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(DG.Tweening.DOTween.Sequence(), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScaleX(this.CollectorBody, this.defaultCollectorScale.x, this.durationRecover), this.recoverEase)), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScaleY(this.CollectorBody, this.defaultCollectorScale.y, this.durationRecover), this.recoverEase)));
                DG.Tweening.TweenSettingsExtensions.OnRewind(DG.Tweening.Sequence, this.cachedJumpSeq, Bridge.fn.bind(this, function () {
                    this.CollectorBody.localPosition = this.defaultPos.$clone();
                    this.CollectorBody.localScale = this.defaultCollectorScale.$clone();
                }));
                DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Sequence, this.cachedJumpSeq, Bridge.fn.bind(this, function () {
                    // ensure final exact values
                    this.CollectorBody.localPosition = this.defaultPos.$clone();
                    this.CollectorBody.localScale = this.defaultCollectorScale.$clone();
                    // note: we keep sequence alive (SetAutoKill(false)) so it can be restarted
                }));
            },
            /*CollectorAnimation.CreateJumpTween end.*/

            /*CollectorAnimation.PlayJump start.*/
            PlayJump: function () {
if ( TRACE ) { TRACE( "CollectorAnimation#PlayJump", this ); }

                DG.Tweening.TweenExtensions.Restart(this.cachedJumpSeq);
            },
            /*CollectorAnimation.PlayJump end.*/

            /*CollectorAnimation.PlayBoxReveal start.*/
            PlayBoxReveal: function () {
if ( TRACE ) { TRACE( "CollectorAnimation#PlayBoxReveal", this ); }

                if (this.CollectorController.VisualHandler.CattonBox.activeSelf) {
                    this.BoxAnimator.Play$2(this.BoxRevealAnimation);
                }
            },
            /*CollectorAnimation.PlayBoxReveal end.*/

            /*CollectorAnimation.StopJump start.*/
            StopJump: function () {
if ( TRACE ) { TRACE( "CollectorAnimation#StopJump", this ); }

                if (UnityEngine.Object.op_Implicit(this.CollectorBody)) {
                    DG.Tweening.TweenExtensions.Pause(DG.Tweening.Sequence, this.cachedJumpSeq);
                    this.CollectorBody.localScale = this.defaultCollectorScale.$clone();
                    this.CollectorBody.localPosition = this.defaultPos.$clone();
                }
            },
            /*CollectorAnimation.StopJump end.*/

            /*CollectorAnimation.StartEarIdleAnimation start.*/
            StartEarIdleAnimation: function () {
if ( TRACE ) { TRACE( "CollectorAnimation#StartEarIdleAnimation", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    _r,
                    execute,
                    earOrIdle,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if (!this.EffectOptions.RabbitEarAnimation || UnityEngine.MonoBehaviour.op_Equality(this.CollectorController, null)) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 2;
                                        continue;
                                }
                                case 1: {
                                    return false;
                                }
                                case 2: {
                                    if ( this.EffectOptions.RabbitEarAnimation || this.EffectOptions.RabbitRandomIdleAnimation ) {
                                            $step = 3;
                                            continue;
                                        } 
                                        $step = 8;
                                        continue;
                                }
                                case 3: {
                                    this.earIdleTimer = UnityEngine.Random.Range$1(this.EarIdleRate.x, this.EarIdleRate.y);
                                        $enumerator.current = new UnityEngine.WaitForSeconds(this.earIdleTimer);
                                        $step = 4;
                                        return true;
                                }
                                case 4: {
                                    _r = UnityEngine.Random.Range(0, 100);
                                        execute = _r < this.EffectOptions.IdleRate && this.CollectorInfoController.IndexInColumn < 4;
                                        if (this.CollectorController.BulletLeft > 0) {
                                            $step = 5;
                                            continue;
                                        } else  {
                                            $step = 6;
                                            continue;
                                        }
                                }
                                case 5: {
                                    if (execute && !this.CollectorController.IsCollectorActive) {
                                            if (this.EffectOptions.RabbitEarAnimation) {
                                                _r = UnityEngine.Random.Range(0, 100);
                                                earOrIdle = _r > 50;
                                                this.RabbitAnimator.Rebind();
                                                if (earOrIdle) {
                                                    this.RabbitAnimator.Play$2(this.EarIdleAnimation);
                                                } else {
                                                    if (_r <= 10 && !this.CollectorController.IsHidden) {
                                                        this.RabbitAnimator.Play$2(this.RareIdleAnimation);
                                                    } else {
                                                        this.RabbitAnimator.Play$2(this.IdleAnimations[UnityEngine.Random.Range(0, this.IdleAnimations.length)]);
                                                    }
                                                }
                                            } else {
                                                _r = UnityEngine.Random.Range(0, 100);
                                                if (_r <= 10 && !this.CollectorController.IsHidden) {
                                                    this.RabbitAnimator.Play$2(this.RareIdleAnimation);
                                                } else {
                                                    this.RabbitAnimator.Play$2(this.IdleAnimations[UnityEngine.Random.Range(0, this.IdleAnimations.length)]);
                                                }
                                            }
                                        }
                                    $step = 7;
                                    continue;
                                }
                                case 6: {
                                    return false;
                                }
                                case 7: {
                                    
                                        $step = 2;
                                        continue;
                                }
                                case 8: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*CollectorAnimation.StartEarIdleAnimation end.*/

            /*CollectorAnimation.CacheBreathTween start.*/
            CacheBreathTween: function () {
if ( TRACE ) { TRACE( "CollectorAnimation#CacheBreathTween", this ); }

                var inhaleScale = new pc.Vec3( this.defaultRabbitRootScale.x * this.breathScaleX, this.defaultRabbitRootScale.y * this.breathScaleY, this.defaultRabbitRootScale.z );
                var exhaleScale = this.defaultRabbitRootScale.$clone();

                this.breathTween = DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Append(DG.Tweening.TweenSettingsExtensions.Append(DG.Tweening.DOTween.Sequence(), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.RabbitRoot, inhaleScale.$clone(), this.duration), DG.Tweening.Ease.InOutSine)), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.RabbitRoot, exhaleScale.$clone(), this.duration), DG.Tweening.Ease.InOutSine)), -1, DG.Tweening.LoopType.Restart);
                DG.Tweening.TweenExtensions.Pause(DG.Tweening.Sequence, this.breathTween); // cached but not playing yet
            },
            /*CollectorAnimation.CacheBreathTween end.*/

            /*CollectorAnimation.StartBreathing start.*/
            StartBreathing: function () {
if ( TRACE ) { TRACE( "CollectorAnimation#StartBreathing", this ); }

                DG.Tweening.TweenExtensions.Restart(this.breathTween);
            },
            /*CollectorAnimation.StartBreathing end.*/

            /*CollectorAnimation.DelayStartBreathing start.*/
            DelayStartBreathing: function (extraDelay) {
if ( TRACE ) { TRACE( "CollectorAnimation#DelayStartBreathing", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if (extraDelay === void 0) { extraDelay = 0.0; }
                                        $enumerator.current = new UnityEngine.WaitForSeconds(this.durationDown * 2.7 + UnityEngine.Random.Range$1(0.1, 0.5) + extraDelay);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    DG.Tweening.TweenExtensions.Restart(this.breathTween);

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*CollectorAnimation.DelayStartBreathing end.*/

            /*CollectorAnimation.StopBreathing start.*/
            StopBreathing: function () {
if ( TRACE ) { TRACE( "CollectorAnimation#StopBreathing", this ); }

                if (UnityEngine.Object.op_Implicit(this.RabbitRoot)) {
                    if (this.breathAnimCoroutine != null) {
                        this.StopCoroutine$2(this.breathAnimCoroutine);
                        this.breathAnimCoroutine = null;
                    }
                    DG.Tweening.TweenExtensions.Pause(DG.Tweening.Sequence, this.breathTween);
                    this.RabbitRoot.localScale = this.defaultRabbitRootScale.$clone();
                }
            },
            /*CollectorAnimation.StopBreathing end.*/

            /*CollectorAnimation.PlayShootAnimation start.*/
            PlayShootAnimation: function () {
if ( TRACE ) { TRACE( "CollectorAnimation#PlayShootAnimation", this ); }

                if (this.shootTimer <= 0) {
                    this.shootTimer = this.ShootRate;
                    this.RabbitAnimator.Rebind();
                    this.RabbitAnimator.Play$2(this.ShootAnimation);
                    //DeviceVibrationManager.Instance.ExecuteShootVibration();
                }
            },
            /*CollectorAnimation.PlayShootAnimation end.*/

            /*CollectorAnimation.CacheStretchTween start.*/
            CacheStretchTween: function () {
if ( TRACE ) { TRACE( "CollectorAnimation#CacheStretchTween", this ); }

                if (this.stretchTween != null) {
                    DG.Tweening.TweenExtensions.Kill(this.stretchTween);
                    this.stretchTween = null;
                }
                this.stretchTween = DG.Tweening.TweenExtensions.Pause(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetAutoKill$1(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Append(DG.Tweening.DOTween.Sequence(), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScaleY(this.CollectorBody, this.stretchScaleY, this.stretchDuration), DG.Tweening.Ease.InOutSine)), false));
                DG.Tweening.TweenExtensions.Pause(DG.Tweening.Sequence, this.stretchTween);
            },
            /*CollectorAnimation.CacheStretchTween end.*/

            /*CollectorAnimation.PlayStretch start.*/
            PlayStretch: function () {
if ( TRACE ) { TRACE( "CollectorAnimation#PlayStretch", this ); }

                DG.Tweening.TweenExtensions.Restart(this.stretchTween);
            },
            /*CollectorAnimation.PlayStretch end.*/

            /*CollectorAnimation.StopStretch start.*/
            StopStretch: function () {
if ( TRACE ) { TRACE( "CollectorAnimation#StopStretch", this ); }

                DG.Tweening.TweenExtensions.Pause(DG.Tweening.Sequence, this.stretchTween);
                this.CollectorBody.localScale = this.defaultCollectorScale.$clone();
            },
            /*CollectorAnimation.StopStretch end.*/

            /*CollectorAnimation.StopAnimation start.*/
            StopAnimation: function () {
if ( TRACE ) { TRACE( "CollectorAnimation#StopAnimation", this ); }

                if (this.earAnimCoroutine != null) {
                    this.StopCoroutine$2(this.earAnimCoroutine);
                    this.earAnimCoroutine = null;
                }
                if (this.breathAnimCoroutine != null) {
                    this.StopCoroutine$2(this.breathAnimCoroutine);
                    this.breathAnimCoroutine = null;
                }
                this.StopBreathing();
                this.StopJump();
            },
            /*CollectorAnimation.StopAnimation end.*/


        }
    });
    /*CollectorAnimation end.*/

    /*CollectorAnimState start.*/
    Bridge.define("CollectorAnimState", {
        $kind: 6,
        statics: {
            fields: {
                Idle: 0,
                MoveToQueue: 1,
                MoveToConveyorBelt: 2,
                PushForward: 3,
                CompleteColorPixels: 4,
                PushForwardOnConveyorBelt: 5,
                UnlockLockObject: 6,
                MoveToDeadPosition: 7,
                MoveToQueueRotateBack: 8
            }
        }
    });
    /*CollectorAnimState end.*/

    /*CollectorColumn start.*/
    Bridge.define("CollectorColumn", {
        fields: {
            CollectorsInColumn: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "CollectorColumn#ctor", this ); }

                this.$initialize();
                this.CollectorsInColumn = new (System.Collections.Generic.List$1(CollectorMachanicObjectBase)).ctor();
            }
        }
    });
    /*CollectorColumn end.*/

    /*CollectorColumnController start.*/
    Bridge.define("CollectorColumnController", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                _colorCodeCache: null,
                _cachedWaitForSeconds: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "CollectorColumnController#init", this ); }

                    this._colorCodeCache = new (System.Collections.Generic.Dictionary$2(System.String,System.String)).ctor();
                }
            }
        },
        fields: {
            collectorsSystem: null,
            _cachedFormationCenter: null,
            _cachedSpaceBetweenColumns: 0,
            _cachedSpaceBetweenCollectors: 0,
            _cachedCollectorRotation: null,
            _tempCollectorsToRemove: null,
            _tempCollectorsToDestroy: null,
            _tempActiveCollectors: null,
            _tempDeadCollectors: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "CollectorColumnController#init", this ); }

                this._cachedCollectorRotation = new UnityEngine.Vector3();
                this._tempCollectorsToRemove = new (System.Collections.Generic.List$1(CollectorController)).ctor();
                this._tempCollectorsToDestroy = new (System.Collections.Generic.List$1(CollectorController)).ctor();
                this._tempActiveCollectors = new (System.Collections.Generic.List$1(CollectorController)).ctor();
                this._tempDeadCollectors = new (System.Collections.Generic.List$1(CollectorController)).ctor();
            }
        },
        methods: {
            /*CollectorColumnController.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "CollectorColumnController#Awake", this ); }

                this.CacheSystemReferences();
                this.RegisterEvents();
            },
            /*CollectorColumnController.Awake end.*/

            /*CollectorColumnController.CacheSystemReferences start.*/
            CacheSystemReferences: function () {
if ( TRACE ) { TRACE( "CollectorColumnController#CacheSystemReferences", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.collectorsSystem, null)) {
                    this._cachedFormationCenter = this.collectorsSystem.FormationCenter;
                    this._cachedSpaceBetweenColumns = this.collectorsSystem.SpaceBetweenColumns;
                    this._cachedSpaceBetweenCollectors = this.collectorsSystem.SpaceBetweenCollectors;
                    this._cachedCollectorRotation = this.collectorsSystem.CollectorRotation.$clone();
                }
            },
            /*CollectorColumnController.CacheSystemReferences end.*/

            /*CollectorColumnController.RegisterEvents start.*/
            RegisterEvents: function () {
if ( TRACE ) { TRACE( "CollectorColumnController#RegisterEvents", this ); }

                GameplayEventsManager.OnUnlockLockObject = Bridge.fn.combine(GameplayEventsManager.OnUnlockLockObject, Bridge.fn.cacheBind(this, this.OnCollectorStartMove));
                GameplayEventsManager.OnCollectorStartMove = Bridge.fn.combine(GameplayEventsManager.OnCollectorStartMove, Bridge.fn.cacheBind(this, this.OnCollectorStartMove));
                GameplayEventsManager.OnAKeyReadyToBeCollected = Bridge.fn.combine(GameplayEventsManager.OnAKeyReadyToBeCollected, Bridge.fn.cacheBind(this, this.OnAKeyReadyToBeCollected));
            },
            /*CollectorColumnController.RegisterEvents end.*/

            /*CollectorColumnController.OnCollectorStartMove start.*/
            OnCollectorStartMove: function (collector) {
if ( TRACE ) { TRACE( "CollectorColumnController#OnCollectorStartMove", this ); }

                if (collector.ColumnIndex >= 0) {
                    this.collectorsSystem.CollectorControllersColumns.getItem(collector.ColumnIndex).remove(collector);
                    this.UpdatePosition(this.collectorsSystem.CollectorControllersColumns.getItem(collector.ColumnIndex));
                    collector.ColumnIndex = -1;
                    collector.IndexInColumn = -1;
                    this.UpdateHiddenCollectorsState();
                }
                !Bridge.staticEquals(GameplayEventsManager.OnCollectorsSquadChanged, null) ? GameplayEventsManager.OnCollectorsSquadChanged(this) : null;
            },
            /*CollectorColumnController.OnCollectorStartMove end.*/

            /*CollectorColumnController.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "CollectorColumnController#OnDestroy", this ); }

                GameplayEventsManager.OnUnlockLockObject = Bridge.fn.remove(GameplayEventsManager.OnUnlockLockObject, Bridge.fn.cacheBind(this, this.OnCollectorStartMove));
                GameplayEventsManager.OnCollectorStartMove = Bridge.fn.remove(GameplayEventsManager.OnCollectorStartMove, Bridge.fn.cacheBind(this, this.OnCollectorStartMove));
                GameplayEventsManager.OnAKeyReadyToBeCollected = Bridge.fn.remove(GameplayEventsManager.OnAKeyReadyToBeCollected, Bridge.fn.cacheBind(this, this.OnAKeyReadyToBeCollected));
            },
            /*CollectorColumnController.OnDestroy end.*/

            /*CollectorColumnController.UpdatePosition start.*/
            UpdatePosition: function (collectorsInColumn) {
if ( TRACE ) { TRACE( "CollectorColumnController#UpdatePosition", this ); }

                if (collectorsInColumn == null || collectorsInColumn.Count === 0) {
                    return;
                }

                // Use cached values for better performance
                var columnIndex = collectorsInColumn.getItem(0).ColumnIndex;
                var columnCount = this.collectorsSystem.ObjectsInColumns.Count;
                var formationCenter = UnityEngine.Component.op_Inequality(this._cachedFormationCenter, null) ? this._cachedFormationCenter : this.collectorsSystem.FormationCenter;
                var spaceBetweenColumns = this._cachedSpaceBetweenColumns;
                var spaceBetweenCollectors = this._cachedSpaceBetweenCollectors;
                var collectorRotation = this._cachedCollectorRotation.$clone();

                // Pre-calculate common values to avoid repeated calculations
                var startPosition = formationCenter.position.$clone();
                var columnOffset = formationCenter.right.clone().scale( (columnIndex - (((columnCount - 1) | 0)) / 2.0) * spaceBetweenColumns );
                var basePosition = startPosition.$clone().add( columnOffset );
                var forwardOffset = formationCenter.forward.$clone().clone().scale( spaceBetweenCollectors );

                for (var i = 0; i < collectorsInColumn.Count; i = (i + 1) | 0) {
                    // Calculate position using pre-calculated values
                    var spawnPosition = basePosition.$clone().sub( (forwardOffset.clone().scale( i )) );
                    var collector = collectorsInColumn.getItem(i);
                    collector.MoveToPos(spawnPosition, CollectorAnimState.PushForward, null);
                    collector.transform.localEulerAngles = collectorRotation.$clone();
                    collector.IndexInColumn = i;
                    if (i === 0) {
                        collector.SetFadeBulletText(false);
                    }
                    //collector.UpdateVisiblityBasedOnRow();
                }
            },
            /*CollectorColumnController.UpdatePosition end.*/

            /*CollectorColumnController.GetLockReadyToUnlock start.*/
            GetLockReadyToUnlock: function () {
if ( TRACE ) { TRACE( "CollectorColumnController#GetLockReadyToUnlock", this ); }

                var columns = this.collectorsSystem.CollectorControllersColumns;
                for (var i = 0; i < columns.Count; i = (i + 1) | 0) {
                    var col = columns.getItem(i);
                    if (col.Count > 0) {
                        var firstCollector = col.getItem(0);
                        if (firstCollector.IsLockObject && !firstCollector.LockController.IsUnlocked) {
                            return firstCollector;
                        }
                    }
                }
                return null;
            },
            /*CollectorColumnController.GetLockReadyToUnlock end.*/

            /*CollectorColumnController.OnAKeyReadyToBeCollected start.*/
            OnAKeyReadyToBeCollected: function () {
if ( TRACE ) { TRACE( "CollectorColumnController#OnAKeyReadyToBeCollected", this ); }

                //invoke this to make grid finding key (temporary)
                !Bridge.staticEquals(GameplayEventsManager.OnCollectorsSquadChanged, null) ? GameplayEventsManager.OnCollectorsSquadChanged(this) : null;
            },
            /*CollectorColumnController.OnAKeyReadyToBeCollected end.*/

            /*CollectorColumnController.UpdateHiddenCollectorsState start.*/
            UpdateHiddenCollectorsState: function () {
if ( TRACE ) { TRACE( "CollectorColumnController#UpdateHiddenCollectorsState", this ); }

                var columns = this.collectorsSystem.CollectorControllersColumns;
                for (var i = 0; i < columns.Count; i = (i + 1) | 0) {
                    var col = columns.getItem(i);
                    if (col != null && col.Count > 0) {
                        var firstCollector = col.getItem(0);
                        if (!firstCollector.IsLockObject && firstCollector.ColorCollector.IsHidden) {
                            firstCollector.ColorCollector.Reveal();
                        }
                    }
                }
            },
            /*CollectorColumnController.UpdateHiddenCollectorsState end.*/

            /*CollectorColumnController.RemoveAllCollectorWithColor start.*/
            RemoveAllCollectorWithColor: function (colorCode) {
if ( TRACE ) { TRACE( "CollectorColumnController#RemoveAllCollectorWithColor", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5;
                // Use cached color code to avoid string allocation
                if (!CollectorColumnController._colorCodeCache.containsKey(colorCode)) {
                    CollectorColumnController._colorCodeCache.setItem(colorCode, colorCode);
                }
                var cachedColorCode = CollectorColumnController._colorCodeCache.getItem(colorCode);

                // Use cached lists to reduce GC allocations
                this._tempCollectorsToRemove.clear();
                this._tempCollectorsToDestroy.clear();

                // Process collectors in columns
                $t = Bridge.getEnumerator(this.collectorsSystem.CollectorControllersColumns);
                try {
                    while ($t.moveNext()) {
                        var col = $t.Current;
                        if (col.Count <= 0) {
                            continue;
                        }
                        $t1 = Bridge.getEnumerator(col);
                        try {
                            while ($t1.moveNext()) {
                                var _collector = $t1.Current;
                                if (_collector.IsLockObject) {
                                    continue;
                                }

                                var sameColor = Bridge.referenceEquals(_collector.ColorCollector.CollectorColor, cachedColorCode);

                                if (!sameColor) {
                                    continue;
                                }

                                var hasConnect = _collector.collectorConnect != null && _collector.collectorConnect.Count > 1;

                                if (hasConnect) {
                                    var connectStillProgress = false;
                                    $t2 = Bridge.getEnumerator(_collector.collectorConnect);
                                    try {
                                        while ($t2.moveNext()) {
                                            var _connector = $t2.Current;
                                            if (_connector.ColorCollector.ID === _collector.ColorCollector.ID) {
                                                continue;
                                            }
                                            if (_connector.ColorCollector.BulletLeft > 0 && !Bridge.referenceEquals(_connector.ColorCollector.CollectorColor, cachedColorCode)) {
                                                connectStillProgress = true;
                                                break;
                                            }
                                        }
                                    } finally {
                                        if (Bridge.is($t2, System.IDisposable)) {
                                            $t2.System$IDisposable$Dispose();
                                        }
                                    }

                                    if (!connectStillProgress) {
                                        this._tempCollectorsToRemove.AddRange(_collector.collectorConnect);
                                    } else {
                                        _collector.ColorCollector.SetBullet(0);
                                    }
                                } else {
                                    this._tempCollectorsToRemove.add(_collector);
                                }
                            }
                        } finally {
                            if (Bridge.is($t1, System.IDisposable)) {
                                $t1.System$IDisposable$Dispose();
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                // Process active moving controllers
                this._tempActiveCollectors.clear();
                this._tempActiveCollectors.AddRange(CollectorGameManager.Instance.ActiveMovingControllers);
                $t3 = Bridge.getEnumerator(this._tempActiveCollectors);
                try {
                    while ($t3.moveNext()) {
                        var collector = $t3.Current;
                        if (collector.IsLockObject) {
                            continue;
                        }
                        var sameColor1 = Bridge.referenceEquals(collector.ColorCollector.CollectorColor, cachedColorCode);
                        if (sameColor1) {
                            this._tempCollectorsToDestroy.add(collector);
                        }
                    }
                } finally {
                    if (Bridge.is($t3, System.IDisposable)) {
                        $t3.System$IDisposable$Dispose();
                    }
                }

                // Process dead collectors
                this._tempDeadCollectors.clear();
                this._tempDeadCollectors.AddRange(CollectorGameManager.Instance.collectorOnDead);
                $t4 = Bridge.getEnumerator(this._tempDeadCollectors);
                try {
                    while ($t4.moveNext()) {
                        var collector1 = $t4.Current;
                        if (collector1.IsLockObject) {
                            continue;
                        }
                        var sameColor2 = Bridge.referenceEquals(collector1.ColorCollector.CollectorColor, cachedColorCode);
                        if (sameColor2) {
                            this._tempCollectorsToDestroy.add(collector1);
                        }
                    }
                } finally {
                    if (Bridge.is($t4, System.IDisposable)) {
                        $t4.System$IDisposable$Dispose();
                    }
                }

                // Destroy collectors to be destroyed
                $t5 = Bridge.getEnumerator(this._tempCollectorsToDestroy);
                try {
                    while ($t5.moveNext()) {
                        var collector2 = $t5.Current;
                        CollectorGameManager.Instance.collectorOnDead.remove(collector2);
                        CollectorGameManager.Instance.ActiveMovingControllers.remove(collector2);
                        collector2.ColorCollector.SetBullet(0);
                        collector2.ColorCollector.SelfDestroy();
                    }
                } finally {
                    if (Bridge.is($t5, System.IDisposable)) {
                        $t5.System$IDisposable$Dispose();
                    }
                }

                this.StartCoroutine$1(this.RemoveAndRePositionCollectors(this._tempCollectorsToRemove));
            },
            /*CollectorColumnController.RemoveAllCollectorWithColor end.*/

            /*CollectorColumnController.RemoveAndRePositionCollectors start.*/
            RemoveAndRePositionCollectors: function (collectorsToRemove) {
if ( TRACE ) { TRACE( "CollectorColumnController#RemoveAndRePositionCollectors", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    i,
                    collector,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    // Use cached WaitForSeconds to avoid creating new objects
                                        if (CollectorColumnController._cachedWaitForSeconds == null) {
                                            CollectorColumnController._cachedWaitForSeconds = new UnityEngine.WaitForSeconds(0.0833333358);
                                        }

                                        i = 0;
                                        $step = 1;
                                        continue;
                                }
                                case 1: {
                                    if ( i < collectorsToRemove.Count ) {
                                            $step = 2;
                                            continue;
                                        }
                                    $step = 5;
                                    continue;
                                }
                                case 2: {
                                    collector = collectorsToRemove.getItem(i);
                                        collector.ColorCollector.SetBullet(0);
                                        GameplayEventsManager.OnCollectorStartMove(collector);
                                        collector.gameObject.SetActive(false);
                                        $enumerator.current = CollectorColumnController._cachedWaitForSeconds;
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    $step = 4;
                                    continue;
                                }
                                case 4: {
                                    i = (i + 1) | 0;
                                    $step = 1;
                                    continue;
                                }
                                case 5: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*CollectorColumnController.RemoveAndRePositionCollectors end.*/

            /*CollectorColumnController.HighlightRows start.*/
            HighlightRows: function (row, min, max, duration) {
if ( TRACE ) { TRACE( "CollectorColumnController#HighlightRows", this ); }

                if (row === void 0) { row = 5; }
                if (min === void 0) { min = 0.0; }
                if (max === void 0) { max = 1.5; }
                if (duration === void 0) { duration = 0.5; }
                var columns = this.collectorsSystem.CollectorControllersColumns;
                for (var colIdx = 0; colIdx < columns.Count; colIdx = (colIdx + 1) | 0) {
                    var col = columns.getItem(colIdx);
                    var count = UnityEngine.Mathf.Min(col.Count, row);
                    for (var i = 0; i < count; i = (i + 1) | 0) {
                        var colorCollector = col.getItem(i).ColorCollector;
                        if (UnityEngine.MonoBehaviour.op_Inequality(colorCollector, null) && UnityEngine.MonoBehaviour.op_Inequality(colorCollector.VisualHandler, null)) {
                            colorCollector.VisualHandler.StartHighlight(min, max, duration);
                        }
                    }
                }
            },
            /*CollectorColumnController.HighlightRows end.*/

            /*CollectorColumnController.DeHighlightRows start.*/
            DeHighlightRows: function (row) {
if ( TRACE ) { TRACE( "CollectorColumnController#DeHighlightRows", this ); }

                if (row === void 0) { row = 5; }
                var columns = this.collectorsSystem.CollectorControllersColumns;
                for (var colIdx = 0; colIdx < columns.Count; colIdx = (colIdx + 1) | 0) {
                    var col = columns.getItem(colIdx);
                    var count = UnityEngine.Mathf.Min(col.Count, row);
                    for (var i = 0; i < count; i = (i + 1) | 0) {
                        var colorCollector = col.getItem(i).ColorCollector;
                        if (UnityEngine.MonoBehaviour.op_Inequality(colorCollector, null) && UnityEngine.MonoBehaviour.op_Inequality(colorCollector.VisualHandler, null)) {
                            colorCollector.VisualHandler.StopHighlight();
                        }
                    }
                }
            },
            /*CollectorColumnController.DeHighlightRows end.*/


        }
    });
    /*CollectorColumnController end.*/

    /*CollectorController start.*/
    Bridge.define("CollectorController", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                Vector3One: null,
                Vector3Zero: null,
                Vector3Up: null,
                Vector3Forward: null,
                Vector3Right: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "CollectorController#init", this ); }

                    this.Vector3One = new UnityEngine.Vector3();
                    this.Vector3Zero = new UnityEngine.Vector3();
                    this.Vector3Up = new UnityEngine.Vector3();
                    this.Vector3Forward = new UnityEngine.Vector3();
                    this.Vector3Right = new UnityEngine.Vector3();
                    this.Vector3One = new pc.Vec3( 1, 1, 1 );
                    this.Vector3Zero = pc.Vec3.ZERO.clone();
                    this.Vector3Up = pc.Vec3.UP.clone();
                    this.Vector3Forward = new pc.Vec3( 0, 0, 1 );
                    this.Vector3Right = pc.Vec3.RIGHT.clone();
                }
            }
        },
        fields: {
            movementHandle: null,
            ColorCollector: null,
            collectorConnect: null,
            State: 0,
            IndexInColumn: 0,
            ColumnIndex: 0,
            SlotOnQueue: 0,
            LockController: null,
            IsLockObject: false,
            anim: null,
            bulletDisplayHandler: null,
            IsCompleteColor: false,
            waitForEndOfFrame: null,
            hasCompleted: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "CollectorController#init", this ); }

                this.State = CollectorState.InColumn;
                this.IndexInColumn = 0;
                this.ColumnIndex = 0;
                this.SlotOnQueue = 1;
                this.IsLockObject = false;
                this.IsCompleteColor = false;
                this.waitForEndOfFrame = new UnityEngine.WaitForEndOfFrame();
                this.hasCompleted = false;
            }
        },
        methods: {
            /*CollectorController.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "CollectorController#Awake", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.ColorCollector, null)) {
                    this.ColorCollector.OnCompleteAllColorPixels = Bridge.fn.combine(this.ColorCollector.OnCompleteAllColorPixels, Bridge.fn.cacheBind(this, this.HandleCompleteColorPixels));
                }

                GameplayEventsManager.OnAbsoluteWin = Bridge.fn.combine(GameplayEventsManager.OnAbsoluteWin, Bridge.fn.cacheBind(this, this.OnAbsoluteWin));
            },
            /*CollectorController.Awake end.*/

            /*CollectorController.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "CollectorController#OnDestroy", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.ColorCollector, null)) {
                    this.ColorCollector.OnCompleteAllColorPixels = Bridge.fn.remove(this.ColorCollector.OnCompleteAllColorPixels, Bridge.fn.cacheBind(this, this.HandleCompleteColorPixels));
                }
                GameplayEventsManager.OnAbsoluteWin = Bridge.fn.remove(GameplayEventsManager.OnAbsoluteWin, Bridge.fn.cacheBind(this, this.OnAbsoluteWin));
            },
            /*CollectorController.OnDestroy end.*/

            /*CollectorController.PauseMovement start.*/
            PauseMovement: function () {
if ( TRACE ) { TRACE( "CollectorController#PauseMovement", this ); }

                this.movementHandle.PauseMovement();
            },
            /*CollectorController.PauseMovement end.*/

            /*CollectorController.ResumeMovement start.*/
            ResumeMovement: function () {
if ( TRACE ) { TRACE( "CollectorController#ResumeMovement", this ); }

                this.ColorCollector.SetStatusAttributes();
            },
            /*CollectorController.ResumeMovement end.*/

            /*CollectorController.StartMovement start.*/
            StartMovement: function (targetTF) {
if ( TRACE ) { TRACE( "CollectorController#StartMovement", this ); }

                // Nu collector  di chuyn th khng gi li na  trnh lp v hn
                if (this.State === CollectorState.Moving) {
                    return;
                }

                // if (State == CollectorState.InDeadQueue)
                // {
                //     transform.DOScale(Vector3One, 0.1f);
                // }
                this.movementHandle.HandleSelectCollector(targetTF, Bridge.fn.cacheBind(this, this.OnCollectorMoveFinished));
                this.ColorCollector.SetActiveCollector(true);
                this.ColorCollector.SetStatusAttributes();
                this.State = CollectorState.Moving;
                UnityEngine.MonoBehaviour.op_Inequality(this.bulletDisplayHandler, null) ? this.bulletDisplayHandler.SetUpdateText(true) : null;
                this.ColorCollector.OnStartMove();
                this.ColorCollector.RabbitRotateTransform.eulerAngles = CollectorController.Vector3Zero.$clone();
            },
            /*CollectorController.StartMovement end.*/

            /*CollectorController.StopMovementAtCurrentPosition start.*/
            StopMovementAtCurrentPosition: function () {
if ( TRACE ) { TRACE( "CollectorController#StopMovementAtCurrentPosition", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    this.movementHandle.StopMovementAtCurrentPosition();
                                        this.State = CollectorState.InDeadQueue;
                                        $enumerator.current = this.waitForEndOfFrame;
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    this.ColorCollector.RabbitRotateTransform.eulerAngles = CollectorController.Vector3Zero.$clone();

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*CollectorController.StopMovementAtCurrentPosition end.*/

            /*CollectorController.OnCollectorMoveFinished start.*/
            OnCollectorMoveFinished: function () {
if ( TRACE ) { TRACE( "CollectorController#OnCollectorMoveFinished", this ); }

                !Bridge.staticEquals(GameplayEventsManager.OnACollectorFinishMove, null) ? GameplayEventsManager.OnACollectorFinishMove(this) : null;
                !Bridge.staticEquals(GameplayEventsManager.OnACollectorMoveToQueue, null) ? GameplayEventsManager.OnACollectorMoveToQueue(this) : null;
                this.State = CollectorState.InQueue;
                this.ColumnIndex = -1;

                //bulletDisplayHandler?.SetUpdateText(false);
                // Action action = () => { bulletDisplayHandler?.SetUpdateText(false); };
                // anim.PlayAnim(transform.position, CollectorAnimState.MoveToQueue, action);
                DG.Tweening.ShortcutExtensions.DORotate(this.ColorCollector.RabbitRotateTransform, new pc.Vec3( 0, 180, 0 ), 0.3);
                this.ColorCollector.SetActiveCollector(false);
                this.ColorCollector.SetStatusAttributes();
            },
            /*CollectorController.OnCollectorMoveFinished end.*/

            /*CollectorController.DeUpdateText start.*/
            DeUpdateText: function () {
if ( TRACE ) { TRACE( "CollectorController#DeUpdateText", this ); }

                UnityEngine.MonoBehaviour.op_Inequality(this.bulletDisplayHandler, null) ? this.bulletDisplayHandler.SetUpdateText(false) : null;
            },
            /*CollectorController.DeUpdateText end.*/

            /*CollectorController.CanMove start.*/
            CanMove: function () {
if ( TRACE ) { TRACE( "CollectorController#CanMove", this ); }

                // Cho php di chuyn nu ang  queue hoc l index 0 ca ct
                return this.State === CollectorState.InDeadQueue || this.State === CollectorState.InQueue || (this.State === CollectorState.InColumn && this.IndexInColumn === 0);
            },
            /*CollectorController.CanMove end.*/

            /*CollectorController.GetStartPosition start.*/
            GetStartPosition: function () {
if ( TRACE ) { TRACE( "CollectorController#GetStartPosition", this ); }

                return this.movementHandle.GetPositionAtTF(0.0);
            },
            /*CollectorController.GetStartPosition end.*/

            /*CollectorController.GetPositionByTF start.*/
            GetPositionByTF: function (tf) {
if ( TRACE ) { TRACE( "CollectorController#GetPositionByTF", this ); }

                return this.movementHandle.GetPositionAtTF(tf);
            },
            /*CollectorController.GetPositionByTF end.*/

            /*CollectorController.GetCurrentTF start.*/
            GetCurrentTF: function () {
if ( TRACE ) { TRACE( "CollectorController#GetCurrentTF", this ); }

                return this.movementHandle.currentTF;
            },
            /*CollectorController.GetCurrentTF end.*/

            /*CollectorController.MoveToPos start.*/
            MoveToPos: function (newPos, animState, actionOnComplete) {
if ( TRACE ) { TRACE( "CollectorController#MoveToPos", this ); }

                if (actionOnComplete === void 0) { actionOnComplete = null; }
                this.anim.PlayAnim(newPos, animState, actionOnComplete);
            },
            /*CollectorController.MoveToPos end.*/

            /*CollectorController.HandleCompleteColorPixelsDirect start.*/
            HandleCompleteColorPixelsDirect: function () {
if ( TRACE ) { TRACE( "CollectorController#HandleCompleteColorPixelsDirect", this ); }

                // Only trigger completion when all connected collectors have BulletLeft <= 0
                if (this.collectorConnect == null || this.collectorConnect.Count === 0) {
                    return;
                }

                // Check that every connected collector (skip nulls and collectors with null colorPixels)
                for (var i = 0; i < this.collectorConnect.Count; i = (i + 1) | 0) {
                    var connectCollector = this.collectorConnect.getItem(i);
                    if (UnityEngine.MonoBehaviour.op_Equality(connectCollector, null)) {
                        continue;
                    }
                    if (UnityEngine.MonoBehaviour.op_Equality(connectCollector.ColorCollector, null)) {
                        continue;
                    }
                    if (connectCollector.ColorCollector.BulletLeft > 0) {
                        // At least one still has bullets left -> do nothing
                        return;
                    }
                }

                // All have BulletLeft <= 0 -> invoke completion on each (skip nulls)
                for (var i1 = 0; i1 < this.collectorConnect.Count; i1 = (i1 + 1) | 0) {
                    var connectCollector1 = this.collectorConnect.getItem(i1);
                    if (UnityEngine.MonoBehaviour.op_Equality(connectCollector1, null)) {
                        continue;
                    }
                    connectCollector1.OnCompletePixel();
                }
            },
            /*CollectorController.HandleCompleteColorPixelsDirect end.*/

            /*CollectorController.HandleCompleteColorPixels start.*/
            HandleCompleteColorPixels: function () {
if ( TRACE ) { TRACE( "CollectorController#HandleCompleteColorPixels", this ); }

                this.HandleCompleteColorPixelsDirect();
            },
            /*CollectorController.HandleCompleteColorPixels end.*/

            /*CollectorController.OnCompletePixel start.*/
            OnCompletePixel: function () {
if ( TRACE ) { TRACE( "CollectorController#OnCompletePixel", this ); }

                if (this.hasCompleted) {
                    return;
                }
                this.hasCompleted = true;

                if (this.State === CollectorState.Moving) {
                    !Bridge.staticEquals(GameplayEventsManager.CompleteColor, null) ? GameplayEventsManager.CompleteColor(this) : null;
                }
                // else
                // {
                //     GameplayEventsManager.OnCompleteDead?.Invoke(this);
                // }
                this.State = CollectorState.Completed;
                this.ColumnIndex = -1;
                this.anim.PlayAnim(CollectorController.Vector3One, CollectorAnimState.CompleteColorPixels, null);
                this.ColorCollector.IsHided = true;
            },
            /*CollectorController.OnCompletePixel end.*/

            /*CollectorController.UnlockCollector start.*/
            UnlockCollector: function () {
if ( TRACE ) { TRACE( "CollectorController#UnlockCollector", this ); }

                this.State = CollectorState.Completed;
                this.anim.PlayAnim(CollectorController.Vector3One, CollectorAnimState.UnlockLockObject, null);
            },
            /*CollectorController.UnlockCollector end.*/

            /*CollectorController.SetFadeBulletText start.*/
            SetFadeBulletText: function (isFaded) {
if ( TRACE ) { TRACE( "CollectorController#SetFadeBulletText", this ); }

                UnityEngine.MonoBehaviour.op_Inequality(this.bulletDisplayHandler, null) ? this.bulletDisplayHandler.SetFadeText(isFaded) : null;
            },
            /*CollectorController.SetFadeBulletText end.*/

            /*CollectorController.UpdateVisiblityBasedOnRow start.*/
            UpdateVisiblityBasedOnRow: function () {
if ( TRACE ) { TRACE( "CollectorController#UpdateVisiblityBasedOnRow", this ); }

                UnityEngine.MonoBehaviour.op_Inequality(this.ColorCollector, null) && UnityEngine.MonoBehaviour.op_Inequality(this.ColorCollector.VisualHandler, null) ? this.ColorCollector.VisualHandler.SetVisisble(this.IndexInColumn <= 4) : null;
            },
            /*CollectorController.UpdateVisiblityBasedOnRow end.*/

            /*CollectorController.OnAbsoluteWin start.*/
            OnAbsoluteWin: function () {
if ( TRACE ) { TRACE( "CollectorController#OnAbsoluteWin", this ); }

                //if (collectorConnect.Count > 1)
                //{
                //    bool hasNonMovingCollector = false;
                //    for (int i = 0; i < collectorConnect.Count; i++)
                //    {
                //        if (collectorConnect[i] != null && collectorConnect[i].State != CollectorState.Moving)
                //        {
                //            hasNonMovingCollector = true;
                //            break;
                //        }
                //    }
                //    if (hasNonMovingCollector)
                //    {
                //        return;
                //    }
                //}
                UnityEngine.MonoBehaviour.op_Inequality(this.ColorCollector, null) ? this.ColorCollector.OnAbsoluteWin(this.State === CollectorState.Moving) : null;
            },
            /*CollectorController.OnAbsoluteWin end.*/

            /*CollectorController.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "CollectorController#OnDisable", this ); }

                !Bridge.staticEquals(GameplayEventsManager.ForceRemoveCollectorActive, null) ? GameplayEventsManager.ForceRemoveCollectorActive(this) : null;
            },
            /*CollectorController.OnDisable end.*/


        }
    });
    /*CollectorController end.*/

    /*CollectorGameManager start.*/
    Bridge.define("CollectorGameManager", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                Instance: null,
                tempControllers: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "CollectorGameManager#init", this ); }

                    this.tempControllers = new (System.Collections.Generic.List$1(CollectorController)).ctor();
                }
            }
        },
        fields: {
            queueManager: null,
            moveLimiter: null,
            inputManager: null,
            gamePlaySound: null,
            gameplayManager: null,
            distanceTf: 0,
            pendingStartInterval: 0,
            activeMovingControllers: null,
            pendingStartQueue: null,
            isProcessingPending: false,
            collectorOnDead: null,
            hasShowPrelose: false,
            countClickToMoveStore: 0,
            canMoveStoreEqualCount: false
        },
        props: {
            ActiveMovingControllers: {
                get: function () {
if ( TRACE ) { TRACE( "CollectorGameManager#ActiveMovingControllers#get", this ); }

                    return this.activeMovingControllers;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "CollectorGameManager#init", this ); }

                this.distanceTf = 0.06;
                this.pendingStartInterval = 0.2;
                this.activeMovingControllers = new (System.Collections.Generic.HashSet$1(CollectorController)).ctor();
                this.pendingStartQueue = new (System.Collections.Generic.Queue$1(CollectorController)).ctor();
                this.isProcessingPending = false;
                this.hasShowPrelose = false;
                this.countClickToMoveStore = 5;
                this.canMoveStoreEqualCount = true;
            }
        },
        methods: {
            /*CollectorGameManager.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "CollectorGameManager#Awake", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(CollectorGameManager.Instance, null)) {
                    CollectorGameManager.Instance = this;
                } else {
                    UnityEngine.MonoBehaviour.Destroy(this.gameObject);
                }

                GameplayEventsManager.OnACollectorFinishMove = Bridge.fn.combine(GameplayEventsManager.OnACollectorFinishMove, Bridge.fn.cacheBind(this, this.OnCollectorFinished));
                GameplayEventsManager.CompleteColor = Bridge.fn.combine(GameplayEventsManager.CompleteColor, Bridge.fn.cacheBind(this, this.OnCompleteColor));
                GameplayEventsManager.ForceRemoveCollectorActive = Bridge.fn.combine(GameplayEventsManager.ForceRemoveCollectorActive, Bridge.fn.cacheBind(this, this.ForceRemoveCollector));
                GameplayEventsManager.PauseGame = Bridge.fn.combine(GameplayEventsManager.PauseGame, Bridge.fn.cacheBind(this, this.PauseGame));
            },
            /*CollectorGameManager.Awake end.*/

            /*CollectorGameManager.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "CollectorGameManager#OnDestroy", this ); }

                GameplayEventsManager.OnACollectorFinishMove = Bridge.fn.remove(GameplayEventsManager.OnACollectorFinishMove, Bridge.fn.cacheBind(this, this.OnCollectorFinished));
                GameplayEventsManager.ForceRemoveCollectorActive = Bridge.fn.remove(GameplayEventsManager.ForceRemoveCollectorActive, Bridge.fn.cacheBind(this, this.ForceRemoveCollector));
                GameplayEventsManager.CompleteColor = Bridge.fn.remove(GameplayEventsManager.CompleteColor, Bridge.fn.cacheBind(this, this.OnCompleteColor));
                GameplayEventsManager.PauseGame = Bridge.fn.remove(GameplayEventsManager.PauseGame, Bridge.fn.cacheBind(this, this.PauseGame));
            },
            /*CollectorGameManager.OnDestroy end.*/

            /*CollectorGameManager.RequestMoveCollector start.*/
            RequestMoveCollector: function (controller) {
if ( TRACE ) { TRACE( "CollectorGameManager#RequestMoveCollector", this ); }

                var $t, $t1;
                // 1. Check ng i
                if (!this.CanMoveCollectorPath(controller)) {
                    !Bridge.staticEquals(GameplayEventsManager.OnClickACollector, null) ? GameplayEventsManager.OnClickACollector(controller, false) : null;
                    if (this.moveLimiter.IsFullSlots()) {
                        this.moveLimiter.TextAnimShakeOnFull();
                    }
                    return;
                }

                // 2. Tm Partner
                var partner = null;
                if (controller.collectorConnect != null && controller.collectorConnect.Count > 1) {
                    partner = System.Linq.Enumerable.from(controller.collectorConnect, CollectorController).firstOrDefault(Bridge.fn.bind(this, function (c) {
                            return UnityEngine.MonoBehaviour.op_Inequality(c, controller);
                        }), null);
                }

                // 3. Xin php Limiter
                var moveGranted = this.moveLimiter.TryStartMove(controller, partner);

                if (moveGranted) {
                    // --- X L LOGIC TRC KHI DI CHUYN ---

                    var moveGrante = this.moveLimiter.TryStartMove(controller, partner);

                    if (moveGranted) {
                        // --- CLICK TO STORE (LUNA) ---
                        if (this.canMoveStoreEqualCount) {
                            var blockedByFirstLevelLimit = false;

                            // Nu GameplayManager bt limit & ang  level u (m khng phi level cui) -> KHNG m
                            if (UnityEngine.MonoBehaviour.op_Inequality(this.gameplayManager, null) && this.gameplayManager.IsStoreLimitForFirstLevelEnabled && this.gameplayManager.IsFirstLevelAndNotLast()) {
                                blockedByFirstLevelLimit = true;
                            }

                            if (!blockedByFirstLevelLimit) {
                                this.countClickToMoveStore = (this.countClickToMoveStore - 1) | 0;

                                // countClickToMoveStore = s ln click THC S (5 ngha l 5 ln)
                                if (this.countClickToMoveStore <= 0) {
                                    this.canMoveStoreEqualCount = false;

                                    // Gi Luna trc tip, khng qua Tutorial
                                    Luna.Unity.LifeCycle.GameEnded();
                                    Luna.Unity.Playable.InstallFullGame();
                                }
                            }
                        }

                        // --- BC QUAN TRNG: FIX LI NHY ---

                        // To danh sch  x l xa khi hng i
                        var groupToMove = controller.collectorConnect;
                        var listToRemove = new (System.Collections.Generic.List$1(CollectorController)).$ctor1(groupToMove);

                        // SP XP NGC: Xa con ng v tr index cao (ng sau) trc
                        //  trnh vic con ng trc ri i lm con ng sau b trt ln
                        if (UnityEngine.MonoBehaviour.op_Inequality(this.queueManager, null) && this.queueManager.queueArray != null) {
                            listToRemove.Sort$2(Bridge.fn.bind(this, function (a, b) {
                                var indexA = System.Array.indexOfT(this.queueManager.queueArray, a);
                                var indexB = System.Array.indexOfT(this.queueManager.queueArray, b);
                                return Bridge.compare(indexB, indexA); // Gim dn (Index ln xp trc)
                            }));
                        }

                        // Xa khi d liu hng i & NGT CHUYN NG C
                        $t = Bridge.getEnumerator(listToRemove);
                        try {
                            while ($t.moveNext()) {
                                var c = $t.Current;
                                // Kill ngay lp tc mi tween ang chy (v d: ang trt dn hng)
                                // m bo n ng im  chun b Nhy
                                DG.Tweening.ShortcutExtensions.DOKill(c.transform);

                                // Xa khi logic qun l ca Queue ( Queue khng iu khin n na)
                                this.HandleStartMoveCollector(c);
                            }
                        } finally {
                            if (Bridge.is($t, System.IDisposable)) {
                                $t.System$IDisposable$Dispose();
                            }
                        }

                        // --- BT U DI CHUYN ---

                        // Lc ny c 2 con  t do, gi lnh Nhy
                        this.StartCoroutine$1(this.MoveCollectorCoroutine(groupToMove));

                        // Kch hot hiu ng/Event click cho c nhm
                        $t1 = Bridge.getEnumerator(groupToMove);
                        try {
                            while ($t1.moveNext()) {
                                var c1 = { v : $t1.Current };
                                !Bridge.staticEquals(GameplayEventsManager.OnClickACollector, null) ? GameplayEventsManager.OnClickACollector(c1.v, true) : null;
                            }
                        } finally {
                            if (Bridge.is($t1, System.IDisposable)) {
                                $t1.System$IDisposable$Dispose();
                            }
                        }

                        UnityEngine.MonoBehaviour.op_Inequality(this.gamePlaySound, null) ? this.gamePlaySound.PlayClickCat() : null;
                    } else {
                        !Bridge.staticEquals(GameplayEventsManager.OnClickACollector, null) ? GameplayEventsManager.OnClickACollector(controller, false) : null;
                    }
                }
            },
            /*CollectorGameManager.RequestMoveCollector end.*/

            /*CollectorGameManager.ForceMoveCollector start.*/
            ForceMoveCollector: function (controller) {
if ( TRACE ) { TRACE( "CollectorGameManager#ForceMoveCollector", this ); }

                var $t;
                if (controller.ColorCollector.IsHidden) {
                    controller.ColorCollector.Reveal();
                }

                // Tm partner  update visual limiter (d force move th vn nn bo cho limiter bit)
                var partner = System.Linq.Enumerable.from(controller.collectorConnect, CollectorController).firstOrDefault(Bridge.fn.bind(this, function (c) {
                        return UnityEngine.MonoBehaviour.op_Inequality(c, controller);
                    }), null);
                this.moveLimiter.TryStartMove(controller, partner);

                this.StartCoroutine$1(this.MoveCollectorCoroutine(controller.collectorConnect));

                // FIX LI TNG T CHO FORCE MOVE
                $t = Bridge.getEnumerator(controller.collectorConnect);
                try {
                    while ($t.moveNext()) {
                        var connectCollector = { v : $t.Current };
                        this.HandleStartMoveCollector(connectCollector.v);

                        // Gi event cho tt c
                        !Bridge.staticEquals(GameplayEventsManager.OnClickACollector, null) ? GameplayEventsManager.OnClickACollector(connectCollector.v, true) : null;
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*CollectorGameManager.ForceMoveCollector end.*/

            /*CollectorGameManager.MoveCollectorCoroutine start.*/
            MoveCollectorCoroutine: function (controllers) {
if ( TRACE ) { TRACE( "CollectorGameManager#MoveCollectorCoroutine", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $t,
                    controller,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if (controllers == null || controllers.Count === 0) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 2;
                                        continue;
                                }
                                case 1: {
                                    return false;
                                }
                                case 2: {
                                    $t = Bridge.getEnumerator(controllers);
                                        try {
                                            while ($t.moveNext()) {
                                                controller = { v : $t.Current };
                                                this.pendingStartQueue.Enqueue(controller.v);
                                                !Bridge.staticEquals(GameplayEventsManager.OnCollectorMoveToConveyor, null) ? GameplayEventsManager.OnCollectorMoveToConveyor(controller.v) : null;

                                                // Safety: Kill ln na  chc chn khng cn qun tnh c
                                                DG.Tweening.ShortcutExtensions.DOKill(controller.v.transform);

                                                // Gi lnh nhy theo ng cong (Jump)
                                                controller.v.MoveToPos(controller.v.GetPositionByTF(0.0), CollectorAnimState.MoveToConveyorBelt);

                                                !Bridge.staticEquals(GameplayEventsManager.OnCollectorStartMove, null) ? GameplayEventsManager.OnCollectorStartMove(controller.v) : null;

                                                if (!this.activeMovingControllers.contains(controller.v)) {
                                                    this.activeMovingControllers.add(controller.v);
                                                }
                                            }
                                        } finally {
                                            if (Bridge.is($t, System.IDisposable)) {
                                                $t.System$IDisposable$Dispose();
                                            }
                                        }

                                        if (!this.isProcessingPending) {
                                            this.StartCoroutine$1(this.ProcessPendingQueueCoroutine());
                                        }

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*CollectorGameManager.MoveCollectorCoroutine end.*/

            /*CollectorGameManager.ProcessPendingQueueCoroutine start.*/
            ProcessPendingQueueCoroutine: function () {
if ( TRACE ) { TRACE( "CollectorGameManager#ProcessPendingQueueCoroutine", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    controller,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    this.isProcessingPending = true;

                                        //float timer = 0f;
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( this.pendingStartQueue.Count > 0 ) {
                                            $step = 2;
                                            continue;
                                        } 
                                        $step = 4;
                                        continue;
                                }
                                case 2: {
                                    // Wait between each collector start
                                        $enumerator.current = HelperCoroutine.WaitSeconds(this.pendingStartInterval);
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    if (this.pendingStartQueue.Count === 0) {
                                            $step = 4;
                                            continue;
                                        }

                                        controller = this.pendingStartQueue.Dequeue();
                                        if (UnityEngine.MonoBehaviour.op_Equality(controller, null)) {
                                            $step = 1;
                                            continue;
                                        }

                                        controller.StartMovement(0.0);

                                        $step = 1;
                                        continue;
                                }
                                case 4: {
                                    this.isProcessingPending = false;

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*CollectorGameManager.ProcessPendingQueueCoroutine end.*/

            /*CollectorGameManager.ForceRemoveCollector start.*/
            ForceRemoveCollector: function (collector) {
if ( TRACE ) { TRACE( "CollectorGameManager#ForceRemoveCollector", this ); }

                if (this.activeMovingControllers.contains(collector)) {
                    collector.IsCompleteColor = true;
                    this.activeMovingControllers.remove(collector);
                    this.moveLimiter.OnCollectorMoveFinished(collector);
                }
            },
            /*CollectorGameManager.ForceRemoveCollector end.*/

            /*CollectorGameManager.HandleStartMoveCollector start.*/
            HandleStartMoveCollector: function (controller) {
if ( TRACE ) { TRACE( "CollectorGameManager#HandleStartMoveCollector", this ); }

                this.moveLimiter.TryStartMove(controller);

                if (controller.State === CollectorState.InQueue) {
                    this.queueManager.RemoveCollectorFromQueue(controller);
                }

                if (this.collectorOnDead != null && this.collectorOnDead.contains(controller)) {
                    this.collectorOnDead.remove(controller);
                }
            },
            /*CollectorGameManager.HandleStartMoveCollector end.*/

            /*CollectorGameManager.CanMoveCollectorPath start.*/
            CanMoveCollectorPath: function (controller) {
if ( TRACE ) { TRACE( "CollectorGameManager#CanMoveCollectorPath", this ); }

                var $t, $t1, $t2, $t3;
                if (UnityEngine.MonoBehaviour.op_Equality(controller, null)) {
                    return false;
                }

                var group = controller.collectorConnect;
                // Nu khng c nhm hoc  trong hng i th check n gin
                if (group == null || group.Count === 0) {
                    if (controller.State !== CollectorState.InQueue && !controller.CanMove()) {
                        return false;
                    }
                    return UnityEngine.MonoBehaviour.op_Inequality(controller.ColorCollector, null) && controller.ColorCollector.BulletLeft > 0;
                }

                // 1. Check n: Ch cn 1 con trong c nhm cn n l OK
                var groupHasAmmo = false;
                $t = Bridge.getEnumerator(group);
                try {
                    while ($t.moveNext()) {
                        var c = $t.Current;
                        if (UnityEngine.MonoBehaviour.op_Inequality(c, null) && UnityEngine.MonoBehaviour.op_Inequality(c.ColorCollector, null) && c.ColorCollector.BulletLeft > 0) {
                            groupHasAmmo = true;
                            break; // Tm thy 1 vin l  iu kin n
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                if (!groupHasAmmo) {
                    return false;
                } // Ht n c l -> Ngh

                // 2. Check ng i (Vt l): X l li cng ct
                // Logic: Nhm cc con theo Ct. Trong mi ct, ch cn 1 con i c l c ct  i c (do con i c s ko con b chn i theo).

                // Dng HashSet  ly danh sch cc ct duy nht m nhm ny ang chim gi
                var uniqueColumns = new (System.Collections.Generic.HashSet$1(System.Int32)).ctor();
                $t1 = Bridge.getEnumerator(group);
                try {
                    while ($t1.moveNext()) {
                        var c1 = $t1.Current;
                        if (UnityEngine.MonoBehaviour.op_Inequality(c1, null)) {
                            uniqueColumns.add(c1.ColumnIndex);
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                // Duyt qua tng ct c mt trong nhm
                $t2 = Bridge.getEnumerator(uniqueColumns);
                try {
                    while ($t2.moveNext()) {
                        var colIndex = $t2.Current;
                        var canMoveInThisColumn = false;

                        // Kim tra tt c cc con thuc ct ny
                        $t3 = Bridge.getEnumerator(group);
                        try {
                            while ($t3.moveNext()) {
                                var c2 = $t3.Current;
                                if (UnityEngine.MonoBehaviour.op_Equality(c2, null)) {
                                    continue;
                                }

                                // Nu con ny thuc ct ang xt
                                if (c2.ColumnIndex === colIndex) {
                                    // Nu ang  hng i th auto i c
                                    if (c2.State === CollectorState.InQueue) {
                                        canMoveInThisColumn = true;
                                        break;
                                    }

                                    // Nu c t nht 1 con trong ct ny check Raycast thnh cng (khng b chn)
                                    // Th coi nh ct ny thng thong (con dn u s m ng)
                                    if (c2.CanMove()) {
                                        canMoveInThisColumn = true;
                                        break;
                                    }
                                }
                            }
                        } finally {
                            if (Bridge.is($t3, System.IDisposable)) {
                                $t3.System$IDisposable$Dispose();
                            }
                        }

                        // Nu sau khi check ht cc con trong ct ny m KHNG con no i c (tt c u b chn bi vt l)
                        // -> C nhm b kt.
                        if (!canMoveInThisColumn) {
                            return false;
                        }
                    }
                } finally {
                    if (Bridge.is($t2, System.IDisposable)) {
                        $t2.System$IDisposable$Dispose();
                    }
                }

                // Nu tt c cc ct lin quan u c ngi dn u -> i tt
                return true;
            },
            /*CollectorGameManager.CanMoveCollectorPath end.*/

            /*CollectorGameManager.OnCollectorFinished start.*/
            OnCollectorFinished: function (collector) {
if ( TRACE ) { TRACE( "CollectorGameManager#OnCollectorFinished", this ); }

                if (this.queueManager.IsQueueFull()) {
                    if (this.hasShowPrelose) {
                        !Bridge.staticEquals(GameplayEventsManager.OnEndGame, null) ? GameplayEventsManager.OnEndGame(false) : null;
                        return;
                    }

                    this.hasShowPrelose = true;
                    //LayerManager.Instance.ShowPopupRevive();
                    UnityEngine.Debug.Log$1("Game Over: Queue full!");
                    Singleton$1(UiEndGame).Instance.ShowEndGameLose();

                    // LUNA: bo end game + m Store khi thua
                    Luna.Unity.LifeCycle.GameEnded();
                    Luna.Unity.Playable.InstallFullGame();

                    this.inputManager.BlockGameplayInput();
                    return;
                }

                this.moveLimiter.OnCollectorMoveFinished(collector);

                var canEnqueue = UnityEngine.MonoBehaviour.op_Inequality(collector, null) && UnityEngine.MonoBehaviour.op_Inequality(collector.ColorCollector, null) && System.Linq.Enumerable.from(collector.collectorConnect, CollectorController).any(function (x) {
                        return UnityEngine.MonoBehaviour.op_Inequality(x.ColorCollector, null) && x.ColorCollector.BulletLeft > 0;
                    });

                if (canEnqueue) {
                    this.queueManager.EnqueueCollector(collector);
                }

                this.activeMovingControllers.remove(collector);
            },
            /*CollectorGameManager.OnCollectorFinished end.*/

            /*CollectorGameManager.OnCompleteColor start.*/
            OnCompleteColor: function (collector) {
if ( TRACE ) { TRACE( "CollectorGameManager#OnCompleteColor", this ); }

                this.moveLimiter.OnCollectorMoveFinished(collector);
                this.activeMovingControllers.remove(collector);
            },
            /*CollectorGameManager.OnCompleteColor end.*/

            /*CollectorGameManager.PauseGame start.*/
            PauseGame: function (isPause) {
if ( TRACE ) { TRACE( "CollectorGameManager#PauseGame", this ); }

                if (isPause) {
                    this.OnPauseGame();
                } else {
                    this.OnResumeGame();
                }
            },
            /*CollectorGameManager.PauseGame end.*/

            /*CollectorGameManager.OnPauseGame start.*/
            OnPauseGame: function () {
if ( TRACE ) { TRACE( "CollectorGameManager#OnPauseGame", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.activeMovingControllers);
                try {
                    while ($t.moveNext()) {
                        var controller = { v : $t.Current };
                        UnityEngine.MonoBehaviour.op_Inequality(controller.v, null) ? controller.v.PauseMovement() : null;
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*CollectorGameManager.OnPauseGame end.*/

            /*CollectorGameManager.OnResumeGame start.*/
            OnResumeGame: function () {
if ( TRACE ) { TRACE( "CollectorGameManager#OnResumeGame", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.activeMovingControllers);
                try {
                    while ($t.moveNext()) {
                        var controller = { v : $t.Current };
                        UnityEngine.MonoBehaviour.op_Inequality(controller.v, null) ? controller.v.ResumeMovement() : null;
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*CollectorGameManager.OnResumeGame end.*/


        }
    });
    /*CollectorGameManager end.*/

    /*CollectorMachanicObjectBase start.*/
    Bridge.define("CollectorMachanicObjectBase", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            ID: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "CollectorMachanicObjectBase#init", this ); }

                this.ID = -1;
            }
        }
    });
    /*CollectorMachanicObjectBase end.*/

    /*CollectorMoveLimiter start.*/
    Bridge.define("CollectorMoveLimiter", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            padController: null,
            maxActiveMoving: 0,
            defaultPosition: null,
            poolParent: null,
            limiterText: null,
            padSpacing: 0,
            padPool: null,
            collectorToPad: null,
            originalPos: null,
            textScaleTween: null,
            seqShake: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "CollectorMoveLimiter#init", this ); }

                this.originalPos = new UnityEngine.Vector2();
                this.maxActiveMoving = 5;
                this.padSpacing = 0.5;
                this.padPool = new (System.Collections.Generic.List$1(PadController)).ctor();
                this.collectorToPad = new (System.Collections.Generic.Dictionary$2(CollectorController,PadController)).ctor();
            }
        },
        methods: {
            /*CollectorMoveLimiter.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "CollectorMoveLimiter#Awake", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.limiterText, null)) {
                    this.originalPos = this.limiterText.rectTransform$1.anchoredPosition.$clone();
                }
                this.EnsurePoolSize();
                this.UpdateText();
            },
            /*CollectorMoveLimiter.Awake end.*/

            /*CollectorMoveLimiter.TryStartMove start.*/
            /**
             * Th ly Pad  di chuyn.
             Tr v TRUE: Thnh cng (c i).
             Tr v FALSE: Tht bi (ht ch, phi ng im).
             *
             * @instance
             * @public
             * @this CollectorMoveLimiter
             * @memberof CollectorMoveLimiter
             * @param   {CollectorController}    main       
             * @param   {CollectorController}    partner
             * @return  {boolean}
             */
            TryStartMove: function (main, partner) {
if ( TRACE ) { TRACE( "CollectorMoveLimiter#TryStartMove", this ); }

                var $t, $t1, $t2, $t3;
                if (partner === void 0) { partner = null; }
                // Ly ton b cc con mo trong chui kt ni  tnh ton pad cn thit
                var allCollectorsInChain = this.GetAllCollectorsInChain(main, partner);

                // 1. Xc nh trng thi hin ti v tnh s lng pad cn thit
                var needed = 0;
                $t = Bridge.getEnumerator(allCollectorsInChain);
                try {
                    while ($t.moveNext()) {
                        var collector = $t.Current;
                        if (!this.collectorToPad.containsKey(collector)) {
                            needed = (needed + 1) | 0;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                // 2. Kim tra xem c  slot trng khng
                var available = this.GetAvailableSlots();
                if (available < needed) {
                    // Khng  ch cho c team -> Rung UI bo li -> Tr v False
                    this.TextAnimShakeOnFull();
                    return false;
                }

                // 3. Cp pht Pad (Transaction Phase)
                // Chng ta cn ly Pad ra, nu ly li th phi tr li (Rollback)
                var allocatedPads = new (System.Collections.Generic.List$1(PadController)).ctor();
                var collectorsToAllocate = new (System.Collections.Generic.List$1(CollectorController)).ctor();

                // Xc nh nhng con mo cn cp pht pad mi
                $t1 = Bridge.getEnumerator(allCollectorsInChain);
                try {
                    while ($t1.moveNext()) {
                        var collector1 = $t1.Current;
                        if (!this.collectorToPad.containsKey(collector1)) {
                            collectorsToAllocate.add(collector1);
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                // Ly pad cho tng con mo cn cp pht
                $t2 = Bridge.getEnumerator(collectorsToAllocate);
                try {
                    while ($t2.moveNext()) {
                        var collectorItem = $t2.Current;
                        var padItem = this.GetAndRemoveFreePad();
                        if (UnityEngine.MonoBehaviour.op_Equality(padItem, null)) {
                            // Th fix pool nu li null
                            this.EnsurePoolSize();
                            padItem = this.GetAndRemoveFreePad();
                            if (UnityEngine.MonoBehaviour.op_Equality(padItem, null)) {
                                // Rollback: Tr li tt c pad  ly
                                $t3 = Bridge.getEnumerator(allocatedPads);
                                try {
                                    while ($t3.moveNext()) {
                                        var allocatedPad = $t3.Current;
                                        this.ReturnPadToPool(allocatedPad);
                                    }
                                } finally {
                                    if (Bridge.is($t3, System.IDisposable)) {
                                        $t3.System$IDisposable$Dispose();
                                    }
                                }
                                return false; // Vn li -> Thua
                            }
                        }
                        allocatedPads.add(padItem);
                    }
                } finally {
                    if (Bridge.is($t2, System.IDisposable)) {
                        $t2.System$IDisposable$Dispose();
                    }
                }

                // 4. Cam kt (Commit Phase) - Ch chy khi  cm chc pad trong tay
                for (var i = 0; i < collectorsToAllocate.Count; i = (i + 1) | 0) {
                    var collector2 = collectorsToAllocate.getItem(i);
                    var pad = allocatedPads.getItem(i);

                    // --- FIX LI: BT OBJECT LN TRC KHI CHY COROUTINE ---
                    pad.gameObject.SetActive(true);
                    // ---------------------------------------------------------

                    this.collectorToPad.add(collector2, pad);
                    pad.OnCollectorEnterPad(collector2);
                }

                // Cp nht Visual
                this.UpdateText();
                this.UpdatePoolLayout();

                return true;
            },
            /*CollectorMoveLimiter.TryStartMove end.*/

            /*CollectorMoveLimiter.GetAllCollectorsInChain start.*/
            /**
             * Ly ton b cc con mo trong chui kt ni, bao gm c main v partner
             *
             * @instance
             * @private
             * @this CollectorMoveLimiter
             * @memberof CollectorMoveLimiter
             * @param   {CollectorController}                  main       
             * @param   {CollectorController}                  partner
             * @return  {System.Collections.Generic.List$1}
             */
            GetAllCollectorsInChain: function (main, partner) {
if ( TRACE ) { TRACE( "CollectorMoveLimiter#GetAllCollectorsInChain", this ); }

                var $t;
                if (partner === void 0) { partner = null; }
                var allCollectors = new (System.Collections.Generic.HashSet$1(CollectorController)).ctor();
                var queue = new (System.Collections.Generic.Queue$1(CollectorController)).ctor();

                // Bt u vi main v partner (nu c)
                if (UnityEngine.MonoBehaviour.op_Inequality(main, null)) {
                    allCollectors.add(main);
                    queue.Enqueue(main);
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(partner, null) && !allCollectors.contains(partner)) {
                    allCollectors.add(partner);
                    queue.Enqueue(partner);
                }

                // Duyt qua ton b chui kt ni
                while (queue.Count > 0) {
                    var current = queue.Dequeue();

                    // Thm cc con mo c kt ni vi current vo danh sch
                    if (current.collectorConnect != null) {
                        $t = Bridge.getEnumerator(current.collectorConnect);
                        try {
                            while ($t.moveNext()) {
                                var connectedCollector = $t.Current;
                                if (UnityEngine.MonoBehaviour.op_Inequality(connectedCollector, null) && !allCollectors.contains(connectedCollector)) {
                                    allCollectors.add(connectedCollector);
                                    queue.Enqueue(connectedCollector);
                                }
                            }
                        } finally {
                            if (Bridge.is($t, System.IDisposable)) {
                                $t.System$IDisposable$Dispose();
                            }
                        }
                    }
                }

                return new (System.Collections.Generic.List$1(CollectorController)).$ctor1(allCollectors);
            },
            /*CollectorMoveLimiter.GetAllCollectorsInChain end.*/

            /*CollectorMoveLimiter.OnCollectorMoveFinished start.*/
            OnCollectorMoveFinished: function (collector) {
if ( TRACE ) { TRACE( "CollectorMoveLimiter#OnCollectorMoveFinished", this ); }

                var returnedPad = { };
                if (this.collectorToPad.tryGetValue(collector, returnedPad)) {
                    // Xa khi danh sch qun l
                    this.collectorToPad.remove(collector);

                    // Tr Pad v h cha
                    this.ReturnPadToPool(returnedPad.v);

                    // Cp nht Visual
                    this.UpdateText();
                    this.UpdatePoolLayout();
                }
            },
            /*CollectorMoveLimiter.OnCollectorMoveFinished end.*/

            /*CollectorMoveLimiter.GetAndRemoveFreePad start.*/
            GetAndRemoveFreePad: function () {
if ( TRACE ) { TRACE( "CollectorMoveLimiter#GetAndRemoveFreePad", this ); }

                var freePad = null;
                var index = -1;

                // Tm Pad u tin kh dng trong Pool
                for (var i = 0; i < this.padPool.Count; i = (i + 1) | 0) {
                    if (UnityEngine.MonoBehaviour.op_Inequality(this.padPool.getItem(i), null)) {
                        freePad = this.padPool.getItem(i);
                        index = i;
                        this.padPool.setItem(i, null); // nh du slot ny trng
                        break;
                    }
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(freePad, null)) {
                    // Dn hng (Shift Left): Lp y ch trng va to ra
                    for (var i1 = (index + 1) | 0; i1 < this.padPool.Count; i1 = (i1 + 1) | 0) {
                        this.padPool.setItem(((i1 - 1) | 0), this.padPool.getItem(i1));
                        this.padPool.setItem(i1, null);
                    }
                }

                return freePad;
            },
            /*CollectorMoveLimiter.GetAndRemoveFreePad end.*/

            /*CollectorMoveLimiter.ReturnPadToPool start.*/
            ReturnPadToPool: function (pad) {
if ( TRACE ) { TRACE( "CollectorMoveLimiter#ReturnPadToPool", this ); }

                var targetParent = UnityEngine.Component.op_Inequality(this.poolParent, null) ? this.poolParent : this.transform;
                pad.ResetToDefault(UnityEngine.Component.op_Inequality(this.defaultPosition, null) ? this.defaultPosition.position.$clone() : pc.Vec3.ZERO.clone(), targetParent);

                // Tm slot trng u tin  nht Pad vo
                var insertIdx = -1;
                for (var i = 0; i < this.padPool.Count; i = (i + 1) | 0) {
                    if (UnityEngine.MonoBehaviour.op_Equality(this.padPool.getItem(i), null)) {
                        insertIdx = i;
                        break;
                    }
                }

                if (insertIdx !== -1) {
                    this.padPool.setItem(insertIdx, pad);
                } else {
                    // Fallback: Nht vo u nu khng tm thy slot (him)
                    this.padPool.setItem(0, pad);
                }
            },
            /*CollectorMoveLimiter.ReturnPadToPool end.*/

            /*CollectorMoveLimiter.EnsurePoolSize start.*/
            EnsurePoolSize: function () {
if ( TRACE ) { TRACE( "CollectorMoveLimiter#EnsurePoolSize", this ); }

                var $t;
                if (UnityEngine.MonoBehaviour.op_Equality(this.padController, null)) {
                    return;
                }

                // m bo list size = maxActiveMoving
                while (this.padPool.Count < this.maxActiveMoving) {
                    this.padPool.add(null);
                }
                while (this.padPool.Count > this.maxActiveMoving) {
                    var last = (this.padPool.Count - 1) | 0;
                    if (UnityEngine.MonoBehaviour.op_Inequality(this.padPool.getItem(last), null)) {
                        UnityEngine.MonoBehaviour.Destroy(this.padPool.getItem(last).gameObject);
                    }
                    this.padPool.removeAt(last);
                }

                // Tnh ton s lng Pad cn spawn thm
                var currentlyBusy = this.collectorToPad.Count;
                var currentlyFree = 0;
                $t = Bridge.getEnumerator(this.padPool);
                try {
                    while ($t.moveNext()) {
                        var p = $t.Current;
                        if (UnityEngine.MonoBehaviour.op_Inequality(p, null)) {
                            currentlyFree = (currentlyFree + 1) | 0;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                var needed = (this.maxActiveMoving - (((currentlyBusy + currentlyFree) | 0))) | 0;

                if (needed > 0) {
                    for (var k = 0; k < needed; k = (k + 1) | 0) {
                        // Tm slot null
                        var slot = -1;
                        for (var i = 0; i < this.padPool.Count; i = (i + 1) | 0) {
                            if (UnityEngine.MonoBehaviour.op_Equality(this.padPool.getItem(i), null)) {
                                slot = i;
                                break;
                            }
                        }

                        if (slot !== -1) {
                            var newPad = UnityEngine.Object.Instantiate(PadController, this.padController, UnityEngine.Component.op_Inequality(this.poolParent, null) ? this.poolParent : this.transform);
                            newPad.gameObject.name = System.String.format("{0}_Pooled_{1}", this.padController.name, Bridge.box(slot, System.Int32));
                            if (UnityEngine.Component.op_Inequality(this.defaultPosition, null)) {
                                newPad.transform.position = this.defaultPosition.position.$clone();
                            }
                            newPad.transform.rotation = new pc.Quat().setFromEulerAngles_Unity( 0.0, 0.0, 90.0 );
                            this.padPool.setItem(slot, newPad);
                        }
                    }
                }
                this.UpdatePoolLayout();
            },
            /*CollectorMoveLimiter.EnsurePoolSize end.*/

            /*CollectorMoveLimiter.UpdatePoolLayout start.*/
            UpdatePoolLayout: function () {
if ( TRACE ) { TRACE( "CollectorMoveLimiter#UpdatePoolLayout", this ); }

                var parent = UnityEngine.Component.op_Inequality(this.poolParent, null) ? this.poolParent : this.transform;
                var basePos = UnityEngine.Component.op_Inequality(this.defaultPosition, null) ? this.defaultPosition.position.$clone() : parent.position.$clone();
                var rot = new pc.Quat().setFromEulerAngles_Unity( 0.0, 0.0, 90.0 );

                for (var i = 0; i < this.padPool.Count; i = (i + 1) | 0) {
                    var p = this.padPool.getItem(i);
                    if (UnityEngine.MonoBehaviour.op_Equality(p, null)) {
                        continue;
                    }

                    // B qua nu ang b disable
                    if (UnityEngine.Component.op_Inequality(p.transform.parent, null) && !p.transform.parent.gameObject.activeInHierarchy) {
                        continue;
                    }

                    p.transform.SetParent(parent, true);

                    // Tnh v tr da trn index (Index 0  phi, tng dn sang tri)
                    var targetPos = basePos.$clone().add( pc.Vec3.LEFT.clone().clone().scale( (i * this.padSpacing) ) );

                    p.transform.rotation = rot.$clone();
                    p.PushForwardPad(targetPos);
                }
            },
            /*CollectorMoveLimiter.UpdatePoolLayout end.*/

            /*CollectorMoveLimiter.GetAvailableSlots start.*/
            GetAvailableSlots: function () {
if ( TRACE ) { TRACE( "CollectorMoveLimiter#GetAvailableSlots", this ); }

                return UnityEngine.Mathf.Max(0, ((this.maxActiveMoving - this.collectorToPad.Count) | 0));
            },
            /*CollectorMoveLimiter.GetAvailableSlots end.*/

            /*CollectorMoveLimiter.SetMaxActiveMoving start.*/
            SetMaxActiveMoving: function (value) {
if ( TRACE ) { TRACE( "CollectorMoveLimiter#SetMaxActiveMoving", this ); }

                this.maxActiveMoving = value;
                this.EnsurePoolSize();
                this.UpdateText();
            },
            /*CollectorMoveLimiter.SetMaxActiveMoving end.*/

            /*CollectorMoveLimiter.AddMaxActiveMoving start.*/
            AddMaxActiveMoving: function (increment) {
if ( TRACE ) { TRACE( "CollectorMoveLimiter#AddMaxActiveMoving", this ); }

                if (increment === void 0) { increment = 1; }
                this.maxActiveMoving = (this.maxActiveMoving + increment) | 0;
                this.EnsurePoolSize();
                this.UpdateText();
            },
            /*CollectorMoveLimiter.AddMaxActiveMoving end.*/

            /*CollectorMoveLimiter.IsFullSlots start.*/
            IsFullSlots: function () {
if ( TRACE ) { TRACE( "CollectorMoveLimiter#IsFullSlots", this ); }

                return this.collectorToPad.Count >= this.maxActiveMoving;
            },
            /*CollectorMoveLimiter.IsFullSlots end.*/

            /*CollectorMoveLimiter.UpdateText start.*/
            UpdateText: function () {
if ( TRACE ) { TRACE( "CollectorMoveLimiter#UpdateText", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.limiterText, null)) {
                    this.limiterText.text = System.String.format("{0}/{1}", Bridge.box(this.GetAvailableSlots(), System.Int32), Bridge.box(this.maxActiveMoving, System.Int32));
                    this.TextAnimScale();
                }
            },
            /*CollectorMoveLimiter.UpdateText end.*/

            /*CollectorMoveLimiter.TextAnimScale start.*/
            TextAnimScale: function () {
if ( TRACE ) { TRACE( "CollectorMoveLimiter#TextAnimScale", this ); }

                if (this.textScaleTween != null && DG.Tweening.TweenExtensions.IsActive(this.textScaleTween)) {
                    DG.Tweening.TweenExtensions.Kill(this.textScaleTween);
                }
                this.limiterText.rectTransform$1.localScale = new pc.Vec3( 1, 1, 1 );

                this.textScaleTween = DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.limiterText.rectTransform$1, new pc.Vec3( 1, 1, 1 ).clone().scale( 1.1 ), 0.1), DG.Tweening.Ease.OutSine), Bridge.fn.bind(this, function () {
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.limiterText.rectTransform$1, new pc.Vec3( 1, 1, 1 ), 0.1), DG.Tweening.Ease.InSine);
                }));
            },
            /*CollectorMoveLimiter.TextAnimScale end.*/

            /*CollectorMoveLimiter.TextAnimShakeOnFull start.*/
            TextAnimShakeOnFull: function () {
if ( TRACE ) { TRACE( "CollectorMoveLimiter#TextAnimShakeOnFull", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.limiterText, null)) {
                    return;
                }

                this.limiterText.color = new pc.Color( 1, 0, 0, 1 );

                // Reset v v tr gc trc khi shake
                var target = this.limiterText.rectTransform$1;
                if (this.seqShake != null && DG.Tweening.TweenExtensions.IsActive(this.seqShake)) {
                    DG.Tweening.TweenExtensions.Kill(this.seqShake);
                    target.anchoredPosition = this.originalPos.$clone();
                    this.limiterText.color = new pc.Color( 1, 1, 1, 1 );
                }

                // Logic shake nh nhng (Gc)
                var strength = 0.15;
                var duration = 0.1;

                this.seqShake = DG.Tweening.DOTween.Sequence();

                // Rung sang phi
                DG.Tweening.TweenSettingsExtensions.Append(this.seqShake, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.DOTweenModuleUI.DOAnchorPosX(target, this.originalPos.x + strength, duration * 0.5), DG.Tweening.Ease.OutSine));
                // Rung sang tri
                DG.Tweening.TweenSettingsExtensions.Append(this.seqShake, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.DOTweenModuleUI.DOAnchorPosX(target, this.originalPos.x - strength, duration), DG.Tweening.Ease.InOutSine));
                // V gia
                DG.Tweening.TweenSettingsExtensions.Append(this.seqShake, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.DOTweenModuleUI.DOAnchorPosX(target, this.originalPos.x, duration * 0.5), DG.Tweening.Ease.InSine));

                var strength2 = strength / 2.0;
                // Rung nh thm nhp na
                DG.Tweening.TweenSettingsExtensions.Append(this.seqShake, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.DOTweenModuleUI.DOAnchorPosX(target, this.originalPos.x + strength2, duration * 0.5), DG.Tweening.Ease.OutSine));
                DG.Tweening.TweenSettingsExtensions.Append(this.seqShake, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.DOTweenModuleUI.DOAnchorPosX(target, this.originalPos.x - strength2, duration), DG.Tweening.Ease.InOutSine));
                DG.Tweening.TweenSettingsExtensions.Append(this.seqShake, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.DOTweenModuleUI.DOAnchorPosX(target, this.originalPos.x, duration * 0.5), DG.Tweening.Ease.InSine));

                // i mu v trng
                DG.Tweening.TweenSettingsExtensions.Join(this.seqShake, DG.Tweening.DOTweenModuleUI.DOColor(this.limiterText, new pc.Color( 1, 1, 1, 1 ), duration * 0.5));
            },
            /*CollectorMoveLimiter.TextAnimShakeOnFull end.*/

            /*CollectorMoveLimiter.GetMaxActiveMoving start.*/
            GetMaxActiveMoving: function () {
if ( TRACE ) { TRACE( "CollectorMoveLimiter#GetMaxActiveMoving", this ); }

                return this.maxActiveMoving;
            },
            /*CollectorMoveLimiter.GetMaxActiveMoving end.*/


        }
    });
    /*CollectorMoveLimiter end.*/

    /*CollectorProjectileController start.*/
    Bridge.define("CollectorProjectileController", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            EffectOptions: null,
            MyTransform: null,
            SuperAmmo: false,
            Speed: 0,
            Target: null,
            TimeExisted: 0,
            TimeExistedAfterHit: 0,
            CurrentTimer: 0,
            Stopped: false,
            FlyingFXs: null,
            HitFXs: null,
            TrailFX: null,
            BulletMeshParticle: null,
            bulletRenderer: null,
            returnToPoolCallback: null,
            currentTarget: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "CollectorProjectileController#init", this ); }

                this.Target = new UnityEngine.Vector3();
                this.SuperAmmo = false;
                this.Speed = 0.0;
                this.TimeExisted = 0.0;
                this.TimeExistedAfterHit = 1.0;
                this.CurrentTimer = 0;
                this.Stopped = false;
                this.FlyingFXs = new (System.Collections.Generic.List$1(UnityEngine.ParticleSystem)).ctor();
                this.HitFXs = new (System.Collections.Generic.List$1(UnityEngine.ParticleSystem)).ctor();
            }
        },
        methods: {
            /*CollectorProjectileController.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "CollectorProjectileController#Awake", this ); }

                this.bulletRenderer = this.BulletMeshParticle.GetComponent(UnityEngine.Renderer);
            },
            /*CollectorProjectileController.Awake end.*/

            /*CollectorProjectileController.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "CollectorProjectileController#Update", this ); }

                this.CurrentTimer += UnityEngine.Time.deltaTime;
                if (!this.Stopped && this.Speed > 0) {
                    this.MyTransform.position = this.MyTransform.position.$clone().add( (this.MyTransform.forward).clone().scale( (this.Speed * UnityEngine.Time.deltaTime) ) );
                    this.MyTransform.LookAt$2(this.Target);

                    if (this.CurrentTimer >= this.TimeExisted - this.TimeExistedAfterHit) {
                        this.OnStop();
                    }
                    return;
                }
                if (this.CurrentTimer >= this.TimeExisted + this.TimeExistedAfterHit) {
                    this.gameObject.SetActive(false);
                }
            },
            /*CollectorProjectileController.Update end.*/

            /*CollectorProjectileController.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "CollectorProjectileController#OnDisable", this ); }

                this.Speed = 0.0;
                this.Stopped = true;
                this.TimeExisted = 0.0;
                this.CurrentTimer = 0.0;

                if (UnityEngine.Object.op_Implicit(this.currentTarget)) {
                    this.currentTarget.DestroyPixelVisually();
                }

                this.currentTarget = null;

                this.Despawn(this.SuperAmmo);
            },
            /*CollectorProjectileController.OnDisable end.*/

            /*CollectorProjectileController.RotateToTarget start.*/
            RotateToTarget: function () {
if ( TRACE ) { TRACE( "CollectorProjectileController#RotateToTarget", this ); }

                this.MyTransform.LookAt$2(this.Target);
            },
            /*CollectorProjectileController.RotateToTarget end.*/

            /*CollectorProjectileController.StartProjectile start.*/
            StartProjectile: function (target, speed) {
if ( TRACE ) { TRACE( "CollectorProjectileController#StartProjectile", this ); }

                var $t, $t1;
                if (speed === void 0) { speed = -1.0; }
                this.RotateToTarget();

                if (speed <= 0) {
                    speed = this.EffectOptions.BulletSpeed;
                }
                this.transform.localScale = new pc.Vec3( this.EffectOptions.BulletScale, this.EffectOptions.BulletScale, this.EffectOptions.BulletScale );
                this.gameObject.SetActive(true);
                this.Speed = speed;
                this.Target = target.transform.position.$clone();
                var distance = pc.Vec3.distance( this.MyTransform.position, this.Target );
                var travelTime = distance / this.Speed;
                this.TimeExisted = travelTime + this.TimeExistedAfterHit;
                this.CurrentTimer = 0;

                this.currentTarget = target;

                this.Stopped = false;
                $t = Bridge.getEnumerator(this.FlyingFXs);
                try {
                    while ($t.moveNext()) {
                        var fx = $t.Current;
                        fx.Play();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                $t1 = Bridge.getEnumerator(this.HitFXs);
                try {
                    while ($t1.moveNext()) {
                        var fx1 = $t1.Current;
                        fx1.Stop();
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }
            },
            /*CollectorProjectileController.StartProjectile end.*/

            /*CollectorProjectileController.StartProjectile$1 start.*/
            StartProjectile$1: function (target, speed) {
if ( TRACE ) { TRACE( "CollectorProjectileController#StartProjectile$1", this ); }

                var $t, $t1;
                if (speed === void 0) { speed = -1.0; }
                this.RotateToTarget();

                if (speed <= 0) {
                    speed = this.EffectOptions.BulletSpeed;
                }
                this.transform.localScale = new pc.Vec3( this.EffectOptions.BulletScale, this.EffectOptions.BulletScale, this.EffectOptions.BulletScale );
                this.gameObject.SetActive(true);
                this.Speed = speed;
                this.Target = target.$clone();
                var distance = pc.Vec3.distance( this.MyTransform.position, this.Target );
                var travelTime = distance / this.Speed;
                this.TimeExisted = travelTime + this.TimeExistedAfterHit;
                this.CurrentTimer = 0;
                this.currentTarget = null;
                this.Stopped = false;
                $t = Bridge.getEnumerator(this.FlyingFXs);
                try {
                    while ($t.moveNext()) {
                        var fx = $t.Current;
                        fx.Play();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                $t1 = Bridge.getEnumerator(this.HitFXs);
                try {
                    while ($t1.moveNext()) {
                        var fx1 = $t1.Current;
                        fx1.Stop();
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }
            },
            /*CollectorProjectileController.StartProjectile$1 end.*/

            /*CollectorProjectileController.SetPosition start.*/
            SetPosition: function (pos) {
if ( TRACE ) { TRACE( "CollectorProjectileController#SetPosition", this ); }

                this.MyTransform.position = pos.$clone();
            },
            /*CollectorProjectileController.SetPosition end.*/

            /*CollectorProjectileController.SetColor start.*/
            SetColor: function (color) {
if ( TRACE ) { TRACE( "CollectorProjectileController#SetColor", this ); }

                var $t, $t1;
                var gradient = new pc.ColorGradient(void 0, void 0, 0);
                gradient.setKeys(System.Array.init([new UnityEngine.GradientColorKey(color.$clone(), 0.0), new UnityEngine.GradientColorKey(color.$clone(), 1.0)], UnityEngine.GradientColorKey), System.Array.init([new UnityEngine.GradientAlphaKey(1.0, 0.0), new UnityEngine.GradientAlphaKey(1.0, 0.7), new UnityEngine.GradientAlphaKey(0.0, 1.0)], UnityEngine.GradientAlphaKey));

                this.TrailFX.colorGradient = gradient;
                $t = Bridge.getEnumerator(this.FlyingFXs);
                try {
                    while ($t.moveNext()) {
                        var fx = $t.Current;
                        var main = fx.main;
                        main.startColor = new pc.MinMaxGradient( color.$clone() );
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                $t1 = Bridge.getEnumerator(this.HitFXs);
                try {
                    while ($t1.moveNext()) {
                        var fx1 = $t1.Current;
                        var main1 = fx1.main;
                        main1.startColor = new pc.MinMaxGradient( color.$clone() );
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }
                this.SetBulletMeshColor(color);
            },
            /*CollectorProjectileController.SetColor end.*/

            /*CollectorProjectileController.SetBulletMeshColor start.*/
            SetBulletMeshColor: function (_color) {
if ( TRACE ) { TRACE( "CollectorProjectileController#SetBulletMeshColor", this ); }

                if (UnityEngine.Component.op_Equality(this.bulletRenderer, null)) {
                    this.bulletRenderer = UnityEngine.Component.op_Inequality(this.BulletMeshParticle, null) ? this.BulletMeshParticle.GetComponent(UnityEngine.Renderer) : null;
                }
                if (UnityEngine.Component.op_Equality(this.bulletRenderer, null)) {
                    return;
                }

                var mat = this.bulletRenderer.sharedMaterial;
                if (mat == null) {
                    return;
                }

                // Kim tra shader name
                var shaderName = mat.shader != null ? mat.shader.name : "null";
                //Debug.Log($"[BulletColor] Shader: {shaderName}");

                // D property c th dng
                if (mat.HasProperty$1("_BaseColor")) {
                    mat.SetColor$1("_BaseColor", _color);
                } else {
                    if (mat.HasProperty$1("_TintColor")) {
                        mat.SetColor$1("_TintColor", _color);
                    } else {
                        if (mat.HasProperty$1("_Color")) {
                            mat.SetColor$1("_Color", _color);
                        }
                    }
                }

                // Nu c Outline
                if (this.EffectOptions.ChangeOutlineColor && mat.HasProperty$1("_OutlineColor")) {
                    mat.SetColor$1("_OutlineColor", _color);
                }

                // Nu shader c emission  set lun cho sng hn
                if (mat.HasProperty$1("_EmissionColor")) {
                    mat.EnableKeyword("_EMISSION");
                    mat.SetColor$1("_EmissionColor", new pc.Color( _color.r * 0.5, _color.g * 0.5, _color.b * 0.5, _color.a * 0.5 ));
                }

                // Va set cho particle main na  particle ng b
                var main = this.BulletMeshParticle.main;
                main.startColor = new pc.MinMaxGradient(_color.$clone());

                //Debug.Log($"[BulletColor] Applied color: {_color}");
            },
            /*CollectorProjectileController.SetBulletMeshColor end.*/

            /*CollectorProjectileController.OnStop start.*/
            OnStop: function () {
if ( TRACE ) { TRACE( "CollectorProjectileController#OnStop", this ); }

                var $t, $t1;
                this.Stopped = true;

                $t = Bridge.getEnumerator(this.HitFXs);
                try {
                    while ($t.moveNext()) {
                        var fx = $t.Current;
                        fx.Play();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                $t1 = Bridge.getEnumerator(this.FlyingFXs);
                try {
                    while ($t1.moveNext()) {
                        var fx1 = $t1.Current;
                        fx1.Stop();
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                this.currentTarget.DestroyPixelVisually();
                this.currentTarget = null;
            },
            /*CollectorProjectileController.OnStop end.*/

            /*CollectorProjectileController.SetReturnToPoolCallback start.*/
            SetReturnToPoolCallback: function (callback) {
if ( TRACE ) { TRACE( "CollectorProjectileController#SetReturnToPoolCallback", this ); }

                this.returnToPoolCallback = callback;
            },
            /*CollectorProjectileController.SetReturnToPoolCallback end.*/

            /*CollectorProjectileController.Despawn start.*/
            Despawn: function ($super) {
if ( TRACE ) { TRACE( "CollectorProjectileController#Despawn", this ); }

                !Bridge.staticEquals(this.returnToPoolCallback, null) ? this.returnToPoolCallback(this, $super) : null;
            },
            /*CollectorProjectileController.Despawn end.*/


        },
        overloads: {
            "StartProjectile(Vector3, float)": "StartProjectile$1"
        }
    });
    /*CollectorProjectileController end.*/

    /*CollectorProjectilePool start.*/
    Bridge.define("CollectorProjectilePool", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                Instance: null
            }
        },
        fields: {
            normalProjectilePrefab: null,
            superProjectilePrefab: null,
            initialCount: 0,
            normalBulletPool: null,
            superBulletPool: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "CollectorProjectilePool#init", this ); }

                this.initialCount = 20;
                this.normalBulletPool = new (System.Collections.Generic.Queue$1(CollectorProjectileController)).ctor();
                this.superBulletPool = new (System.Collections.Generic.Queue$1(CollectorProjectileController)).ctor();
            }
        },
        methods: {
            /*CollectorProjectilePool.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "CollectorProjectilePool#Awake", this ); }

                // Singleton
                if (UnityEngine.MonoBehaviour.op_Inequality(CollectorProjectilePool.Instance, null) && UnityEngine.MonoBehaviour.op_Inequality(CollectorProjectilePool.Instance, this)) {
                    UnityEngine.MonoBehaviour.Destroy(this.gameObject);
                    return;
                }

                CollectorProjectilePool.Instance = this;

                this.InitializePool();
            },
            /*CollectorProjectilePool.Awake end.*/

            /*CollectorProjectilePool.InitializePool start.*/
            InitializePool: function () {
if ( TRACE ) { TRACE( "CollectorProjectilePool#InitializePool", this ); }

                for (var i = 0; i < this.initialCount; i = (i + 1) | 0) {
                    this.CreateProjectile(false, false);
                }
            },
            /*CollectorProjectilePool.InitializePool end.*/

            /*CollectorProjectilePool.CreateProjectile start.*/
            CreateProjectile: function ($super, active) {
if ( TRACE ) { TRACE( "CollectorProjectilePool#CreateProjectile", this ); }

                if (active === void 0) { active = false; }
                var prefabToSpawn = $super ? this.superProjectilePrefab : this.normalProjectilePrefab;
                var proj = UnityEngine.Object.Instantiate(CollectorProjectileController, prefabToSpawn, this.transform);
                proj.gameObject.SetActive(active);

                proj.SetReturnToPoolCallback(Bridge.fn.cacheBind(this, this.ReturnToPool));

                if (!active) {
                    if ($super) {
                        this.superBulletPool.Enqueue(proj);
                    } else {
                        this.normalBulletPool.Enqueue(proj);
                    }
                }

                return proj;
            },
            /*CollectorProjectilePool.CreateProjectile end.*/

            /*CollectorProjectilePool.GetProjectile start.*/
            GetProjectile: function ($super) {
if ( TRACE ) { TRACE( "CollectorProjectilePool#GetProjectile", this ); }

                if ($super) {
                    if (this.superBulletPool.Count > 0) {
                        var proj = this.superBulletPool.Dequeue();
                        proj.gameObject.SetActive(true);
                        return proj;
                    }
                } else {
                    if (this.normalBulletPool.Count > 0) {
                        var proj1 = this.normalBulletPool.Dequeue();
                        proj1.gameObject.SetActive(true);
                        return proj1;
                    }
                }

                return this.CreateProjectile($super, true);
            },
            /*CollectorProjectilePool.GetProjectile end.*/

            /*CollectorProjectilePool.ReturnToPool start.*/
            ReturnToPool: function (proj, $super) {
if ( TRACE ) { TRACE( "CollectorProjectilePool#ReturnToPool", this ); }

                proj.gameObject.SetActive(false);
                if ($super) {
                    this.superBulletPool.Enqueue(proj);
                } else {
                    this.normalBulletPool.Enqueue(proj);
                }
            },
            /*CollectorProjectilePool.ReturnToPool end.*/


        }
    });
    /*CollectorProjectilePool end.*/

    /*CollectorQueueManager start.*/
    Bridge.define("CollectorQueueManager", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            deadQueue: null,
            maxSlot: 0,
            queuePositions: null,
            defaultDeadPosition: null,
            deadOffset: null,
            queueArray: null,
            alertFullSlotAnim: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "CollectorQueueManager#init", this ); }

                this.deadOffset = new UnityEngine.Vector3();
                this.deadQueue = new (System.Collections.Generic.List$1(CollectorController)).ctor();
                this.maxSlot = 5;
                this.deadOffset = new pc.Vec3( 1.0, 0.0, 0.0 );
            }
        },
        methods: {
            /*CollectorQueueManager.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "CollectorQueueManager#Awake", this ); }

                this.queueArray = System.Array.init(this.maxSlot, null, CollectorController);

            },
            /*CollectorQueueManager.Awake end.*/

            /*CollectorQueueManager.AddMaxSlot start.*/
            AddMaxSlot: function (increment) {
if ( TRACE ) { TRACE( "CollectorQueueManager#AddMaxSlot", this ); }

                if (increment === void 0) { increment = 1; }
                this.SetMaxSlot(((this.maxSlot + increment) | 0));
            },
            /*CollectorQueueManager.AddMaxSlot end.*/

            /*CollectorQueueManager.SetMaxSlot start.*/
            SetMaxSlot: function (newMaxSlot) {
if ( TRACE ) { TRACE( "CollectorQueueManager#SetMaxSlot", this ); }

                if (newMaxSlot === this.maxSlot) {
                    return;
                }
                var newArray = System.Array.init(newMaxSlot, null, CollectorController);
                var copyCount = UnityEngine.Mathf.Min(this.queueArray != null ? this.queueArray.length : 0, newMaxSlot);
                for (var i = 0; i < copyCount; i = (i + 1) | 0) {
                    newArray[i] = this.queueArray[i];
                }
                this.queueArray = newArray;
                this.maxSlot = newMaxSlot;
            },
            /*CollectorQueueManager.SetMaxSlot end.*/

            /*CollectorQueueManager.IsQueueFull start.*/
            IsQueueFull: function () {
if ( TRACE ) { TRACE( "CollectorQueueManager#IsQueueFull", this ); }

                for (var i = 0; i < this.maxSlot; i = (i + 1) | 0) {
                    if (UnityEngine.MonoBehaviour.op_Equality(this.queueArray[i], null)) {
                        return false;
                    }
                }
                return true;
            },
            /*CollectorQueueManager.IsQueueFull end.*/

            /*CollectorQueueManager.EnqueueCollector start.*/
            EnqueueCollector: function (collector) {
if ( TRACE ) { TRACE( "CollectorQueueManager#EnqueueCollector", this ); }

                if (this.IsQueueFull()) {
                    UnityEngine.Debug.Log$1("Queue is full, cannot enqueue collector.");
                    return;
                }

                for (var i = 0; i < this.maxSlot; i = (i + 1) | 0) {
                    if (UnityEngine.MonoBehaviour.op_Equality(this.queueArray[i], null)) {
                        this.queueArray[i] = collector;
                        this.StartCoroutine$1(this.MoveCollectorToQueuePosition(collector, i));

                        if (UnityEngine.MonoBehaviour.op_Inequality(this.alertFullSlotAnim, null) && this.IsQueueFull()) {
                            this.alertFullSlotAnim.PlayAlertAnim();
                        }
                        //Debug.Log($"[CollectorQueueManager] Enqueued collector {collector.ColorCollector.ID} to slot {i}");
                        return;
                    }
                }

                return;
            },
            /*CollectorQueueManager.EnqueueCollector end.*/

            /*CollectorQueueManager.RemoveCollectorFromDeadQueue start.*/
            RemoveCollectorFromDeadQueue: function (collector) {
if ( TRACE ) { TRACE( "CollectorQueueManager#RemoveCollectorFromDeadQueue", this ); }

                var index = this.deadQueue.indexOf(collector);
                if (index === -1) {
                    return;
                }
                this.deadQueue.removeAt(index);
                // Cp nht li v tr cho cc collector pha sau
                for (var i = index; i < this.deadQueue.Count; i = (i + 1) | 0) {
                    this.MoveCollectorToDeadPosition(this.deadQueue.getItem(i));
                }
            },
            /*CollectorQueueManager.RemoveCollectorFromDeadQueue end.*/

            /*CollectorQueueManager.RemoveCollectorFromQueue start.*/
            RemoveCollectorFromQueue: function (collector) {
if ( TRACE ) { TRACE( "CollectorQueueManager#RemoveCollectorFromQueue", this ); }

                for (var i = 0; i < this.maxSlot; i = (i + 1) | 0) {
                    if (UnityEngine.MonoBehaviour.op_Equality(this.queueArray[i], collector)) {
                        // Dch cc collector pha sau ln mt slot
                        for (var j = i; j < ((this.maxSlot - 1) | 0); j = (j + 1) | 0) {
                            this.queueArray[j] = this.queueArray[((j + 1) | 0)];
                            if (UnityEngine.MonoBehaviour.op_Inequality(this.queueArray[j], null)) {
                                this.PushForwardCollectorOnQueue(this.queueArray[j], j);
                            }
                        }
                        //Debug.Log($"[CollectorQueueManager] Removed collector {collector.ColorCollector.ID} from slot {i}");
                        this.queueArray[((this.maxSlot - 1) | 0)] = null;
                        return;
                    }
                }
                return;
            },
            /*CollectorQueueManager.RemoveCollectorFromQueue end.*/

            /*CollectorQueueManager.IsInQueue start.*/
            IsInQueue: function (collector) {
if ( TRACE ) { TRACE( "CollectorQueueManager#IsInQueue", this ); }

                for (var i = 0; i < this.maxSlot; i = (i + 1) | 0) {
                    if (UnityEngine.MonoBehaviour.op_Inequality(this.queueArray[i], null) && this.queueArray[i].ColorCollector.ID === collector.ColorCollector.ID) {
                        return true;
                    }
                }
                return false;
            },
            /*CollectorQueueManager.IsInQueue end.*/

            /*CollectorQueueManager.GetLastCollectorInQueue start.*/
            GetLastCollectorInQueue: function () {
if ( TRACE ) { TRACE( "CollectorQueueManager#GetLastCollectorInQueue", this ); }

                if (this.queueArray == null || this.maxSlot <= 0) {
                    return null;
                }

                // Duyt t cui v u  tm collector cui cng (index ln nht) c gi tr khc null
                for (var i = (UnityEngine.Mathf.Min(this.maxSlot, this.queueArray.length) - 1) | 0; i >= 0; i = (i - 1) | 0) {
                    if (UnityEngine.MonoBehaviour.op_Inequality(this.queueArray[i], null)) {
                        return this.queueArray[i];
                    }
                }

                return null;
            },
            /*CollectorQueueManager.GetLastCollectorInQueue end.*/

            /*CollectorQueueManager.MoveCollectorToQueuePosition start.*/
            MoveCollectorToQueuePosition: function (collector, index) {
if ( TRACE ) { TRACE( "CollectorQueueManager#MoveCollectorToQueuePosition", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    //await UniTask.DelayFrame(1); // i 1 frame  trnh li transform
                                        !Bridge.staticEquals(GameplayEventsManager.OnACollectorMoveToQueue, null) ? GameplayEventsManager.OnACollectorMoveToQueue(collector) : null;
                                        // Action action = () => 
                                        // {
                                        //     collector.DeUpdateText();
                                        // };
                                        if (this.queuePositions == null) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 2;
                                        continue;
                                }
                                case 1: {
                                    return false;
                                }
                                case 2: {
                                    UnityEngine.MonoBehaviour.op_Inequality(collector, null) ? collector.MoveToPos(this.queuePositions[index].position, CollectorAnimState.MoveToQueueRotateBack, null) : null;

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*CollectorQueueManager.MoveCollectorToQueuePosition end.*/

            /*CollectorQueueManager.MoveCollectorToDeadPosition start.*/
            MoveCollectorToDeadPosition: function (collector, onComplete) {
if ( TRACE ) { TRACE( "CollectorQueueManager#MoveCollectorToDeadPosition", this ); }

                if (onComplete === void 0) { onComplete = null; }
                // Nu collector cha c trong deadQueue th thm vo cui
                var realIndex = this.deadQueue.indexOf(collector);
                if (realIndex === -1) {
                    this.deadQueue.add(collector);
                    realIndex = (this.deadQueue.Count - 1) | 0;
                }
                // Nu  c th gi nguyn v tr hin ti

                var targetPosition = this.defaultDeadPosition.position.$clone().add( this.deadOffset.$clone().clone().scale( realIndex ) );
                // Combine internal cleanup action vi callback bn ngoi
                var internalAction = function () {
                    collector.ColorCollector.RabbitRotateTransform.eulerAngles = pc.Vec3.ZERO.clone();
                };
                var combined = null;
                if (!Bridge.staticEquals(onComplete, null)) {
                    combined = function () {
                        internalAction();
                        onComplete();
                    };
                } else {
                    combined = internalAction;
                }

                collector.MoveToPos(targetPosition, CollectorAnimState.MoveToDeadPosition, combined);
            },
            /*CollectorQueueManager.MoveCollectorToDeadPosition end.*/

            /*CollectorQueueManager.PushForwardCollectorOnQueue start.*/
            PushForwardCollectorOnQueue: function (collector, index) {
if ( TRACE ) { TRACE( "CollectorQueueManager#PushForwardCollectorOnQueue", this ); }

                !Bridge.staticEquals(GameplayEventsManager.OnACollectorMoveToQueue, null) ? GameplayEventsManager.OnACollectorMoveToQueue(collector) : null;
                collector.MoveToPos(this.queuePositions[index].position, CollectorAnimState.MoveToQueueRotateBack);
            },
            /*CollectorQueueManager.PushForwardCollectorOnQueue end.*/

            /*CollectorQueueManager.HasEnoughSlotsFor start.*/
            HasEnoughSlotsFor: function (_slot) {
if ( TRACE ) { TRACE( "CollectorQueueManager#HasEnoughSlotsFor", this ); }

                var availableSlots = 0;
                for (var i = 0; i < this.maxSlot; i = (i + 1) | 0) {
                    if (UnityEngine.MonoBehaviour.op_Equality(this.queueArray[i], null)) {
                        availableSlots = (availableSlots + 1) | 0;
                    }
                }
                return availableSlots >= _slot;
            },
            /*CollectorQueueManager.HasEnoughSlotsFor end.*/


        }
    });
    /*CollectorQueueManager end.*/

    /*CollectorRearrangeIDs start.*/
    Bridge.define("CollectorRearrangeIDs", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            CurrentCollectorsConfigs: null
        }
    });
    /*CollectorRearrangeIDs end.*/

    /*CollectorState start.*/
    Bridge.define("CollectorState", {
        $kind: 6,
        statics: {
            fields: {
                InColumn: 0,
                InQueue: 1,
                Moving: 2,
                Completed: 3,
                InDeadQueue: 4
            }
        }
    });
    /*CollectorState end.*/

    /*CollectorVisualHandler start.*/
    Bridge.define("CollectorVisualHandler", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            CollectorHandle: null,
            Animator: null,
            colorPalette: null,
            GunnerRenderers: null,
            rimTween: null,
            block: null,
            colorCache: null,
            BulletsText: null,
            TankRopeObj: null,
            TankRope: null,
            TankRopeMesh: null,
            LockSpriteRenderer: null,
            CattonBox: null,
            QuestionMarkSpriteRenderer: null,
            OriginalMat: null,
            HiddenOutlineColor: null,
            HiddenRopeColor: null,
            BulletSpawner: null,
            CollectorMuzzleVFX: null,
            ReavealVFX: null,
            HighSpeedTrail: null,
            CurrentColor: null,
            hidden: false,
            connectedTarget: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "CollectorVisualHandler#init", this ); }

                this.HiddenOutlineColor = new UnityEngine.Color();
                this.HiddenRopeColor = new UnityEngine.Color();
                this.CurrentColor = new UnityEngine.Color();
                this.GunnerRenderers = new (System.Collections.Generic.List$1(UnityEngine.Renderer)).ctor();
                this.colorCache = new (System.Collections.Generic.Dictionary$2(System.String,UnityEngine.Color)).ctor();
                this.HiddenOutlineColor = new pc.Color( 1, 1, 1, 1 );
                this.HiddenRopeColor = new pc.Color( 1, 1, 1, 1 );
                this.hidden = false;
            }
        },
        methods: {
            /*CollectorVisualHandler.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "CollectorVisualHandler#Awake", this ); }

                this.block = new UnityEngine.MaterialPropertyBlock();
                this.RegisterEvents();
            },
            /*CollectorVisualHandler.Awake end.*/

            /*CollectorVisualHandler.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "CollectorVisualHandler#OnEnable", this ); }

                this.StopHighlight();
            },
            /*CollectorVisualHandler.OnEnable end.*/

            /*CollectorVisualHandler.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "CollectorVisualHandler#OnDisable", this ); }

                this.connectedTarget = null;
                this.StopHighlight();
            },
            /*CollectorVisualHandler.OnDisable end.*/

            /*CollectorVisualHandler.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "CollectorVisualHandler#OnDestroy", this ); }

                this.UnRegisterEvents();
                // Clear the color cache to prevent memory leaks
                this.colorCache.clear();
            },
            /*CollectorVisualHandler.OnDestroy end.*/

            /*CollectorVisualHandler.RegisterEvents start.*/
            RegisterEvents: function () {
if ( TRACE ) { TRACE( "CollectorVisualHandler#RegisterEvents", this ); }

                GameplayEventsManager.OnCollectorRevealed = Bridge.fn.combine(GameplayEventsManager.OnCollectorRevealed, Bridge.fn.cacheBind(this, this.OnACollectorRevealed));
            },
            /*CollectorVisualHandler.RegisterEvents end.*/

            /*CollectorVisualHandler.UnRegisterEvents start.*/
            UnRegisterEvents: function () {
if ( TRACE ) { TRACE( "CollectorVisualHandler#UnRegisterEvents", this ); }

                GameplayEventsManager.OnCollectorRevealed = Bridge.fn.remove(GameplayEventsManager.OnCollectorRevealed, Bridge.fn.cacheBind(this, this.OnACollectorRevealed));
            },
            /*CollectorVisualHandler.UnRegisterEvents end.*/

            /*CollectorVisualHandler.OnACollectorRevealed start.*/
            OnACollectorRevealed: function (_collector) {
if ( TRACE ) { TRACE( "CollectorVisualHandler#OnACollectorRevealed", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.connectedTarget, null)) {
                    return;
                }
                if (this.connectedTarget.CollectorHandle.ID !== _collector.ID || this.CollectorHandle.ID === _collector.ID) {
                    return;
                }
                //var target = _collector.VisualHandler;
                //SetupRope(target, null);
                this.UpdateRopeColor();
            },
            /*CollectorVisualHandler.OnACollectorRevealed end.*/

            /*CollectorVisualHandler.SetColor start.*/
            SetColor: function (colorCode) {
if ( TRACE ) { TRACE( "CollectorVisualHandler#SetColor", this ); }

                if (this.GunnerRenderers != null) {
                    // Use cached color if available, otherwise get from palette and cache it
                    var color = { v : new UnityEngine.Color() };
                    if (!this.colorCache.tryGetValue(colorCode, color)) {
                        color.v = this.colorPalette.GetColorByCode(colorCode);
                        this.colorCache.setItem(colorCode, color.v.$clone());
                    }
                    this.CurrentColor = color.v.$clone(); // Set CurrentColor first
                    // Try to get material from colorPalette first, fallback to OriginalMat
                    var mat = this.OriginalMat;
                    if (this.colorPalette != null && this.colorPalette.MatPallete.containsKey(colorCode)) {
                        var paletteMat = this.colorPalette.MatPallete.getItem(colorCode);
                        if (paletteMat != null) {
                            mat = paletteMat;
                        }
                    }
                    this.SetMeshMaterial(mat);
                    this.SetMuzzleColor();
                    this.UpdateRopeColor(); // Update rope color when main color changes
                }
            },
            /*CollectorVisualHandler.SetColor end.*/

            /*CollectorVisualHandler.SetMaterial start.*/
            SetMaterial: function (colorCode, mat) {
if ( TRACE ) { TRACE( "CollectorVisualHandler#SetMaterial", this ); }

                if (this.GunnerRenderers != null) {
                    // Use cached color if available, otherwise get from palette and cache it
                    var color = { v : new UnityEngine.Color() };
                    if (!this.colorCache.tryGetValue(colorCode, color)) {
                        color.v = this.colorPalette.GetColorByCode(colorCode);
                        this.colorCache.setItem(colorCode, color.v.$clone());
                    }
                    this.CurrentColor = color.v.$clone(); // Set CurrentColor first
                    this.SetMeshMaterial(mat);
                    this.SetMuzzleColor();
                    this.UpdateRopeColor(); // Update rope color when main color changes
                }
            },
            /*CollectorVisualHandler.SetMaterial end.*/

            /*CollectorVisualHandler.SetMeshMaterial start.*/
            SetMeshMaterial: function (mat) {
if ( TRACE ) { TRACE( "CollectorVisualHandler#SetMeshMaterial", this ); }

                // Apply the material to all renderers in the pipe part
                for (var i = 0; i < this.GunnerRenderers.Count; i = (i + 1) | 0) {
                    var renderer = this.GunnerRenderers.getItem(i);
                    if (UnityEngine.Component.op_Inequality(renderer, null)) {
                        renderer.material = mat;
                    }
                }
            },
            /*CollectorVisualHandler.SetMeshMaterial end.*/

            /*CollectorVisualHandler.SetMeshColor start.*/
            SetMeshColor: function (_color) {
if ( TRACE ) { TRACE( "CollectorVisualHandler#SetMeshColor", this ); }

                // Create a MaterialPropertyBlock to set the color
                this.block.SetColor$1("_Color", _color);

                // Apply the color to all renderers in the pipe part
                for (var i = 0; i < this.GunnerRenderers.Count; i = (i + 1) | 0) {
                    var renderer = this.GunnerRenderers.getItem(i);
                    if (UnityEngine.Component.op_Inequality(renderer, null)) {
                        renderer.material = this.OriginalMat;
                        renderer.SetPropertyBlock(this.block);
                    }
                }
            },
            /*CollectorVisualHandler.SetMeshColor end.*/

            /*CollectorVisualHandler.SetRopeColor start.*/
            SetRopeColor: function (_firstColor, _secondColor) {
if ( TRACE ) { TRACE( "CollectorVisualHandler#SetRopeColor", this ); }

                this.TankRopeMesh.SetColor$1(_firstColor, _secondColor);
            },
            /*CollectorVisualHandler.SetRopeColor end.*/

            /*CollectorVisualHandler.SetupRope start.*/
            SetupRope: function (active, target) {
if ( TRACE ) { TRACE( "CollectorVisualHandler#SetupRope", this ); }

                this.connectedTarget = target;
                if (UnityEngine.MonoBehaviour.op_Equality(this.connectedTarget, null)) {
                    return;
                }
                if (active) {
                    this.TankRopeObj.SetActive(true);
                    this.TankRope.SetEndPoint(target.TankRopeObj.transform);
                    var stColor = this.CollectorHandle.IsHidden ? this.HiddenRopeColor.$clone() : this.CurrentColor.$clone();
                    var ndColor = target.CollectorHandle.IsHidden ? this.HiddenRopeColor.$clone() : target.CurrentColor.$clone();
                    this.SetRopeColor(stColor, ndColor);
                } else {
                    this.TankRopeObj.SetActive(false);
                }
            },
            /*CollectorVisualHandler.SetupRope end.*/

            /*CollectorVisualHandler.HideRope start.*/
            HideRope: function () {
if ( TRACE ) { TRACE( "CollectorVisualHandler#HideRope", this ); }

                this.TankRopeObj.SetActive(false);
            },
            /*CollectorVisualHandler.HideRope end.*/

            /*CollectorVisualHandler.UpdateRopeColor start.*/
            UpdateRopeColor: function () {
if ( TRACE ) { TRACE( "CollectorVisualHandler#UpdateRopeColor", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.connectedTarget, null)) {
                    return;
                }

                this.TankRope.SetEndPoint(this.connectedTarget.TankRopeObj.transform);
                var stColor = this.CollectorHandle.IsHidden ? this.HiddenRopeColor.$clone() : this.CurrentColor.$clone();
                var ndColor = this.connectedTarget.CollectorHandle.IsHidden ? this.HiddenRopeColor.$clone() : this.connectedTarget.CurrentColor.$clone();
                this.SetRopeColor(stColor, ndColor);
            },
            /*CollectorVisualHandler.UpdateRopeColor end.*/

            /*CollectorVisualHandler.RefreshColor start.*/
            RefreshColor: function () {
if ( TRACE ) { TRACE( "CollectorVisualHandler#RefreshColor", this ); }
 },
            /*CollectorVisualHandler.RefreshColor end.*/

            /*CollectorVisualHandler.SetBulletText start.*/
            SetBulletText: function (bullet) {
if ( TRACE ) { TRACE( "CollectorVisualHandler#SetBulletText", this ); }

                this.BulletsText.enabled = !this.hidden && bullet > 0;
                this.BulletsText.text = Bridge.toString(bullet);
            },
            /*CollectorVisualHandler.SetBulletText end.*/

            /*CollectorVisualHandler.SetLockedIcon start.*/
            SetLockedIcon: function (locked) {
if ( TRACE ) { TRACE( "CollectorVisualHandler#SetLockedIcon", this ); }

                this.LockSpriteRenderer.enabled = locked;
            },
            /*CollectorVisualHandler.SetLockedIcon end.*/

            /*CollectorVisualHandler.SetHiddenState start.*/
            SetHiddenState: function (_hidden, instantly) {
if ( TRACE ) { TRACE( "CollectorVisualHandler#SetHiddenState", this ); }

                if (instantly === void 0) { instantly = true; }
                this.hidden = _hidden;
                var stColor = this.CollectorHandle.IsHidden ? this.HiddenRopeColor.$clone() : this.CurrentColor.$clone();
                var ndColor = this.CurrentColor.$clone();
                if (UnityEngine.Object.op_Implicit(this.connectedTarget)) {
                    ndColor = this.connectedTarget.CollectorHandle.IsHidden ? this.HiddenRopeColor.$clone() : this.connectedTarget.CurrentColor.$clone();
                }
                this.BulletsText.enabled = !_hidden && this.CollectorHandle.BulletLeft > 0;
                this.QuestionMarkSpriteRenderer.enabled = _hidden;
                if (!UnityEngine.Application.isPlaying) {
                    this.QuestionMarkSpriteRenderer.color = new pc.Color( 0, 1, 1, 1 );
                }
                this.SetRopeColor(stColor, ndColor);

                if (!instantly) {
                    if (!_hidden) {
                        this.StartCoroutine$1(this.DelayReveal(0.3));
                    }
                } else {
                    this.SetVisisble(!_hidden);
                    this.CattonBox.SetActive(_hidden);
                }

                // The code after this return was unreachable, so I've removed it
            },
            /*CollectorVisualHandler.SetHiddenState end.*/

            /*CollectorVisualHandler.DelayReveal start.*/
            DelayReveal: function (delay) {
if ( TRACE ) { TRACE( "CollectorVisualHandler#DelayReveal", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    this.SetVisisble(true);
                                        $enumerator.current = new UnityEngine.WaitForSeconds(delay);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    if (!this.Animator.JumpingToBelt) {
                                            this.Animator.PlayJump();
                                        }
                                        this.Animator.PlayBoxReveal();
                                        UnityEngine.Component.op_Inequality(this.ReavealVFX, null) ? this.ReavealVFX.Play() : null;
                                        $enumerator.current = new UnityEngine.WaitForSeconds(0.7);
                                        $step = 2;
                                        return true;
                                }
                                case 2: {
                                    this.CattonBox.SetActive(false);

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*CollectorVisualHandler.DelayReveal end.*/

            /*CollectorVisualHandler.SetMuzzleColor start.*/
            SetMuzzleColor: function () {
if ( TRACE ) { TRACE( "CollectorVisualHandler#SetMuzzleColor", this ); }

                var main = this.CollectorMuzzleVFX.main;
                main.startColor = new pc.MinMaxGradient(this.CurrentColor.$clone());
            },
            /*CollectorVisualHandler.SetMuzzleColor end.*/

            /*CollectorVisualHandler.PlayMuzzleEffect start.*/
            PlayMuzzleEffect: function () {
if ( TRACE ) { TRACE( "CollectorVisualHandler#PlayMuzzleEffect", this ); }

                this.CollectorMuzzleVFX.Stop();
                this.CollectorMuzzleVFX.Play();
            },
            /*CollectorVisualHandler.PlayMuzzleEffect end.*/

            /*CollectorVisualHandler.StartHighlight start.*/
            StartHighlight: function (min, max, duration) {
if ( TRACE ) { TRACE( "CollectorVisualHandler#StartHighlight", this ); }

                if (min === void 0) { min = 0.0; }
                if (max === void 0) { max = 1.5; }
                if (duration === void 0) { duration = 0.5; }
                this.StartRimBlink(min, max, duration);
            },
            /*CollectorVisualHandler.StartHighlight end.*/

            /*CollectorVisualHandler.StopHighlight start.*/
            StopHighlight: function () {
if ( TRACE ) { TRACE( "CollectorVisualHandler#StopHighlight", this ); }

                // Stop Tween
                this.rimTween != null ? DG.Tweening.TweenExtensions.Kill(this.rimTween) : null;
                this.rimTween = null;

                // Turn off rim
                this.SetFloat("_RimAmount", 0);
                this.SetFloat("_Rim", 0);
                for (var i = 0; i < this.GunnerRenderers.Count; i = (i + 1) | 0) {
                    var renderer = this.GunnerRenderers.getItem(i);
                    if (UnityEngine.Component.op_Inequality(renderer, null) && renderer.sharedMaterial != null) {
                        renderer.sharedMaterial.DisableKeyword("RIM");
                    }
                }
            },
            /*CollectorVisualHandler.StopHighlight end.*/

            /*CollectorVisualHandler.StartRimBlink start.*/
            StartRimBlink: function (min, max, duration) {
if ( TRACE ) { TRACE( "CollectorVisualHandler#StartRimBlink", this ); }

                if (min === void 0) { min = 0.0; }
                if (max === void 0) { max = 1.5; }
                if (duration === void 0) { duration = 0.5; }
                for (var i = 0; i < this.GunnerRenderers.Count; i = (i + 1) | 0) {
                    var renderer = this.GunnerRenderers.getItem(i);
                    if (UnityEngine.Component.op_Inequality(renderer, null) && renderer.sharedMaterial != null) {
                        renderer.sharedMaterial.EnableKeyword("RIM");
                        this.SetFloat("_Rim", 1);
                    }
                }

                // Kill old tween if exists
                this.rimTween != null ? DG.Tweening.TweenExtensions.Kill(this.rimTween) : null;

                var current = min;
                this.rimTween = DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), DG.Tweening.DOTween.To$4(function () {
                    return current;
                }, Bridge.fn.bind(this, function (x) {
                    current = x;
                    this.SetFloat("_RimAmount", current);
                }), max, duration), -1, DG.Tweening.LoopType.Yoyo), DG.Tweening.Ease.InOutQuad);
            },
            /*CollectorVisualHandler.StartRimBlink end.*/

            /*CollectorVisualHandler.SetFloat start.*/
            SetFloat: function (prop, value) {
if ( TRACE ) { TRACE( "CollectorVisualHandler#SetFloat", this ); }

                this.block.SetFloat$1(prop, value);
                for (var i = 0; i < this.GunnerRenderers.Count; i = (i + 1) | 0) {
                    var _render = this.GunnerRenderers.getItem(i);
                    if (UnityEngine.Component.op_Inequality(_render, null)) {
                        _render.SetPropertyBlock(this.block);
                    }
                }
            },
            /*CollectorVisualHandler.SetFloat end.*/

            /*CollectorVisualHandler.StartTrailHighSpeed start.*/
            StartTrailHighSpeed: function () {
if ( TRACE ) { TRACE( "CollectorVisualHandler#StartTrailHighSpeed", this ); }

                this.HighSpeedTrail.Play();
            },
            /*CollectorVisualHandler.StartTrailHighSpeed end.*/

            /*CollectorVisualHandler.StopTrailHighSpeed start.*/
            StopTrailHighSpeed: function () {
if ( TRACE ) { TRACE( "CollectorVisualHandler#StopTrailHighSpeed", this ); }

                this.HighSpeedTrail.Stop();
            },
            /*CollectorVisualHandler.StopTrailHighSpeed end.*/

            /*CollectorVisualHandler.SetVisisble start.*/
            SetVisisble: function (visible) {
if ( TRACE ) { TRACE( "CollectorVisualHandler#SetVisisble", this ); }

                if (UnityEngine.Component.op_Inequality((UnityEngine.MonoBehaviour.op_Inequality(this.Animator, null) ? this.Animator.RabbitAnimator : null), null)) {
                    this.Animator.RabbitAnimator.enabled = visible;
                }

                for (var i = 0; i < this.GunnerRenderers.Count; i = (i + 1) | 0) {
                    var renderer = this.GunnerRenderers.getItem(i);
                    if (UnityEngine.Component.op_Inequality(renderer, null)) {
                        renderer.enabled = visible;
                    }
                }
            },
            /*CollectorVisualHandler.SetVisisble end.*/


        }
    });
    /*CollectorVisualHandler end.*/

    /*ColorPalleteData start.*/
    Bridge.define("ColorPalleteData", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            colorPallete: null,
            ColorKeys: null,
            ColorsValues: null,
            MatValues: null,
            MatPallete: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "ColorPalleteData#init", this ); }

                this.colorPallete = new (System.Collections.Generic.Dictionary$2(System.String,UnityEngine.Color)).$ctor3(System.StringComparer.OrdinalIgnoreCase);
                this.ColorKeys = new (System.Collections.Generic.List$1(System.String)).ctor();
                this.ColorsValues = new (System.Collections.Generic.List$1(UnityEngine.Color)).ctor();
                this.MatValues = new (System.Collections.Generic.List$1(UnityEngine.Material)).ctor();
                this.MatPallete = new (System.Collections.Generic.Dictionary$2(System.String,UnityEngine.Material)).$ctor3(System.StringComparer.OrdinalIgnoreCase);
            }
        },
        methods: {
            /*ColorPalleteData.GetColorByCode start.*/
            GetColorByCode: function (code) {
if ( TRACE ) { TRACE( "ColorPalleteData#GetColorByCode", this ); }

                code = System.String.isNullOrEmpty(code) ? code : code.trim();
                var colorByCode = { v : new UnityEngine.Color() };
                if (!System.String.isNullOrEmpty(code) && this.colorPallete.tryGetValue(code, colorByCode)) {
                    return colorByCode.v.$clone();
                }

                UnityEngine.Debug.LogWarning$1(System.String.format("Color not found: {0}", [code]));
                return new pc.Color( 1, 1, 1, 1 );
            },
            /*ColorPalleteData.GetColorByCode end.*/

            /*ColorPalleteData.GetMaterialByCode start.*/
            GetMaterialByCode: function (code) {
if ( TRACE ) { TRACE( "ColorPalleteData#GetMaterialByCode", this ); }

                code = System.String.isNullOrEmpty(code) ? code : code.trim();
                var materialByCode = { };
                if (!System.String.isNullOrEmpty(code) && this.MatPallete.tryGetValue(code, materialByCode)) {
                    return materialByCode.v;
                }

                UnityEngine.Debug.LogWarning$1(System.String.format("Material not found for code: {0}", [code]));
                return null;
            },
            /*ColorPalleteData.GetMaterialByCode end.*/

            /*ColorPalleteData.FindKeyByColor start.*/
            FindKeyByColor: function (colorToFind) {
if ( TRACE ) { TRACE( "ColorPalleteData#FindKeyByColor", this ); }

                for (var i = 0; i < this.ColorsValues.Count; i = (i + 1) | 0) {
                    if (pc.Color.equals( this.ColorsValues.getItem(i), colorToFind )) {
                        return this.ColorKeys.getItem(i);
                    }
                }
                return null;
            },
            /*ColorPalleteData.FindKeyByColor end.*/

            /*ColorPalleteData.SetupColor start.*/
            SetupColor: function () {
if ( TRACE ) { TRACE( "ColorPalleteData#SetupColor", this ); }

                this.colorPallete.clear();
                for (var i = 0; i < UnityEngine.Mathf.Min(this.ColorKeys.Count, this.ColorsValues.Count); i = (i + 1) | 0) {
                    if (!System.String.isNullOrEmpty(this.ColorKeys.getItem(i))) {
                        this.colorPallete.setItem(this.ColorKeys.getItem(i).trim(), this.ColorsValues.getItem(i).$clone());
                    }
                }
                UnityEngine.Debug.Log$1(System.String.format("{0} colors added to the palette.", [Bridge.box(this.colorPallete.Count, System.Int32)]));
            },
            /*ColorPalleteData.SetupColor end.*/

            /*ColorPalleteData.SetupMaterials start.*/
            SetupMaterials: function () {
if ( TRACE ) { TRACE( "ColorPalleteData#SetupMaterials", this ); }

                this.MatPallete.clear();
                for (var i = 0; i < UnityEngine.Mathf.Min(this.ColorKeys.Count, this.MatValues.Count); i = (i + 1) | 0) {
                    if (!System.String.isNullOrEmpty(this.ColorKeys.getItem(i)) && this.MatValues.getItem(i) != null) {
                        this.MatPallete.setItem(this.ColorKeys.getItem(i).trim(), this.MatValues.getItem(i));
                    }
                }
                UnityEngine.Debug.Log$1(System.String.format("{0} materials added to the palette dictionary.", [Bridge.box(this.MatPallete.Count, System.Int32)]));
            },
            /*ColorPalleteData.SetupMaterials end.*/

            /*ColorPalleteData.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "ColorPalleteData#OnValidate", this ); }

                // m bo c hai dictionary lun c ng b khi c thay i trong Inspector
                this.SetupColor();
                this.SetupMaterials();
            },
            /*ColorPalleteData.OnValidate end.*/

            /*ColorPalleteData.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "ColorPalleteData#OnEnable", this ); }

                // Khi asset c load, m bo cc dictionary c khi to
                if (this.colorPallete == null || this.colorPallete.Count === 0) {
                    this.SetupColor();
                }
                if (this.MatPallete == null || this.MatPallete.Count === 0) {
                    this.SetupMaterials();
                }
            },
            /*ColorPalleteData.OnEnable end.*/


        }
    });
    /*ColorPalleteData end.*/

    /*ColorPixelsCollectorObject+State start.*/
    Bridge.define("ColorPixelsCollectorObject.State", {
        $kind: 1006,
        statics: {
            fields: {
                Normal: 0,
                AbsoluteWin: 1
            }
        }
    });
    /*ColorPixelsCollectorObject+State end.*/

    /*ColumnOfCollectorConfig start.*/
    Bridge.define("ColumnOfCollectorConfig", {
        fields: {
            Collectors: null,
            Locks: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "ColumnOfCollectorConfig#ctor", this ); }

                this.$initialize();
                this.Collectors = new (System.Collections.Generic.List$1(SingleColorCollectorConfig)).ctor();
                this.Locks = new (System.Collections.Generic.List$1(LockObjectConfig)).ctor();
            },
            $ctor1: function (_stock) {
if ( TRACE ) { TRACE( "ColumnOfCollectorConfig#$ctor1", this ); }

                var $t, $t1;
                this.$initialize();
                this.Collectors = new (System.Collections.Generic.List$1(SingleColorCollectorConfig)).ctor();
                $t = Bridge.getEnumerator(_stock.Collectors);
                try {
                    while ($t.moveNext()) {
                        var c = $t.Current;
                        this.Collectors.add(new SingleColorCollectorConfig.$ctor1(c));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                this.Locks = new (System.Collections.Generic.List$1(LockObjectConfig)).ctor();
                $t1 = Bridge.getEnumerator(_stock.Locks);
                try {
                    while ($t1.moveNext()) {
                        var l = $t1.Current;
                        var newLock = new LockObjectConfig();
                        newLock.ID = l.ID;
                        newLock.Row = l.Row;
                        this.Locks.add(newLock);
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }
            }
        }
    });
    /*ColumnOfCollectorConfig end.*/

    /*CombinesCollector start.*/
    Bridge.define("CombinesCollector", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            LevelCollectorsSetup: null,
            CombineIndexOne: 0,
            CombineIndexTwo: 0,
            Gunner0ne: null,
            GunnerTwo: null
        },
        methods: {
            /*CombinesCollector.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "CombinesCollector#OnValidate", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.LevelCollectorsSetup, null)) {
                    return;
                }
                if (this.LevelCollectorsSetup.previewSystem.CurrentCollectors.Count <= 0) {
                    return;
                }
                if (this.CombineIndexOne < 0 || this.CombineIndexOne >= this.LevelCollectorsSetup.previewSystem.CurrentCollectors.Count) {
                    return;
                }
                if (this.CombineIndexTwo < 0 || this.CombineIndexTwo >= this.LevelCollectorsSetup.previewSystem.CurrentCollectors.Count) {
                    return;
                }
                this.Gunner0ne = this.LevelCollectorsSetup.previewSystem.CurrentCollectors.getItem(this.CombineIndexOne);
                this.GunnerTwo = this.LevelCollectorsSetup.previewSystem.CurrentCollectors.getItem(this.CombineIndexTwo);
            },
            /*CombinesCollector.OnValidate end.*/

            /*CombinesCollector.Combine start.*/
            Combine: function () {
if ( TRACE ) { TRACE( "CombinesCollector#Combine", this ); }

                var $t;
                if (UnityEngine.MonoBehaviour.op_Equality(this.Gunner0ne, null) || UnityEngine.MonoBehaviour.op_Equality(this.GunnerTwo, null)) {
                    return;
                }
                if (!Bridge.referenceEquals(this.Gunner0ne.CollectorColor, this.GunnerTwo.CollectorColor)) {
                    return;
                }

                ($t = this.GunnerTwo).BulletCapacity = ($t.BulletCapacity + this.Gunner0ne.BulletCapacity) | 0;

                this.Gunner0ne.VisualHandler.RefreshColor();
                this.GunnerTwo.VisualHandler.RefreshColor();

                this.LevelCollectorsSetup.ImportCollectorsFromScene();

                this.LevelCollectorsSetup.Save();
            },
            /*CombinesCollector.Combine end.*/

            /*CombinesCollector.Combine$1 start.*/
            Combine$1: function (first, second) {
if ( TRACE ) { TRACE( "CombinesCollector#Combine$1", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(first, null) || UnityEngine.MonoBehaviour.op_Equality(second, null)) {
                    return;
                }
                if (!Bridge.referenceEquals(first.CollectorColor, second.CollectorColor)) {
                    return;
                }

                second.BulletCapacity = (second.BulletCapacity + first.BulletCapacity) | 0;

                this.LevelCollectorsSetup.previewSystem.RemoveCollector(first);
                this.LevelCollectorsSetup.ImportCollectorsFromScene();
                this.LevelCollectorsSetup.BakeCollectorsPositionInTool();

                this.LevelCollectorsSetup.Save();
            },
            /*CombinesCollector.Combine$1 end.*/


        },
        overloads: {
            "Combine(ColorPixelsCollectorObject, ColorPixelsCollectorObject)": "Combine$1"
        }
    });
    /*CombinesCollector end.*/

    /*ConnectCollectors start.*/
    Bridge.define("ConnectCollectors", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            LevelCollectorsSetup: null,
            ConnectIndexOne: 0,
            ConnectIndexTwo: 0,
            Gunner0ne: null,
            GunnerTwo: null
        },
        methods: {
            /*ConnectCollectors.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "ConnectCollectors#OnValidate", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.LevelCollectorsSetup, null)) {
                    return;
                }
                if (this.LevelCollectorsSetup.previewSystem.CurrentCollectors.Count <= 0) {
                    return;
                }
                if (this.ConnectIndexOne < 0 || this.ConnectIndexOne >= this.LevelCollectorsSetup.previewSystem.CurrentCollectors.Count) {
                    return;
                }
                if (this.ConnectIndexTwo < 0 || this.ConnectIndexTwo >= this.LevelCollectorsSetup.previewSystem.CurrentCollectors.Count) {
                    return;
                }
                this.Gunner0ne = this.LevelCollectorsSetup.previewSystem.CurrentCollectors.getItem(this.ConnectIndexOne);
                this.GunnerTwo = this.LevelCollectorsSetup.previewSystem.CurrentCollectors.getItem(this.ConnectIndexTwo);
            },
            /*ConnectCollectors.OnValidate end.*/

            /*ConnectCollectors.Connect start.*/
            Connect: function () {
if ( TRACE ) { TRACE( "ConnectCollectors#Connect", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.Gunner0ne, null) || UnityEngine.MonoBehaviour.op_Equality(this.GunnerTwo, null)) {
                    return;
                }

                if (this.Gunner0ne.ID === this.GunnerTwo.ID) {
                    return;
                }

                if (!this.Gunner0ne.ConnectedCollectorsIDs.contains(this.GunnerTwo.ID)) {
                    this.Gunner0ne.ConnectedCollectorsIDs.add(this.GunnerTwo.ID);
                }
                if (!this.GunnerTwo.ConnectedCollectorsIDs.contains(this.Gunner0ne.ID)) {
                    this.GunnerTwo.ConnectedCollectorsIDs.add(this.Gunner0ne.ID);
                }

                this.Gunner0ne.VisualHandler.RefreshColor();
                this.GunnerTwo.VisualHandler.RefreshColor();

                this.LevelCollectorsSetup.ImportCollectorsFromScene();
                this.LevelCollectorsSetup.EnsureBidirectionalConnections();
                this.LevelCollectorsSetup.previewSystem.SetupConnectedCollectors();
            },
            /*ConnectCollectors.Connect end.*/

            /*ConnectCollectors.Connect$1 start.*/
            Connect$1: function (first, second) {
if ( TRACE ) { TRACE( "ConnectCollectors#Connect$1", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(first, null) || UnityEngine.MonoBehaviour.op_Equality(second, null)) {
                    return;
                }

                if (first.ID === second.ID) {
                    return;
                }

                var alreadyConnected = first.ConnectedCollectorsIDs.contains(second.ID) || second.ConnectedCollectorsIDs.contains(first.ID);

                if (alreadyConnected) {
                    if (first.ConnectedCollectorsIDs.contains(second.ID)) {
                        first.ConnectedCollectorsIDs.remove(second.ID);
                    }
                    if (second.ConnectedCollectorsIDs.contains(first.ID)) {
                        second.ConnectedCollectorsIDs.remove(first.ID);
                    }
                } else {
                    if (!first.ConnectedCollectorsIDs.contains(second.ID)) {
                        first.ConnectedCollectorsIDs.add(second.ID);
                    }
                    if (!second.ConnectedCollectorsIDs.contains(first.ID)) {
                        second.ConnectedCollectorsIDs.add(first.ID);
                    }
                }

                first.VisualHandler.RefreshColor();
                second.VisualHandler.RefreshColor();

                this.LevelCollectorsSetup.ImportCollectorsFromScene();
                this.LevelCollectorsSetup.EnsureBidirectionalConnections();
                this.LevelCollectorsSetup.previewSystem.SetupConnectedCollectors();
            },
            /*ConnectCollectors.Connect$1 end.*/


        },
        overloads: {
            "Connect(ColorPixelsCollectorObject, ColorPixelsCollectorObject)": "Connect$1"
        }
    });
    /*ConnectCollectors end.*/

    /*CullableObject start.*/
    Bridge.define("CullableObject", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            targetRenderers: null,
            checkInterval: 0,
            maxDistance: 0,
            showDebug: false,
            cam: null,
            isVisible: false,
            originalStates: null,
            timer: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "CullableObject#init", this ); }

                this.checkInterval = 0.5;
                this.maxDistance = 100.0;
                this.showDebug = false;
                this.isVisible = true;
                this.timer = 0.0;
            }
        },
        methods: {
            /*CullableObject.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "CullableObject#Start", this ); }

                // T ng ly renderer
                if (this.targetRenderers == null || this.targetRenderers.length === 0) {
                    this.targetRenderers = this.GetComponentsInChildren$1(UnityEngine.Renderer, true);
                }

                if (this.targetRenderers.length === 0) {
                    UnityEngine.Debug.LogWarning$1(System.String.format("{0}: Kh\u00f4ng t\u00ecm th\u1ea5y Renderer!", [this.name]));
                    this.enabled = false;
                    return;
                }

                // Lu trng thi ban u
                this.originalStates = System.Array.init(this.targetRenderers.length, false, System.Boolean);
                for (var i = 0; i < this.targetRenderers.length; i = (i + 1) | 0) {
                    if (UnityEngine.Component.op_Inequality(this.targetRenderers[i], null)) {
                        this.originalStates[i] = this.targetRenderers[i].enabled;
                    }
                }

                this.cam = UnityEngine.Camera.main;
                if (UnityEngine.Component.op_Equality(this.cam, null)) {
                    UnityEngine.Debug.LogWarning$1(System.String.format("{0}: Kh\u00f4ng t\u00ecm th\u1ea5y Camera!", [this.name]));
                    this.enabled = false;
                }

                if (this.showDebug) {
                    UnityEngine.Debug.Log$1(System.String.format("{0}: Kh\u1edfi t\u1ea1o v\u1edbi {1} renderer(s)", this.name, Bridge.box(this.targetRenderers.length, System.Int32)));
                }
            },
            /*CullableObject.Start end.*/

            /*CullableObject.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "CullableObject#Update", this ); }

                if (UnityEngine.Component.op_Equality(this.cam, null)) {
                    return;
                }

                this.timer += UnityEngine.Time.deltaTime;
                if (this.timer >= this.checkInterval) {
                    this.timer = 0.0;

                    var shouldVisible = this.CheckVisibility();

                    if (shouldVisible !== this.isVisible) {
                        this.isVisible = shouldVisible;
                        this.SetRenderers(this.isVisible);

                        if (this.showDebug) {
                            UnityEngine.Debug.Log$1(System.String.format("{0}: {1}", this.name, (this.isVisible ? "VISIBLE" : "INVISIBLE")));
                        }
                    }
                }
            },
            /*CullableObject.Update end.*/

            /*CullableObject.CheckVisibility start.*/
            CheckVisibility: function () {
if ( TRACE ) { TRACE( "CullableObject#CheckVisibility", this ); }

                var $t;
                var camPos = this.cam.transform.position.$clone();

                // Kim tra khong cch
                var dist = pc.Vec3.distance( this.transform.position, camPos );
                if (dist > this.maxDistance) {
                    return false;
                }

                // Kim tra tng renderer
                $t = Bridge.getEnumerator(this.targetRenderers);
                try {
                    while ($t.moveNext()) {
                        var r = $t.Current;
                        if (UnityEngine.Component.op_Equality(r, null)) {
                            continue;
                        }

                        // Chuyn bounds center sang viewport space
                        var viewportPoint = this.cam.WorldToViewportPoint(r.bounds.center);

                        // Kim tra c trong viewport khng (x: 0-1, y: 0-1, z: > 0)
                        if (viewportPoint.z > 0 && viewportPoint.x >= -0.1 && viewportPoint.x <= 1.1 && viewportPoint.y >= -0.1 && viewportPoint.y <= 1.1) {
                            // Thm buffer 0.1  trnh flickering  edge
                            return true;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                return false;
            },
            /*CullableObject.CheckVisibility end.*/

            /*CullableObject.SetRenderers start.*/
            SetRenderers: function (enable) {
if ( TRACE ) { TRACE( "CullableObject#SetRenderers", this ); }

                for (var i = 0; i < this.targetRenderers.length; i = (i + 1) | 0) {
                    if (UnityEngine.Component.op_Inequality(this.targetRenderers[i], null)) {
                        this.targetRenderers[i].enabled = enable ? this.originalStates[i] : false;
                    }
                }
            },
            /*CullableObject.SetRenderers end.*/

            /*CullableObject.OnBecameVisible start.*/
            OnBecameVisible: function () {
if ( TRACE ) { TRACE( "CullableObject#OnBecameVisible", this ); }

                if (!this.isVisible) {
                    this.isVisible = true;
                    this.SetRenderers(true);
                    if (this.showDebug) {
                        UnityEngine.Debug.Log$1(System.String.format("{0}: OnBecameVisible", [this.name]));
                    }
                }
            },
            /*CullableObject.OnBecameVisible end.*/

            /*CullableObject.OnBecameInvisible start.*/
            OnBecameInvisible: function () {
if ( TRACE ) { TRACE( "CullableObject#OnBecameInvisible", this ); }

                if (this.isVisible) {
                    this.isVisible = false;
                    this.SetRenderers(false);
                    if (this.showDebug) {
                        UnityEngine.Debug.Log$1(System.String.format("{0}: OnBecameInvisible", [this.name]));
                    }
                }
            },
            /*CullableObject.OnBecameInvisible end.*/

            /*CullableObject.ForceEnable start.*/
            ForceEnable: function () {
if ( TRACE ) { TRACE( "CullableObject#ForceEnable", this ); }

                this.isVisible = true;
                this.SetRenderers(true);
            },
            /*CullableObject.ForceEnable end.*/

            /*CullableObject.ForceDisable start.*/
            ForceDisable: function () {
if ( TRACE ) { TRACE( "CullableObject#ForceDisable", this ); }

                this.isVisible = false;
                this.SetRenderers(false);
            },
            /*CullableObject.ForceDisable end.*/

            /*CullableObject.IsVisible start.*/
            IsVisible: function () {
if ( TRACE ) { TRACE( "CullableObject#IsVisible", this ); }

                return this.isVisible;
            },
            /*CullableObject.IsVisible end.*/

            /*CullableObject.SetMaxDistance start.*/
            SetMaxDistance: function (distance) {
if ( TRACE ) { TRACE( "CullableObject#SetMaxDistance", this ); }

                this.maxDistance = distance;
            },
            /*CullableObject.SetMaxDistance end.*/

            /*CullableObject.OnDrawGizmosSelected start.*/
            OnDrawGizmosSelected: function () {
if ( TRACE ) { TRACE( "CullableObject#OnDrawGizmosSelected", this ); }

                if (UnityEngine.Component.op_Equality(this.cam, null)) {
                    this.cam = UnityEngine.Camera.main;
                }
                if (UnityEngine.Component.op_Equality(this.cam, null)) {
                    return;
                }

                pc.generateStubProxy( 'UnityEngine.Gizmos', true ).color = this.isVisible ? new pc.Color( 0, 1, 0, 1 ) : new pc.Color( 1, 0, 0, 1 );
                pc.stubProxy.reportMethod( 'UnityEngine.Gizmos.DrawWireSphere', null );

                pc.generateStubProxy( 'UnityEngine.Gizmos', true ).color = new pc.Color( 1, 1, 0, 1 );
                pc.stubProxy.reportMethod( 'UnityEngine.Gizmos.DrawLine', null );
            },
            /*CullableObject.OnDrawGizmosSelected end.*/


        }
    });
    /*CullableObject end.*/

    /*DG.Tweening.DOTweenCYInstruction start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction");
    /*DG.Tweening.DOTweenCYInstruction end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForCompletion", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForCompletion#keepWaiting#get", this ); }

                    return this.t.active && !DG.Tweening.TweenExtensions.IsComplete(this.t);
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForCompletion#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null,
            elapsedLoops: 0
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#keepWaiting#get", this ); }

                    return this.t.active && DG.Tweening.TweenExtensions.CompletedLoops(this.t) < this.elapsedLoops;
                }
            }
        },
        ctors: {
            ctor: function (tween, elapsedLoops) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
                this.elapsedLoops = elapsedLoops;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForKill start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForKill", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForKill#keepWaiting#get", this ); }

                    return this.t.active;
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForKill#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForKill end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForPosition", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null,
            position: 0
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForPosition#keepWaiting#get", this ); }

                    return this.t.active && this.t.position * (((DG.Tweening.TweenExtensions.CompletedLoops(this.t) + 1) | 0)) < this.position;
                }
            }
        },
        ctors: {
            ctor: function (tween, position) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForPosition#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
                this.position = position;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForRewind", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForRewind#keepWaiting#get", this ); }

                    return this.t.active && (!this.t.playedOnce || this.t.position * (((DG.Tweening.TweenExtensions.CompletedLoops(this.t) + 1) | 0)) > 0);
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForRewind#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForStart start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForStart", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForStart#keepWaiting#get", this ); }

                    return this.t.active && !this.t.playedOnce;
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForStart#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForStart end.*/

    /*DG.Tweening.DOTweenModuleAudio start.*/
    Bridge.define("DG.Tweening.DOTweenModuleAudio", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleAudio.DOFade:static start.*/
                /**
                 * Tweens an AudioSource's volume to the given value.
                 Also stores the AudioSource as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.AudioSource}           target      
                 * @param   {number}                            endValue    The end value to reach (0 to 1)
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOFade", this ); }

                    if (endValue < 0) {
                        endValue = 0;
                    } else {
                        if (endValue > 1) {
                            endValue = 1;
                        }
                    }
                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.volume;
                    }, function (x) {
                        target.volume = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleAudio.DOFade:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPitch:static start.*/
                /**
                 * Tweens an AudioSource's pitch to the given value.
                 Also stores the AudioSource as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.AudioSource}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPitch: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPitch", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.pitch;
                    }, function (x) {
                        target.pitch = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPitch:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOSetFloat:static start.*/
                /**
                 * Tweens an AudioMixer's exposed float to the given value.
                 Also stores the AudioMixer as the tween's target so it can be used for filtered operations.
                 Note that you need to manually expose a float in an AudioMixerGroup in order to be able to tween it from an AudioMixer.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}      target       
                 * @param   {string}                            floatName    Name given to the exposed float to set
                 * @param   {number}                            endValue     The end value to reach
                 * @param   {number}                            duration     The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOSetFloat: function (target, floatName, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOSetFloat", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        var currVal = { };
                        target.GetFloat(floatName, currVal);
                        return currVal.v;
                    }, function (x) {
                        target.SetFloat(floatName, x);
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleAudio.DOSetFloat:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOComplete:static start.*/
                /**
                 * Completes all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens completed
                 (meaning the tweens that don't have infinite loops and were not already complete)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target           
                 * @param   {boolean}                         withCallbacks    For Sequences only: if TRUE also internal Sequence callbacks will be fired,
                 otherwise they will be ignored
                 * @return  {number}
                 */
                DOComplete: function (target, withCallbacks) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOComplete", this ); }

                    if (withCallbacks === void 0) { withCallbacks = false; }
                    return DG.Tweening.DOTween.Complete(target, withCallbacks);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOComplete:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOKill:static start.*/
                /**
                 * Kills all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens killed.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target      
                 * @param   {boolean}                         complete    If TRUE completes the tween before killing it
                 * @return  {number}
                 */
                DOKill: function (target, complete) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOKill", this ); }

                    if (complete === void 0) { complete = false; }
                    return DG.Tweening.DOTween.Kill(target, complete);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOKill:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOFlip:static start.*/
                /**
                 * Flips the direction (backwards if it was going forward or viceversa) of all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens flipped.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOFlip: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOFlip", this ); }

                    return DG.Tweening.DOTween.Flip(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOFlip:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOGoto:static start.*/
                /**
                 * Sends to the given position all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens involved.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target     
                 * @param   {number}                          to         Time position to reach
                 (if higher than the whole tween duration the tween will simply reach its end)
                 * @param   {boolean}                         andPlay    If TRUE will play the tween after reaching the given position, otherwise it will pause it
                 * @return  {number}
                 */
                DOGoto: function (target, to, andPlay) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOGoto", this ); }

                    if (andPlay === void 0) { andPlay = false; }
                    return DG.Tweening.DOTween.Goto(target, to, andPlay);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOGoto:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPause:static start.*/
                /**
                 * Pauses all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens paused.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOPause: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPause", this ); }

                    return DG.Tweening.DOTween.Pause(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPause:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPlay:static start.*/
                /**
                 * Plays all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens played.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOPlay: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPlay", this ); }

                    return DG.Tweening.DOTween.Play(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPlay:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPlayBackwards:static start.*/
                /**
                 * Plays backwards all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens played.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOPlayBackwards: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPlayBackwards", this ); }

                    return DG.Tweening.DOTween.PlayBackwards(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPlayBackwards:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPlayForward:static start.*/
                /**
                 * Plays forward all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens played.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOPlayForward: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPlayForward", this ); }

                    return DG.Tweening.DOTween.PlayForward(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPlayForward:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DORestart:static start.*/
                /**
                 * Restarts all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens restarted.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DORestart: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DORestart", this ); }

                    return DG.Tweening.DOTween.Restart(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DORestart:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DORewind:static start.*/
                /**
                 * Rewinds all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens rewinded.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DORewind: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DORewind", this ); }

                    return DG.Tweening.DOTween.Rewind(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DORewind:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOSmoothRewind:static start.*/
                /**
                 * Smoothly rewinds all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens rewinded.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOSmoothRewind: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOSmoothRewind", this ); }

                    return DG.Tweening.DOTween.SmoothRewind(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOSmoothRewind:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOTogglePause:static start.*/
                /**
                 * Toggles the paused state (plays if it was paused, pauses if it was playing) of all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens involved.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOTogglePause: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOTogglePause", this ); }

                    return DG.Tweening.DOTween.TogglePause(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOTogglePause:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleAudio end.*/

    /*DG.Tweening.DOTweenModulePhysics start.*/
    Bridge.define("DG.Tweening.DOTweenModulePhysics", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModulePhysics.DOMove:static start.*/
                /**
                 * Tweens a Rigidbody's position to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMove: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMove", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$13(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMove:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOMoveX:static start.*/
                /**
                 * Tweens a Rigidbody's X position to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMoveX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( endValue, 0, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMoveX:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOMoveY:static start.*/
                /**
                 * Tweens a Rigidbody's Y position to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMoveY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0, endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMoveY:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOMoveZ:static start.*/
                /**
                 * Tweens a Rigidbody's Z position to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveZ: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMoveZ", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0, 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Z, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMoveZ:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DORotate:static start.*/
                /**
                 * Tweens a Rigidbody's rotation to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {DG.Tweening.RotateMode}            mode        Rotation mode
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DORotate: function (target, endValue, duration, mode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DORotate", this ); }

                    if (mode === void 0) { mode = 0; }
                    var t = DG.Tweening.DOTween.To$9(function () {
                        return target.rotation;
                    }, Bridge.fn.cacheBind(target, target.MoveRotation), endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), t, target);
                    t.plugOptions.rotateMode = mode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DORotate:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOLookAt:static start.*/
                /**
                 * Tweens a Rigidbody's rotation so that it will look towards the given position.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target            
                 * @param   {UnityEngine.Vector3}               towards           The position to look at
                 * @param   {number}                            duration          The duration of the tween
                 * @param   {DG.Tweening.AxisConstraint}        axisConstraint    Eventual axis constraint for the rotation
                 * @param   {?UnityEngine.Vector3}              up                The vector that defines in which direction up is (default: Vector3.up)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOLookAt: function (target, towards, duration, axisConstraint, up) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOLookAt", this ); }

                    if (axisConstraint === void 0) { axisConstraint = 0; }
                    if (up === void 0) { up = null; }
                    var t = DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.DOTween.To$9(function () {
                        return target.rotation;
                    }, Bridge.fn.cacheBind(target, target.MoveRotation), towards.$clone(), duration), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetLookAt);
                    t.plugOptions.axisConstraint = axisConstraint;
                    t.plugOptions.up = (pc.Vec3.equals( up, null )) ? pc.Vec3.UP.clone() : System.Nullable.getValue(up);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOLookAt:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOJump:static start.*/
                /**
                 * Tweens a Rigidbody's position to the given value, while also applying a jump effect along the Y axis.
                 Returns a Sequence instead of a Tweener.
                 Also stores the Rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}    target       
                 * @param   {UnityEngine.Vector3}      endValue     The end value to reach
                 * @param   {number}                   jumpPower    Power of the jump (the max height of the jump is represented by this plus the final Y offset)
                 * @param   {number}                   numJumps     Total number of jumps
                 * @param   {number}                   duration     The duration of the tween
                 * @param   {boolean}                  snapping     If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Sequence}
                 */
                DOJump: function (target, endValue, jumpPower, numJumps, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOJump", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (numJumps < 1) {
                        numJumps = 1;
                    }
                    var startPosY = 0;
                    var offsetY = -1;
                    var offsetYSet = false;
                    var s = DG.Tweening.DOTween.Sequence();
                    var yTween = DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetRelative(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0, jumpPower, 0 ), duration / (Bridge.Int.mul(numJumps, 2))), DG.Tweening.AxisConstraint.Y, snapping), DG.Tweening.Ease.OutQuad)), Bridge.Int.mul(numJumps, 2), DG.Tweening.LoopType.Yoyo), function () {
                        startPosY = target.position.y;
                    });
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( endValue.x, 0, 0 ), duration), DG.Tweening.AxisConstraint.X, snapping), DG.Tweening.Ease.Linear)), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0, 0, endValue.z ), duration), DG.Tweening.AxisConstraint.Z, snapping), DG.Tweening.Ease.Linear)), yTween), target), DG.Tweening.DOTween.defaultEaseType);
                    DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Tween, yTween, function () {
                        if (!offsetYSet) {
                            offsetYSet = true;
                            offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                        }
                        var pos = target.position.$clone();
                        pos.y += DG.Tweening.DOVirtual.EasedValue(0, offsetY, DG.Tweening.TweenExtensions.ElapsedPercentage(yTween), DG.Tweening.Ease.OutQuad);
                        target.MovePosition(pos);
                    });
                    return s;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOJump:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOPath:static start.*/
                /**
                 * Tweens a Rigidbody's position through the given path waypoints, using the chosen path algorithm.
                 Also stores the Rigidbody as the tween's target so it can be used for filtered operations.
                 <p>NOTE: to tween a rigidbody correctly it should be set to kinematic at least while being tweened.</p><p>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
                 If you plan to publish there you should use a regular transform.DOPath.</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target        
                 * @param   {Array.<UnityEngine.Vector3>}       path          The waypoints to go through
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {DG.Tweening.PathType}              pathType      The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)
                 * @param   {DG.Tweening.PathMode}              pathMode      The path mode: 3D, side-scroller 2D, top-down 2D
                 * @param   {number}                            resolution    The resolution of the path (useless in case of Linear paths): higher resolutions make for more detailed curved paths but are more expensive.
                 Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints
                 * @param   {?UnityEngine.Color}                gizmoColor    The color of the path (shown when gizmos are active in the Play panel and the tween is running)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOPath:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOPath$1:static start.*/
                DOPath$1: function (target, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOPath$1", this ); }

                    if (pathMode === void 0) { pathMode = 1; }
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), path, duration), target);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOPath$1:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath:static start.*/
                /**
                 * Tweens a Rigidbody's localPosition through the given path waypoints, using the chosen path algorithm.
                 Also stores the Rigidbody as the tween's target so it can be used for filtered operations
                 <p>NOTE: to tween a rigidbody correctly it should be set to kinematic at least while being tweened.</p><p>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
                 If you plan to publish there you should use a regular transform.DOLocalPath.</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target        
                 * @param   {Array.<UnityEngine.Vector3>}       path          The waypoint to go through
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {DG.Tweening.PathType}              pathType      The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)
                 * @param   {DG.Tweening.PathMode}              pathMode      The path mode: 3D, side-scroller 2D, top-down 2D
                 * @param   {number}                            resolution    The resolution of the path: higher resolutions make for more detailed curved paths but are more expensive.
                 Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints
                 * @param   {?UnityEngine.Color}                gizmoColor    The color of the path (shown when gizmos are active in the Play panel and the tween is running)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOLocalPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOLocalPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var trans = target.transform;
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return trans.localPosition;
                    }, function (x) {
                        target.MovePosition(UnityEngine.Component.op_Equality(trans.parent, null) ? x.$clone() : trans.parent.TransformPoint$1(x));
                    }, new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath$1:static start.*/
                DOLocalPath$1: function (target, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOLocalPath$1", this ); }

                    if (pathMode === void 0) { pathMode = 1; }
                    var trans = target.transform;
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return trans.localPosition;
                    }, function (x) {
                        target.MovePosition(UnityEngine.Component.op_Equality(trans.parent, null) ? x.$clone() : trans.parent.TransformPoint$1(x));
                    }, path, duration), target);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath$1:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModulePhysics end.*/

    /*DG.Tweening.DOTweenModulePhysics2D start.*/
    Bridge.define("DG.Tweening.DOTweenModulePhysics2D", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModulePhysics2D.DOMove:static start.*/
                /**
                 * Tweens a Rigidbody2D's position to the given value.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMove: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOMove", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOMove:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveX:static start.*/
                /**
                 * Tweens a Rigidbody2D's X position to the given value.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOMoveX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec2( endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveX:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveY:static start.*/
                /**
                 * Tweens a Rigidbody2D's Y position to the given value.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOMoveY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec2( 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveY:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DORotate:static start.*/
                /**
                 * Tweens a Rigidbody2D's rotation to the given value.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DORotate: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DORotate", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.rotation;
                    }, Bridge.fn.cacheBind(target, target.MoveRotation), endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DORotate:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOJump:static start.*/
                /**
                 * Tweens a Rigidbody2D's position to the given value, while also applying a jump effect along the Y axis.
                 Returns a Sequence instead of a Tweener.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations.
                 <p>IMPORTANT: a rigidbody2D can't be animated in a jump arc using MovePosition, so the tween will directly set the position</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}    target       
                 * @param   {UnityEngine.Vector2}        endValue     The end value to reach
                 * @param   {number}                     jumpPower    Power of the jump (the max height of the jump is represented by this plus the final Y offset)
                 * @param   {number}                     numJumps     Total number of jumps
                 * @param   {number}                     duration     The duration of the tween
                 * @param   {boolean}                    snapping     If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Sequence}
                 */
                DOJump: function (target, endValue, jumpPower, numJumps, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOJump", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (numJumps < 1) {
                        numJumps = 1;
                    }
                    var startPosY = 0;
                    var offsetY = -1;
                    var offsetYSet = false;
                    var s = DG.Tweening.DOTween.Sequence();
                    var yTween = DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetRelative(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, function (x) {
                        target.position = x.$clone();
                    }, new pc.Vec2( 0, jumpPower ), duration / (Bridge.Int.mul(numJumps, 2))), DG.Tweening.AxisConstraint.Y, snapping), DG.Tweening.Ease.OutQuad)), Bridge.Int.mul(numJumps, 2), DG.Tweening.LoopType.Yoyo), function () {
                        startPosY = target.position.y;
                    });
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, function (x) {
                        target.position = x.$clone();
                    }, new pc.Vec2( endValue.x, 0 ), duration), DG.Tweening.AxisConstraint.X, snapping), DG.Tweening.Ease.Linear)), yTween), target), DG.Tweening.DOTween.defaultEaseType);
                    DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Tween, yTween, function () {
                        if (!offsetYSet) {
                            offsetYSet = true;
                            offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                        }
                        var pos = UnityEngine.Vector3.FromVector2(target.position.$clone());
                        pos.y += DG.Tweening.DOVirtual.EasedValue(0, offsetY, DG.Tweening.TweenExtensions.ElapsedPercentage(yTween), DG.Tweening.Ease.OutQuad);
                        target.MovePosition$1(pos);
                    });
                    return s;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOJump:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOPath:static start.*/
                /**
                 * Tweens a Rigidbody2D's position through the given path waypoints, using the chosen path algorithm.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations.
                 <p>NOTE: to tween a Rigidbody2D correctly it should be set to kinematic at least while being tweened.</p><p>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
                 If you plan to publish there you should use a regular transform.DOPath.</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target        
                 * @param   {Array.<UnityEngine.Vector2>}       path          The waypoints to go through
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {DG.Tweening.PathType}              pathType      The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)
                 * @param   {DG.Tweening.PathMode}              pathMode      The path mode: 3D, side-scroller 2D, top-down 2D
                 * @param   {number}                            resolution    The resolution of the path (useless in case of Linear paths): higher resolutions make for more detailed curved paths but are more expensive.
                 Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints
                 * @param   {?UnityEngine.Color}                gizmoColor    The color of the path (shown when gizmos are active in the Play panel and the tween is running)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var len = path.length;
                    var path3D = System.Array.init(len, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        path3D[i] = UnityEngine.Vector3.FromVector2(path[i].$clone());
                    }
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return UnityEngine.Vector3.FromVector2(target.position);
                    }, function (x) {
                        target.MovePosition$1(x);
                    }, new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path3D, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);

                    t.plugOptions.isRigidbody2D = true;
                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOPath:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOPath$1:static start.*/
                DOPath$1: function (target, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOPath$1", this ); }

                    if (pathMode === void 0) { pathMode = 1; }
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return UnityEngine.Vector3.FromVector2(target.position);
                    }, function (x) {
                        target.MovePosition$1(x);
                    }, path, duration), target);

                    t.plugOptions.isRigidbody2D = true;
                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOPath$1:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOLocalPath:static start.*/
                /**
                 * Tweens a Rigidbody2D's localPosition through the given path waypoints, using the chosen path algorithm.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 <p>NOTE: to tween a Rigidbody2D correctly it should be set to kinematic at least while being tweened.</p><p>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
                 If you plan to publish there you should use a regular transform.DOLocalPath.</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target        
                 * @param   {Array.<UnityEngine.Vector2>}       path          The waypoint to go through
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {DG.Tweening.PathType}              pathType      The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)
                 * @param   {DG.Tweening.PathMode}              pathMode      The path mode: 3D, side-scroller 2D, top-down 2D
                 * @param   {number}                            resolution    The resolution of the path: higher resolutions make for more detailed curved paths but are more expensive.
                 Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints
                 * @param   {?UnityEngine.Color}                gizmoColor    The color of the path (shown when gizmos are active in the Play panel and the tween is running)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOLocalPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOLocalPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var len = path.length;
                    var path3D = System.Array.init(len, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        path3D[i] = UnityEngine.Vector3.FromVector2(path[i].$clone());
                    }
                    var trans = target.transform;
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return trans.localPosition;
                    }, function (x) {
                        target.MovePosition$1(UnityEngine.Component.op_Equality(trans.parent, null) ? x.$clone() : trans.parent.TransformPoint$1(x));
                    }, new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path3D, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);

                    t.plugOptions.isRigidbody2D = true;
                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOLocalPath:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOLocalPath$1:static start.*/
                DOLocalPath$1: function (target, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOLocalPath$1", this ); }

                    if (pathMode === void 0) { pathMode = 1; }
                    var trans = target.transform;
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return trans.localPosition;
                    }, function (x) {
                        target.MovePosition$1(UnityEngine.Component.op_Equality(trans.parent, null) ? x.$clone() : trans.parent.TransformPoint$1(x));
                    }, path, duration), target);

                    t.plugOptions.isRigidbody2D = true;
                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOLocalPath$1:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModulePhysics2D end.*/

    /*DG.Tweening.DOTweenModuleSprite start.*/
    Bridge.define("DG.Tweening.DOTweenModuleSprite", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleSprite.DOColor:static start.*/
                /**
                 * Tweens a SpriteRenderer's color to the given value.
                 Also stores the spriteRenderer as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}        target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOColor", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOColor:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOFade:static start.*/
                /**
                 * Tweens a Material's alpha color to the given value.
                 Also stores the spriteRenderer as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}        target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOFade", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOFade:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOGradientColor:static start.*/
                /**
                 * Tweens a SpriteRenderer's color using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}    target      
                 * @param   {pc.ColorGradient}              gradient    The gradient to use
                 * @param   {number}                        duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.DOTweenModuleSprite.DOColor(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOBlendableColor:static start.*/
                /**
                 * Tweens a SpriteRenderer's color to the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the SpriteRenderer as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}    target      
                 * @param   {UnityEngine.Color}             endValue    The value to tween to
                 * @param   {number}                        duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOBlendableColor", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleSprite.DOBlendableColor:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleSprite end.*/

    /*DG.Tweening.DOTweenModuleUI start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUI", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUI.DOFade:static start.*/
                /**
                 * Tweens a CanvasGroup's alpha color to the given value.
                 Also stores the canvasGroup as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.CanvasGroup}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.alpha;
                    }, function (x) {
                        target.alpha = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$1:static start.*/
                /**
                 * Tweens an Graphic's alpha color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Graphic}            target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$1", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$2:static start.*/
                /**
                 * Tweens an Image's alpha color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}              target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$2", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$2:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$3:static start.*/
                /**
                 * Tweens a Outline's effectColor alpha to the given value.
                 Also stores the Outline as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Outline}            target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$3: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$3", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.effectColor;
                    }, function (x) {
                        target.effectColor = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$3:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$4:static start.*/
                /**
                 * Tweens a Text's alpha color to the given value.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}               target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$4: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$4", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$4:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor:static start.*/
                /**
                 * Tweens an Graphic's color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Graphic}            target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor$1:static start.*/
                /**
                 * Tweens an Image's color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}              target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor$1", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor$2:static start.*/
                /**
                 * Tweens a Outline's effectColor to the given value.
                 Also stores the Outline as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Outline}            target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor$2", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.effectColor;
                    }, function (x) {
                        target.effectColor = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor$2:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor$3:static start.*/
                /**
                 * Tweens a Text's color to the given value.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}               target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$3: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor$3", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor$3:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFillAmount:static start.*/
                /**
                 * Tweens an Image's fillAmount to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}              target      
                 * @param   {number}                            endValue    The end value to reach (0 to 1)
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFillAmount: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFillAmount", this ); }

                    if (endValue > 1) {
                        endValue = 1;
                    } else {
                        if (endValue < 0) {
                            endValue = 0;
                        }
                    }
                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.fillAmount;
                    }, function (x) {
                        target.fillAmount = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFillAmount:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOGradientColor:static start.*/
                /**
                 * Tweens an Image's colors using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}    target      
                 * @param   {pc.ColorGradient}        gradient    The gradient to use
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.DOTweenModuleUI.DOColor$1(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUI.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFlexibleSize:static start.*/
                /**
                 * Tweens an LayoutElement's flexibleWidth/Height to the given value.
                 Also stores the LayoutElement as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.LayoutElement}      target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFlexibleSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFlexibleSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.flexibleWidth, target.flexibleHeight );
                    }, function (x) {
                        target.flexibleWidth = x.x;
                        target.flexibleHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFlexibleSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOMinSize:static start.*/
                /**
                 * Tweens an LayoutElement's minWidth/Height to the given value.
                 Also stores the LayoutElement as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.LayoutElement}      target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMinSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOMinSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.minWidth, target.minHeight );
                    }, function (x) {
                        target.minWidth = x.x;
                        target.minHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOMinSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPreferredSize:static start.*/
                /**
                 * Tweens an LayoutElement's preferredWidth/Height to the given value.
                 Also stores the LayoutElement as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.LayoutElement}      target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPreferredSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPreferredSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.preferredWidth, target.preferredHeight );
                    }, function (x) {
                        target.preferredWidth = x.x;
                        target.preferredHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPreferredSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOScale:static start.*/
                /**
                 * Tweens a Outline's effectDistance to the given value.
                 Also stores the Outline as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Outline}            target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOScale: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOScale", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.effectDistance;
                    }, function (x) {
                        target.effectDistance = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOScale:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosX:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition X to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPosX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPosX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosY:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition Y to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPosY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPosY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3D:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3D: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3D", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$13(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3D:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DX:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D X to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3DX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( endValue, 0, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DY:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D Y to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3DY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( 0, endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DZ:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D Z to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3DZ: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DZ", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( 0, 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Z, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DZ:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorMax:static start.*/
                /**
                 * Tweens a RectTransform's anchorMax to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorMax: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorMax", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchorMax;
                    }, function (x) {
                        target.anchorMax = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorMax:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorMin:static start.*/
                /**
                 * Tweens a RectTransform's anchorMin to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorMin: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorMin", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchorMin;
                    }, function (x) {
                        target.anchorMin = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorMin:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivot:static start.*/
                /**
                 * Tweens a RectTransform's pivot to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPivot: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivot", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivot:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivotX:static start.*/
                /**
                 * Tweens a RectTransform's pivot X to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPivotX: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivotX", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, new pc.Vec2( endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.X), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivotX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivotY:static start.*/
                /**
                 * Tweens a RectTransform's pivot Y to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPivotY: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivotY", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, new pc.Vec2( 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.Y), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivotY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOSizeDelta:static start.*/
                /**
                 * Tweens a RectTransform's sizeDelta to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOSizeDelta: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOSizeDelta", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.sizeDelta;
                    }, function (x) {
                        target.sizeDelta = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOSizeDelta:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPunchAnchorPos:static start.*/
                /**
                 * Punches a RectTransform's anchoredPosition towards the given direction and then back to the starting one
                 as if it was connected to the starting position via an elastic.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}    target        
                 * @param   {UnityEngine.Vector2}          punch         The direction and strength of the punch (added to the RectTransform's current position)
                 * @param   {number}                       duration      The duration of the tween
                 * @param   {number}                       vibrato       Indicates how much will the punch vibrate
                 * @param   {number}                       elasticity    Represents how much (0 to 1) the vector will go beyond the starting position when bouncing backwards.
                 1 creates a full oscillation between the punch direction and the opposite direction,
                 while 0 oscillates only between the punch and the start position
                 * @param   {boolean}                      snapping      If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOPunchAnchorPos: function (target, punch, duration, vibrato, elasticity, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPunchAnchorPos", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (elasticity === void 0) { elasticity = 1.0; }
                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Punch(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, UnityEngine.Vector3.FromVector2(punch.$clone()), duration, vibrato, elasticity), target), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOPunchAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos:static start.*/
                /**
                 * Shakes a RectTransform's anchoredPosition with the given values.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}          target            
                 * @param   {number}                             duration          The duration of the tween
                 * @param   {number}                             strength          The shake strength
                 * @param   {number}                             vibrato           Indicates how much will the shake vibrate
                 * @param   {number}                             randomness        Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware). 
                 Setting it to 0 will shake along a single direction.
                 * @param   {boolean}                            snapping          If TRUE the tween will smoothly snap all values to integers
                 * @param   {boolean}                            fadeOut           If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it will not
                 * @param   {DG.Tweening.ShakeRandomnessMode}    randomnessMode    Randomness mode
                 * @return  {DG.Tweening.Tweener}
                 */
                DOShakeAnchorPos: function (target, duration, strength, vibrato, randomness, snapping, fadeOut, randomnessMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos", this ); }

                    if (strength === void 0) { strength = 100.0; }
                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (snapping === void 0) { snapping = false; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    if (randomnessMode === void 0) { randomnessMode = 0; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Shake(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, duration, strength, vibrato, randomness, true, fadeOut, randomnessMode), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetShake), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos$1:static start.*/
                /**
                 * Shakes a RectTransform's anchoredPosition with the given values.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}          target            
                 * @param   {number}                             duration          The duration of the tween
                 * @param   {UnityEngine.Vector2}                strength          The shake strength on each axis
                 * @param   {number}                             vibrato           Indicates how much will the shake vibrate
                 * @param   {number}                             randomness        Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware). 
                 Setting it to 0 will shake along a single direction.
                 * @param   {boolean}                            snapping          If TRUE the tween will smoothly snap all values to integers
                 * @param   {boolean}                            fadeOut           If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it will not
                 * @param   {DG.Tweening.ShakeRandomnessMode}    randomnessMode    Randomness mode
                 * @return  {DG.Tweening.Tweener}
                 */
                DOShakeAnchorPos$1: function (target, duration, strength, vibrato, randomness, snapping, fadeOut, randomnessMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos$1", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (snapping === void 0) { snapping = false; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    if (randomnessMode === void 0) { randomnessMode = 0; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Shake$1(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, duration, UnityEngine.Vector3.FromVector2(strength.$clone()), vibrato, randomness, fadeOut, randomnessMode), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetShake), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOJumpAnchorPos:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition to the given value, while also applying a jump effect along the Y axis.
                 Returns a Sequence instead of a Tweener.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}    target       
                 * @param   {UnityEngine.Vector2}          endValue     The end value to reach
                 * @param   {number}                       jumpPower    Power of the jump (the max height of the jump is represented by this plus the final Y offset)
                 * @param   {number}                       numJumps     Total number of jumps
                 * @param   {number}                       duration     The duration of the tween
                 * @param   {boolean}                      snapping     If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Sequence}
                 */
                DOJumpAnchorPos: function (target, endValue, jumpPower, numJumps, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOJumpAnchorPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (numJumps < 1) {
                        numJumps = 1;
                    }
                    var startPosY = 0;
                    var offsetY = -1;
                    var offsetYSet = false;

                    // Separate Y Tween so we can elaborate elapsedPercentage on that insted of on the Sequence
                    // (in case users add a delay or other elements to the Sequence)
                    var s = DG.Tweening.DOTween.Sequence();
                    var yTween = DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetRelative(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( 0, jumpPower ), duration / (Bridge.Int.mul(numJumps, 2))), DG.Tweening.AxisConstraint.Y, snapping), DG.Tweening.Ease.OutQuad)), Bridge.Int.mul(numJumps, 2), DG.Tweening.LoopType.Yoyo), function () {
                        startPosY = target.anchoredPosition.y;
                    });
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( endValue.x, 0 ), duration), DG.Tweening.AxisConstraint.X, snapping), DG.Tweening.Ease.Linear)), yTween), target), DG.Tweening.DOTween.defaultEaseType);
                    DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Sequence, s, function () {
                        if (!offsetYSet) {
                            offsetYSet = true;
                            offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                        }
                        var pos = target.anchoredPosition.$clone();
                        pos.y += DG.Tweening.DOVirtual.EasedValue(0, offsetY, DG.Tweening.TweenExtensions.ElapsedDirectionalPercentage(s), DG.Tweening.Ease.OutQuad);
                        target.anchoredPosition = pos.$clone();
                    });
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUI.DOJumpAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DONormalizedPos:static start.*/
                /**
                 * Tweens a ScrollRect's horizontal/verticalNormalizedPosition to the given value.
                 Also stores the ScrollRect as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.ScrollRect}    target      
                 * @param   {UnityEngine.Vector2}          endValue    The end value to reach
                 * @param   {number}                       duration    The duration of the tween
                 * @param   {boolean}                      snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DONormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DONormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.horizontalNormalizedPosition, target.verticalNormalizedPosition );
                    }, function (x) {
                        target.horizontalNormalizedPosition = x.x;
                        target.verticalNormalizedPosition = x.y;
                    }, endValue.$clone(), duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DONormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOHorizontalNormalizedPos:static start.*/
                /**
                 * Tweens a ScrollRect's horizontalNormalizedPosition to the given value.
                 Also stores the ScrollRect as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.ScrollRect}    target      
                 * @param   {number}                       endValue    The end value to reach
                 * @param   {number}                       duration    The duration of the tween
                 * @param   {boolean}                      snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOHorizontalNormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOHorizontalNormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(DG.Tweening.DOTween.To$4(function () {
                        return target.horizontalNormalizedPosition;
                    }, function (x) {
                        target.horizontalNormalizedPosition = x;
                    }, endValue, duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOHorizontalNormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOVerticalNormalizedPos:static start.*/
                /**
                 * Tweens a ScrollRect's verticalNormalizedPosition to the given value.
                 Also stores the ScrollRect as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.ScrollRect}    target      
                 * @param   {number}                       endValue    The end value to reach
                 * @param   {number}                       duration    The duration of the tween
                 * @param   {boolean}                      snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOVerticalNormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOVerticalNormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(DG.Tweening.DOTween.To$4(function () {
                        return target.verticalNormalizedPosition;
                    }, function (x) {
                        target.verticalNormalizedPosition = x;
                    }, endValue, duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOVerticalNormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOValue:static start.*/
                /**
                 * Tweens a Slider's value to the given value.
                 Also stores the Slider as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Slider}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOValue: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOValue", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.value;
                    }, function (x) {
                        target.value = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOValue:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOCounter:static start.*/
                /**
                 * Tweens a Text's text from one integer to another, with options for thousands separators
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}                 target                   
                 * @param   {number}                              fromValue                The value to start from
                 * @param   {number}                              endValue                 The end value to reach
                 * @param   {number}                              duration                 The duration of the tween
                 * @param   {boolean}                             addThousandsSeparator    If TRUE (default) also adds thousands separators
                 * @param   {System.Globalization.CultureInfo}    culture                  The {@link } to use (InvariantCulture if NULL)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOCounter: function (target, fromValue, endValue, duration, addThousandsSeparator, culture) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOCounter", this ); }

                    if (addThousandsSeparator === void 0) { addThousandsSeparator = true; }
                    if (culture === void 0) { culture = null; }
                    var v = fromValue;
                    var cInfo = !addThousandsSeparator ? null : culture || System.Globalization.CultureInfo.invariantCulture;
                    var t = DG.Tweening.DOTween.To$2(function () {
                        return v;
                    }, function (x) {
                        v = x;
                        target.text = addThousandsSeparator ? System.Int32.format(v, "N0", cInfo) : Bridge.toString(v);
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Int32,System.Int32,DG.Tweening.Plugins.Options.NoOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOCounter:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOText:static start.*/
                /**
                 * Tweens a Text's text to the given value.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}               target             
                 * @param   {string}                            endValue           The end string to tween to
                 * @param   {number}                            duration           The duration of the tween
                 * @param   {boolean}                           richTextEnabled    If TRUE (default), rich text will be interpreted correctly while animated,
                 otherwise all tags will be considered as normal text
                 * @param   {DG.Tweening.ScrambleMode}          scrambleMode       The type of scramble mode to use, if any
                 * @param   {string}                            scrambleChars      A string containing the characters to use for scrambling.
                 Use as many characters as possible (minimum 10) because DOTween uses a fast scramble mode which gives better results with more characters.
                 Leave it to NULL (default) to use default ones
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOText: function (target, endValue, duration, richTextEnabled, scrambleMode, scrambleChars) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOText", this ); }

                    if (richTextEnabled === void 0) { richTextEnabled = true; }
                    if (scrambleMode === void 0) { scrambleMode = 0; }
                    if (scrambleChars === void 0) { scrambleChars = null; }
                    if (endValue == null) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogWarning("You can't pass a NULL string to DOText: an empty string will be used instead to avoid errors");
                        }
                        endValue = "";
                    }
                    var t = DG.Tweening.DOTween.To$5(function () {
                        return target.text;
                    }, function (x) {
                        target.text = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$3(t, richTextEnabled, scrambleMode, scrambleChars), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOText:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor:static start.*/
                /**
                 * Tweens a Graphic's color to the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the Graphic as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Graphic}    target      
                 * @param   {UnityEngine.Color}         endValue    The value to tween to
                 * @param   {number}                    duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$1:static start.*/
                /**
                 * Tweens a Image's color to the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the Image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}    target      
                 * @param   {UnityEngine.Color}       endValue    The value to tween to
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor$1", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$2:static start.*/
                /**
                 * Tweens a Text's color BY the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}    target      
                 * @param   {UnityEngine.Color}      endValue    The value to tween to
                 * @param   {number}                 duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor$2", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$2:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOShapeCircle:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition so that it draws a circle around the given center.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations.<p />
                 IMPORTANT: SetFrom(value) requires a {@link } instead of a float, where the X property represents the "from degrees value"
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target             
                 * @param   {UnityEngine.Vector2}               center             Circle-center/pivot around which to rotate (in UI anchoredPosition coordinates)
                 * @param   {number}                            endValueDegrees    The end value degrees to reach (to rotate counter-clockwise pass a negative value)
                 * @param   {number}                            duration           The duration of the tween
                 * @param   {boolean}                           relativeCenter     If TRUE the {@link } coordinates will be considered as relative to the target's current anchoredPosition
                 * @param   {boolean}                           snapping           If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOShapeCircle: function (target, center, endValueDegrees, duration, relativeCenter, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOShapeCircle", this ); }

                    if (relativeCenter === void 0) { relativeCenter = false; }
                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To(UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.CircleOptions, DG.Tweening.Plugins.CirclePlugin.Get(), function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, center.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$7(t, endValueDegrees, relativeCenter, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOShapeCircle:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUI end.*/

    /*DG.Tweening.DOTweenModuleUI+Utils start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUI.Utils", {
        $kind: 1002,
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUI+Utils.SwitchToRectTransform:static start.*/
                /**
                 * Converts the anchoredPosition of the first RectTransform to the second RectTransform,
                 taking into consideration offset, anchors and pivot, and returns the new anchoredPosition
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI.Utils
                 * @memberof DG.Tweening.DOTweenModuleUI.Utils
                 * @param   {UnityEngine.RectTransform}    from    
                 * @param   {UnityEngine.RectTransform}    to
                 * @return  {UnityEngine.Vector2}
                 */
                SwitchToRectTransform: function (from, to) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI.Utils#SwitchToRectTransform", this ); }

                    var localPoint = { v : new UnityEngine.Vector2() };
                    var fromPivotDerivedOffset = new pc.Vec2( from.rect.width * 0.5 + from.rect.xMin, from.rect.height * 0.5 + from.rect.yMin );
                    var screenP = UnityEngine.RectTransformUtility.WorldToScreenPoint(null, from.position);
                    screenP = screenP.$clone().add( fromPivotDerivedOffset.$clone() );
                    UnityEngine.RectTransformUtility.ScreenPointToLocalPointInRectangle(to, screenP, null, localPoint);
                    var pivotDerivedOffset = new pc.Vec2( to.rect.width * 0.5 + to.rect.xMin, to.rect.height * 0.5 + to.rect.yMin );
                    return to.anchoredPosition.$clone().add( localPoint.v ).sub( pivotDerivedOffset );
                },
                /*DG.Tweening.DOTweenModuleUI+Utils.SwitchToRectTransform:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUI+Utils end.*/

    /*DG.Tweening.DOTweenModuleUnityVersion start.*/
    /** @namespace DG.Tweening */

    /**
     * Shortcuts/functions that are not strictly related to specific Modules
     but are available only on some Unity versions
     *
     * @static
     * @abstract
     * @public
     * @class DG.Tweening.DOTweenModuleUnityVersion
     */
    Bridge.define("DG.Tweening.DOTweenModuleUnityVersion", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor:static start.*/
                /**
                 * Tweens a Material's color using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}    target      
                 * @param   {pc.ColorGradient}        gradient    The gradient to use
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.ShortcutExtensions.DOColor$3(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor$1:static start.*/
                /**
                 * Tweens a Material's named color property using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}    target      
                 * @param   {pc.ColorGradient}        gradient    The gradient to use
                 * @param   {string}                  property    The name of the material property to tween (like _Tint or _SpecColor)
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor$1: function (target, gradient, property, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor$1", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.SetColor$1(property, c.color);
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.ShortcutExtensions.DOColor$4(target, c.color.$clone(), property, colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForCompletion:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or complete.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForCompletion(true);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForCompletion: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForCompletion", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForCompletion(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForCompletion:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForRewind:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or rewinded.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForRewind();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForRewind: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForRewind", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForRewind(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForRewind:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForKill:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForKill();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForKill: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForKill", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForKill(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForKill:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForElapsedLoops:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or has gone through the given amount of loops.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForElapsedLoops(2);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {number}                                elapsedLoops                    Elapsed loops to wait for
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForElapsedLoops: function (t, elapsedLoops, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForElapsedLoops", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops(t, elapsedLoops);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForElapsedLoops:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForPosition:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed
                 or has reached the given time position (loops included, delays excluded).
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForPosition(2.5f);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {number}                                position                        Position (loops included, delays excluded) to wait for
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForPosition: function (t, position, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForPosition", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForPosition(t, position);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForPosition:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForStart:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or started
                 (meaning when the tween is set in a playing state the first time, after any eventual delay).
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForStart();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForStart: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForStart", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForStart(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForStart:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOOffset:static start.*/
                /**
                 * Tweens a Material's named texture offset property with the given ID to the given value.
                 Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}              target        
                 * @param   {UnityEngine.Vector2}               endValue      The end value to reach
                 * @param   {number}                            propertyID    The ID of the material property to tween (also called nameID in Unity's manual)
                 * @param   {number}                            duration      The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOOffset: function (target, endValue, propertyID, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOOffset", this ); }

                    if (!target.HasProperty(propertyID)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty(propertyID);
                        }
                        return null;
                    }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.GetTextureOffset(propertyID);
                    }, function (x) {
                        target.SetTextureOffset(propertyID, x);
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOOffset:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOTiling:static start.*/
                /**
                 * Tweens a Material's named texture scale property with the given ID to the given value.
                 Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}              target        
                 * @param   {UnityEngine.Vector2}               endValue      The end value to reach
                 * @param   {number}                            propertyID    The ID of the material property to tween (also called nameID in Unity's manual)
                 * @param   {number}                            duration      The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOTiling: function (target, endValue, propertyID, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOTiling", this ); }

                    if (!target.HasProperty(propertyID)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty(propertyID);
                        }
                        return null;
                    }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.GetTextureScale(propertyID);
                    }, function (x) {
                        target.SetTextureScale(propertyID, x);
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOTiling:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUnityVersion end.*/

    /*DG.Tweening.DOTweenModuleUtils start.*/
    /**
     * Utility functions that deal with available Modules.
     Modules defines:
     - DOTAUDIO
     - DOTPHYSICS
     - DOTPHYSICS2D
     - DOTSPRITE
     - DOTUI
     Extra defines set and used for implementation of external assets:
     - DOTWEEN_TMP  TextMesh Pro
     - DOTWEEN_TK2D  2D Toolkit
     *
     * @static
     * @abstract
     * @public
     * @class DG.Tweening.DOTweenModuleUtils
     */
    Bridge.define("DG.Tweening.DOTweenModuleUtils", {
        statics: {
            fields: {
                _initialized: false
            },
            methods: {
                /*DG.Tweening.DOTweenModuleUtils.Init:static start.*/
                /**
                 * Called via Reflection by DOTweenComponent on Awake
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUtils
                 * @memberof DG.Tweening.DOTweenModuleUtils
                 * @return  {void}
                 */
                Init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils#Init", this ); }

                    if (DG.Tweening.DOTweenModuleUtils._initialized) {
                        return;
                    }

                    DG.Tweening.DOTweenModuleUtils._initialized = true;
                    DG.Tweening.Core.DOTweenExternalCommand.addSetOrientationOnPath(DG.Tweening.DOTweenModuleUtils.Physics.SetOrientationOnPath);

                },
                /*DG.Tweening.DOTweenModuleUtils.Init:static end.*/

                /*DG.Tweening.DOTweenModuleUtils.Preserver:static start.*/
                Preserver: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils#Preserver", this ); }

                    var loadedAssemblies = System.AppDomain.getAssemblies();
                    var mi = Bridge.Reflection.getMembers(UnityEngine.MonoBehaviour, 8, 284, "Stub");
                },
                /*DG.Tweening.DOTweenModuleUtils.Preserver:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUtils end.*/

    /*DG.Tweening.DOTweenModuleUtils+Physics start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUtils.Physics", {
        $kind: 1002,
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUtils+Physics.SetOrientationOnPath:static start.*/
                SetOrientationOnPath: function (options, t, newRot, trans) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#SetOrientationOnPath", this ); }

                    if (options.isRigidbody) {
                        Bridge.cast(t.target, UnityEngine.Rigidbody).rotation = newRot.$clone();
                    } else {
                        trans.rotation = newRot.$clone();
                    }
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.SetOrientationOnPath:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody2D:static start.*/
                HasRigidbody2D: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody2D", this ); }

                    return UnityEngine.Component.op_Inequality(target.GetComponent(UnityEngine.Rigidbody2D), null);
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody2D:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody:static start.*/
                HasRigidbody: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody", this ); }

                    return UnityEngine.Component.op_Inequality(target.GetComponent(UnityEngine.Rigidbody), null);
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.CreateDOTweenPathTween:static start.*/
                CreateDOTweenPathTween: function (target, tweenRigidbody, isLocal, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#CreateDOTweenPathTween", this ); }

                    var t = null;
                    var rBodyFoundAndTweened = false;
                    if (tweenRigidbody) {
                        var rBody = target.GetComponent(UnityEngine.Rigidbody);
                        if (UnityEngine.Component.op_Inequality(rBody, null)) {
                            rBodyFoundAndTweened = true;
                            t = isLocal ? DG.Tweening.DOTweenModulePhysics.DOLocalPath$1(rBody, path, duration, pathMode) : DG.Tweening.DOTweenModulePhysics.DOPath$1(rBody, path, duration, pathMode);
                        }
                    }
                    if (!rBodyFoundAndTweened && tweenRigidbody) {
                        var rBody2D = target.GetComponent(UnityEngine.Rigidbody2D);
                        if (UnityEngine.Component.op_Inequality(rBody2D, null)) {
                            rBodyFoundAndTweened = true;
                            t = isLocal ? DG.Tweening.DOTweenModulePhysics2D.DOLocalPath$1(rBody2D, path, duration, pathMode) : DG.Tweening.DOTweenModulePhysics2D.DOPath$1(rBody2D, path, duration, pathMode);
                        }
                    }
                    if (!rBodyFoundAndTweened) {
                        t = isLocal ? DG.Tweening.ShortcutExtensions.DOLocalPath(target.transform, path, duration, pathMode) : DG.Tweening.ShortcutExtensions.DOPath(target.transform, path, duration, pathMode);
                    }
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.CreateDOTweenPathTween:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUtils+Physics end.*/

    /*EnableRandomRotate start.*/
    Bridge.define("EnableRandomRotate", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            minY: 0,
            maxY: 0,
            Target: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "EnableRandomRotate#init", this ); }

                this.minY = 0.0;
                this.maxY = 360.0;
            }
        },
        methods: {
            /*EnableRandomRotate.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "EnableRandomRotate#OnEnable", this ); }

                this.RandomRotate();
            },
            /*EnableRandomRotate.OnEnable end.*/

            /*EnableRandomRotate.RandomRotate start.*/
            RandomRotate: function () {
if ( TRACE ) { TRACE( "EnableRandomRotate#RandomRotate", this ); }

                var randomY = UnityEngine.Random.Range$1(this.minY, this.maxY);
                var current = this.Target.eulerAngles.$clone();
                this.Target.eulerAngles = new pc.Vec3( current.x, randomY, current.z );
            },
            /*EnableRandomRotate.RandomRotate end.*/


        }
    });
    /*EnableRandomRotate end.*/

    /*GameplayEventsManager start.*/
    Bridge.define("GameplayEventsManager", {
        statics: {
            fields: {
                OnAPixelDestroyed: null,
                OnAPixelDestroyedByCollector: null,
                OnGridObjectChanged: null,
                OnPaintingInitializeDone: null,
                OnCollectAKey: null,
                OnAPipePixelDestroyed: null,
                OnAKeyReadyToBeCollected: null,
                OnSuperRabbitBlockSelected: null,
                OnFreePickACollector: null,
                OnGridPixelsDestroyedPassive: null,
                CompleteColor: null,
                OnClickACollector: null,
                OnUnlockLockObject: null,
                OnCollectorStartMove: null,
                OnACollectorFinishMove: null,
                OnACollectorMoveToQueue: null,
                OnCollectorMoveToConveyor: null,
                OnCollectorRevealed: null,
                OnCollectorsSquadChanged: null,
                OnCollectorMoveToFirstLine: null,
                ForceRemoveCollectorActive: null,
                PauseGame: null,
                OnExecuteBooster: null,
                OnExecuteBoosterNeedToHideUI: null,
                OnEndExecuteBoosterNeedToHideUI: null,
                OnCancelExecuteBooster: null,
                OnBlockDissapear: null,
                OnAbsoluteWin: null,
                OnEndGame: null,
                OnBlockGamePlayInput: null,
                ShowPopupRevive: null,
                GetFirstCollector: null
            },
            methods: {
                /*GameplayEventsManager.InstallFullGame:static start.*/
                InstallFullGame: function () {
if ( TRACE ) { TRACE( "GameplayEventsManager#InstallFullGame", this ); }


                    Luna.Unity.Playable.InstallFullGame();
                    Luna.Unity.LifeCycle.GameEnded();
                },
                /*GameplayEventsManager.InstallFullGame:static end.*/


            }
        }
    });
    /*GameplayEventsManager end.*/

    /*GameplayManager start.*/
    Bridge.define("GameplayManager", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            levelGamePlayConfig: null,
            levelSetup: null,
            levelCollectorsSystem: null,
            currentLevelConfig: null,
            levelId: 0,
            enableStoreLimitForFirstLevel: false
        },
        props: {
            LevelId: {
                get: function () {
if ( TRACE ) { TRACE( "GameplayManager#LevelId#get", this ); }

                    return this.levelId;
                }
            },
            IsStoreLimitForFirstLevelEnabled: {
                get: function () {
if ( TRACE ) { TRACE( "GameplayManager#IsStoreLimitForFirstLevelEnabled#get", this ); }

                    return this.enableStoreLimitForFirstLevel;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "GameplayManager#init", this ); }

                this.levelId = 0;
                this.enableStoreLimitForFirstLevel = false;
            }
        },
        methods: {
            /*GameplayManager.IsFirstLevelAndNotLast start.*/
            IsFirstLevelAndNotLast: function () {
if ( TRACE ) { TRACE( "GameplayManager#IsFirstLevelAndNotLast", this ); }

                if (this.levelGamePlayConfig == null || this.levelGamePlayConfig.levelConfigDataList == null || this.levelGamePlayConfig.levelConfigDataList.Count === 0) {
                    return false;
                }

                return this.levelId === 0 && this.levelGamePlayConfig.levelConfigDataList.Count > 1;
            },
            /*GameplayManager.IsFirstLevelAndNotLast end.*/

            /*GameplayManager.StartGame start.*/
            StartGame: function () {
if ( TRACE ) { TRACE( "GameplayManager#StartGame", this ); }

                this.currentLevelConfig = this.levelGamePlayConfig.GetLevelConfigData(this.levelId);
                this.levelSetup.LoadLevel$1(this.currentLevelConfig);
                GameplayEventsManager.OnEndGame = Bridge.fn.combine(GameplayEventsManager.OnEndGame, Bridge.fn.cacheBind(this, this.OnEndGameAction));
                Luna.Unity.LifeCycle.GameStarted();
            },
            /*GameplayManager.StartGame end.*/

            /*GameplayManager.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "GameplayManager#OnEnable", this ); }

                this.StartGame();
            },
            /*GameplayManager.OnEnable end.*/

            /*GameplayManager.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "GameplayManager#Start", this ); }

                GameplayEventsManager.CompleteColor = Bridge.fn.combine(GameplayEventsManager.CompleteColor, Bridge.fn.cacheBind(this, this.OnCollectorDead));
            },
            /*GameplayManager.Start end.*/

            /*GameplayManager.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "GameplayManager#OnDestroy", this ); }

                GameplayEventsManager.OnEndGame = Bridge.fn.remove(GameplayEventsManager.OnEndGame, Bridge.fn.cacheBind(this, this.OnEndGameAction));
                GameplayEventsManager.CompleteColor = Bridge.fn.remove(GameplayEventsManager.CompleteColor, Bridge.fn.cacheBind(this, this.OnCollectorDead));
            },
            /*GameplayManager.OnDestroy end.*/

            /*GameplayManager.OnEndGameAction start.*/
            OnEndGameAction: function (isWin) {
if ( TRACE ) { TRACE( "GameplayManager#OnEndGameAction", this ); }

                UnityEngine.Debug.Log$1("End Game: " + System.Boolean.toString(isWin));
                // var data = new EndGameLayerData()
                // {
                //     IsWinGame = isWin
                // };
                // LayerManager.Instance.ShowEndgameLayer(data);
            },
            /*GameplayManager.OnEndGameAction end.*/

            /*GameplayManager.OnCollectorDead start.*/
            OnCollectorDead: function (collectors) {
if ( TRACE ) { TRACE( "GameplayManager#OnCollectorDead", this ); }

                var $t;
                ($t = this.levelCollectorsSystem).CurrentTotalCollectors = ($t.CurrentTotalCollectors - 1) | 0;

                // iu kin thng tuyt i (gi nguyn)
                if (this.levelCollectorsSystem.CurrentTotalCollectors <= CollectorGameManager.Instance.moveLimiter.GetMaxActiveMoving()) {
                    !Bridge.staticEquals(GameplayEventsManager.OnAbsoluteWin, null) ? GameplayEventsManager.OnAbsoluteWin() : null;
                }

                // --- LOGIC CHUYN ROUND ---

                // Nu ht collector trong round hin ti
                if (this.levelCollectorsSystem.CurrentTotalCollectors <= 0) {
                    var isLastRound = this.levelId >= ((this.levelGamePlayConfig.levelConfigDataList.Count - 1) | 0);

                    if (isLastRound) {
                        // y l round cui -> End Game
                        UnityEngine.Debug.Log$1("All Collectors Completed FINAL Round, End Game");

                        HelperCoroutine.DelaySeconds(this, 1.0, function () {
                            Singleton$1(UiEndGame).Instance.ShowEndGameWin();
                            Luna.Unity.LifeCycle.GameEnded();
                            Luna.Unity.Playable.InstallFullGame();
                        });
                    } else {
                        // Cha phi round cui -> sang round tip theo
                        this.levelId = (this.levelId + 1) | 0;
                        UnityEngine.Debug.Log$1("Completed Round " + (((this.levelId - 1) | 0)) + " -> Start Round " + this.levelId);

                        // Use the level transition tween to smoothly cover and reveal during level loading
                        Singleton$1(UiEndGame).Instance.StartLevelTransition(Bridge.fn.bind(this, function () {
                            this.StartGame(); // Load round mi
                        }));
                    }
                }
            },
            /*GameplayManager.OnCollectorDead end.*/


        }
    });
    /*GameplayManager end.*/

    /*GamePlaySound start.*/
    Bridge.define("GamePlaySound", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            clickCatSound: null
        },
        methods: {
            /*GamePlaySound.PlayClickCat start.*/
            PlayClickCat: function () {
if ( TRACE ) { TRACE( "GamePlaySound#PlayClickCat", this ); }

                UnityEngine.Component.op_Inequality(this.clickCatSound, null) ? this.clickCatSound.Stop() : null;
                UnityEngine.Component.op_Inequality(this.clickCatSound, null) ? this.clickCatSound.Play() : null;
            },
            /*GamePlaySound.PlayClickCat end.*/


        }
    });
    /*GamePlaySound end.*/

    /*GogoGaga.OptimizedRopesAndCables.Rope start.*/
    Bridge.define("GogoGaga.OptimizedRopesAndCables.Rope", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                StartPointWeight: 0,
                EndPointWeight: 0,
                valueThreshold: 0,
                velocityThreshold: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.Rope#init", this ); }

                    this.StartPointWeight = 1.0;
                    this.EndPointWeight = 1.0;
                    this.valueThreshold = 0.01;
                    this.velocityThreshold = 0.01;
                }
            }
        },
        fields: {
            startPoint: null,
            midPoint: null,
            endPoint: null,
            linePoints: 0,
            stiffness: 0,
            damping: 0,
            ropeLength: 0,
            ropeWidth: 0,
            midPointWeight: 0,
            midPointPosition: 0,
            currentValue: null,
            currentVelocity: null,
            targetValue: null,
            otherPhysicsFactors: null,
            lineRenderer: null,
            isFirstFrame: false,
            prevStartPointPosition: null,
            prevEndPointPosition: null,
            prevMidPointPosition: 0,
            prevMidPointWeight: 0,
            prevLineQuality: 0,
            prevRopeWidth: 0,
            prevstiffness: 0,
            prevDampness: 0,
            prevRopeLength: 0
        },
        events: {
            OnPointsChanged: null
        },
        props: {
            StartPoint: {
                get: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.Rope#StartPoint#get", this ); }

                    return this.startPoint;
                }
            },
            MidPoint: {
                get: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.Rope#MidPoint#get", this ); }

                    return this.midPoint;
                }
            },
            EndPoint: {
                get: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.Rope#EndPoint#get", this ); }

                    return this.endPoint;
                }
            },
            IsPrefab: {
                get: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.Rope#IsPrefab#get", this ); }

                    return false;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.Rope#init", this ); }

                this.currentValue = new UnityEngine.Vector3();
                this.currentVelocity = new UnityEngine.Vector3();
                this.targetValue = new UnityEngine.Vector3();
                this.otherPhysicsFactors = new UnityEngine.Vector3();
                this.prevStartPointPosition = new UnityEngine.Vector3();
                this.prevEndPointPosition = new UnityEngine.Vector3();
                this.linePoints = 10;
                this.stiffness = 350.0;
                this.damping = 15.0;
                this.ropeLength = 15;
                this.ropeWidth = 0.1;
                this.midPointWeight = 1.0;
                this.midPointPosition = 0.5;
                this.isFirstFrame = true;
            }
        },
        methods: {
            /*GogoGaga.OptimizedRopesAndCables.Rope.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.Rope#Start", this ); }

                this.InitializeLineRenderer();
                if (this.AreEndPointsValid()) {
                    this.currentValue = this.GetMidPoint();
                    this.targetValue = this.currentValue.$clone();
                    this.currentVelocity = pc.Vec3.ZERO.clone();
                    this.SetSplinePoint(); // Ensure initial spline point is set correctly
                }
            },
            /*GogoGaga.OptimizedRopesAndCables.Rope.Start end.*/

            /*GogoGaga.OptimizedRopesAndCables.Rope.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.Rope#OnValidate", this ); }

                if (!UnityEngine.Application.isPlaying) {
                    this.InitializeLineRenderer();
                    if (this.AreEndPointsValid()) {
                        this.RecalculateRope();
                        this.SimulatePhysics();
                    } else {
                        this.lineRenderer.positionCount = 0;
                    }
                }
            },
            /*GogoGaga.OptimizedRopesAndCables.Rope.OnValidate end.*/

            /*GogoGaga.OptimizedRopesAndCables.Rope.InitializeLineRenderer start.*/
            InitializeLineRenderer: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.Rope#InitializeLineRenderer", this ); }

                if (!UnityEngine.Object.op_Implicit(this.lineRenderer)) {
                    this.lineRenderer = this.GetComponent(UnityEngine.LineRenderer);
                }

                this.lineRenderer.startWidth = this.ropeWidth;
                this.lineRenderer.endWidth = this.ropeWidth;
            },
            /*GogoGaga.OptimizedRopesAndCables.Rope.InitializeLineRenderer end.*/

            /*GogoGaga.OptimizedRopesAndCables.Rope.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.Rope#Update", this ); }

                if (this.IsPrefab) {
                    return;
                }

                if (this.AreEndPointsValid()) {
                    this.SetSplinePoint();

                    if (!UnityEngine.Application.isPlaying && (this.IsPointsMoved() || this.IsRopeSettingsChanged())) {
                        this.SimulatePhysics();
                        this.NotifyPointsChanged();
                    }

                    this.prevStartPointPosition = this.startPoint.position.$clone();
                    this.prevEndPointPosition = this.endPoint.position.$clone();
                    this.prevMidPointPosition = this.midPointPosition;
                    this.prevMidPointWeight = this.midPointWeight;

                    this.prevLineQuality = this.linePoints;
                    this.prevRopeWidth = this.ropeWidth;
                    this.prevstiffness = this.stiffness;
                    this.prevDampness = this.damping;
                    this.prevRopeLength = this.ropeLength;
                }
            },
            /*GogoGaga.OptimizedRopesAndCables.Rope.Update end.*/

            /*GogoGaga.OptimizedRopesAndCables.Rope.AreEndPointsValid start.*/
            AreEndPointsValid: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.Rope#AreEndPointsValid", this ); }

                return UnityEngine.Component.op_Inequality(this.startPoint, null) && UnityEngine.Component.op_Inequality(this.endPoint, null);
            },
            /*GogoGaga.OptimizedRopesAndCables.Rope.AreEndPointsValid end.*/

            /*GogoGaga.OptimizedRopesAndCables.Rope.SetSplinePoint start.*/
            SetSplinePoint: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.Rope#SetSplinePoint", this ); }

                if (this.lineRenderer.positionCount !== ((this.linePoints + 1) | 0)) {
                    this.lineRenderer.positionCount = (this.linePoints + 1) | 0;
                }

                var mid = this.GetMidPoint();
                this.targetValue = mid.$clone();
                mid = this.currentValue.$clone();

                if (UnityEngine.Component.op_Inequality(this.midPoint, null)) {
                    this.midPoint.position = this.GetRationalBezierPoint(this.startPoint.position, mid, this.endPoint.position, this.midPointPosition, GogoGaga.OptimizedRopesAndCables.Rope.StartPointWeight, this.midPointWeight, GogoGaga.OptimizedRopesAndCables.Rope.EndPointWeight);
                }

                for (var i = 0; i < this.linePoints; i = (i + 1) | 0) {
                    var p = this.GetRationalBezierPoint(this.startPoint.position, mid, this.endPoint.position, i / this.linePoints, GogoGaga.OptimizedRopesAndCables.Rope.StartPointWeight, this.midPointWeight, GogoGaga.OptimizedRopesAndCables.Rope.EndPointWeight);
                    this.lineRenderer.SetPosition(i, p);
                }

                this.lineRenderer.SetPosition(this.linePoints, this.endPoint.position);
            },
            /*GogoGaga.OptimizedRopesAndCables.Rope.SetSplinePoint end.*/

            /*GogoGaga.OptimizedRopesAndCables.Rope.CalculateYFactorAdjustment start.*/
            CalculateYFactorAdjustment: function (weight) {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.Rope#CalculateYFactorAdjustment", this ); }

                //float k = 0.360f; //after testing this seemed to be a good value for most cases, more accurate k is available.
                var k = pc.math.lerp(0.493, 0.323, pc.math.inverseLerp(1, 15, weight)); //K calculation that is more accurate, interpolates between precalculated values.
                var w = 1.0 + k * Math.log(weight);
                return w;
            },
            /*GogoGaga.OptimizedRopesAndCables.Rope.CalculateYFactorAdjustment end.*/

            /*GogoGaga.OptimizedRopesAndCables.Rope.GetMidPoint start.*/
            GetMidPoint: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.Rope#GetMidPoint", this ); }

                var startPointPosition = this.startPoint.position.$clone();
                var endPointPosition = this.endPoint.position.$clone();
                var midpos = new pc.Vec3().lerp( startPointPosition, endPointPosition, this.midPointPosition );
                var yFactor = (this.ropeLength - UnityEngine.Mathf.Min(pc.Vec3.distance( startPointPosition, endPointPosition ), this.ropeLength)) / this.CalculateYFactorAdjustment(this.midPointWeight);
                midpos.y -= yFactor;
                return midpos.$clone();
            },
            /*GogoGaga.OptimizedRopesAndCables.Rope.GetMidPoint end.*/

            /*GogoGaga.OptimizedRopesAndCables.Rope.GetRationalBezierPoint start.*/
            GetRationalBezierPoint: function (p0, p1, p2, t, w0, w1, w2) {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.Rope#GetRationalBezierPoint", this ); }

                //scale each point by its weight (can probably remove w0 and w2 if the midpoint is the only adjustable weight)
                var wp0 = p0.clone().scale( w0 );
                var wp1 = p1.clone().scale( w1 );
                var wp2 = p2.clone().scale( w2 );

                //calculate the denominator of the rational Bzier curve
                var denominator = w0 * Math.pow(1 - t, 2) + 2 * w1 * (1 - t) * t + w2 * Math.pow(t, 2);
                //calculate the numerator and devide by the demoninator to get the point on the curve
                var point = (wp0.$clone().clone().scale( Math.pow(1 - t, 2) ).add( wp1.$clone().clone().scale( 2 ).clone().scale( (1 - t) ).clone().scale( t ) ).add( wp2.$clone().clone().scale( Math.pow(t, 2) ) )).scale( 1.0 / ( denominator ) );

                return point.$clone();
            },
            /*GogoGaga.OptimizedRopesAndCables.Rope.GetRationalBezierPoint end.*/

            /*GogoGaga.OptimizedRopesAndCables.Rope.GetPointAt start.*/
            GetPointAt: function (t) {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.Rope#GetPointAt", this ); }

                if (!this.AreEndPointsValid()) {
                    UnityEngine.Debug.LogError$2("StartPoint or EndPoint is not assigned.", this.gameObject);
                    return pc.Vec3.ZERO.clone();
                }

                return this.GetRationalBezierPoint(this.startPoint.position, this.currentValue, this.endPoint.position, t, GogoGaga.OptimizedRopesAndCables.Rope.StartPointWeight, this.midPointWeight, GogoGaga.OptimizedRopesAndCables.Rope.EndPointWeight);
            },
            /*GogoGaga.OptimizedRopesAndCables.Rope.GetPointAt end.*/

            /*GogoGaga.OptimizedRopesAndCables.Rope.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.Rope#FixedUpdate", this ); }

                if (this.IsPrefab) {
                    return;
                }

                if (this.AreEndPointsValid()) {
                    if (!this.isFirstFrame) {
                        this.SimulatePhysics();
                    }

                    this.isFirstFrame = false;
                }
            },
            /*GogoGaga.OptimizedRopesAndCables.Rope.FixedUpdate end.*/

            /*GogoGaga.OptimizedRopesAndCables.Rope.SimulatePhysics start.*/
            SimulatePhysics: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.Rope#SimulatePhysics", this ); }

                var dampingFactor = UnityEngine.Mathf.Max(0, 1 - this.damping * UnityEngine.Time.fixedDeltaTime);
                var acceleration = (this.targetValue.$clone().sub( this.currentValue )).clone().scale( this.stiffness ).clone().scale( UnityEngine.Time.fixedDeltaTime );
                this.currentVelocity = this.currentVelocity.$clone().clone().scale( dampingFactor ).add( acceleration ).add( this.otherPhysicsFactors );
                this.currentValue = this.currentValue.$clone().add( this.currentVelocity.$clone().clone().scale( UnityEngine.Time.fixedDeltaTime ) );

                if (pc.Vec3.distance( this.currentValue, this.targetValue ) < GogoGaga.OptimizedRopesAndCables.Rope.valueThreshold && this.currentVelocity.length() < GogoGaga.OptimizedRopesAndCables.Rope.velocityThreshold) {
                    this.currentValue = this.targetValue.$clone();
                    this.currentVelocity = pc.Vec3.ZERO.clone();
                }
            },
            /*GogoGaga.OptimizedRopesAndCables.Rope.SimulatePhysics end.*/

            /*GogoGaga.OptimizedRopesAndCables.Rope.OnDrawGizmos start.*/
            OnDrawGizmos: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.Rope#OnDrawGizmos", this ); }

                if (!this.AreEndPointsValid()) {
                    return;
                }

                var midPos = this.GetMidPoint();
                // Uncomment if you need to visualize midpoint
                // Gizmos.color = Color.red;
                // Gizmos.DrawSphere(midPos, 0.2f);
            },
            /*GogoGaga.OptimizedRopesAndCables.Rope.OnDrawGizmos end.*/

            /*GogoGaga.OptimizedRopesAndCables.Rope.SetStartPoint start.*/
            SetStartPoint: function (newStartPoint, instantAssign) {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.Rope#SetStartPoint", this ); }

                if (instantAssign === void 0) { instantAssign = false; }
                this.startPoint = newStartPoint;
                this.prevStartPointPosition = UnityEngine.Component.op_Equality(this.startPoint, null) ? pc.Vec3.ZERO.clone() : this.startPoint.position.$clone();

                if (instantAssign || UnityEngine.Component.op_Equality(newStartPoint, null)) {
                    this.RecalculateRope();
                }

                this.NotifyPointsChanged();
            },
            /*GogoGaga.OptimizedRopesAndCables.Rope.SetStartPoint end.*/

            /*GogoGaga.OptimizedRopesAndCables.Rope.SetMidPoint start.*/
            SetMidPoint: function (newMidPoint, instantAssign) {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.Rope#SetMidPoint", this ); }

                if (instantAssign === void 0) { instantAssign = false; }
                this.midPoint = newMidPoint;
                this.prevMidPointPosition = UnityEngine.Component.op_Equality(this.midPoint, null) ? 0.5 : this.midPointPosition;

                if (instantAssign || UnityEngine.Component.op_Equality(newMidPoint, null)) {
                    this.RecalculateRope();
                }
                this.NotifyPointsChanged();
            },
            /*GogoGaga.OptimizedRopesAndCables.Rope.SetMidPoint end.*/

            /*GogoGaga.OptimizedRopesAndCables.Rope.SetEndPoint start.*/
            SetEndPoint: function (newEndPoint, instantAssign) {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.Rope#SetEndPoint", this ); }

                if (instantAssign === void 0) { instantAssign = false; }
                this.endPoint = newEndPoint;
                this.prevEndPointPosition = UnityEngine.Component.op_Equality(this.endPoint, null) ? pc.Vec3.ZERO.clone() : this.endPoint.position.$clone();

                if (instantAssign || UnityEngine.Component.op_Equality(newEndPoint, null)) {
                    this.RecalculateRope();
                }

                this.NotifyPointsChanged();
            },
            /*GogoGaga.OptimizedRopesAndCables.Rope.SetEndPoint end.*/

            /*GogoGaga.OptimizedRopesAndCables.Rope.RecalculateRope start.*/
            RecalculateRope: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.Rope#RecalculateRope", this ); }

                if (!this.AreEndPointsValid()) {
                    this.lineRenderer.positionCount = 0;
                    return;
                }

                this.currentValue = this.GetMidPoint();
                this.targetValue = this.currentValue.$clone();
                this.currentVelocity = pc.Vec3.ZERO.clone();
                this.SetSplinePoint();
            },
            /*GogoGaga.OptimizedRopesAndCables.Rope.RecalculateRope end.*/

            /*GogoGaga.OptimizedRopesAndCables.Rope.NotifyPointsChanged start.*/
            NotifyPointsChanged: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.Rope#NotifyPointsChanged", this ); }

                !Bridge.staticEquals(this.OnPointsChanged, null) ? this.OnPointsChanged() : null;
            },
            /*GogoGaga.OptimizedRopesAndCables.Rope.NotifyPointsChanged end.*/

            /*GogoGaga.OptimizedRopesAndCables.Rope.IsPointsMoved start.*/
            IsPointsMoved: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.Rope#IsPointsMoved", this ); }

                var startPointMoved = !pc.Vec3.equals( this.startPoint.position, this.prevStartPointPosition );
                var endPointMoved = !pc.Vec3.equals( this.endPoint.position, this.prevEndPointPosition );
                return startPointMoved || endPointMoved;
            },
            /*GogoGaga.OptimizedRopesAndCables.Rope.IsPointsMoved end.*/

            /*GogoGaga.OptimizedRopesAndCables.Rope.IsRopeSettingsChanged start.*/
            IsRopeSettingsChanged: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.Rope#IsRopeSettingsChanged", this ); }

                var lineQualityChanged = !UnityEngine.Mathf.Approximately(this.linePoints, this.prevLineQuality);
                var ropeWidthChanged = !UnityEngine.Mathf.Approximately(this.ropeWidth, this.prevRopeWidth);
                var stiffnessChanged = !UnityEngine.Mathf.Approximately(this.stiffness, this.prevstiffness);
                var dampnessChanged = !UnityEngine.Mathf.Approximately(this.damping, this.prevDampness);
                var ropeLengthChanged = !UnityEngine.Mathf.Approximately(this.ropeLength, this.prevRopeLength);
                var midPointPositionChanged = !UnityEngine.Mathf.Approximately(this.midPointPosition, this.prevMidPointPosition);
                var midPointWeightChanged = !UnityEngine.Mathf.Approximately(this.midPointWeight, this.prevMidPointWeight);

                return lineQualityChanged || ropeWidthChanged || stiffnessChanged || dampnessChanged || ropeLengthChanged || midPointPositionChanged || midPointWeightChanged;
            },
            /*GogoGaga.OptimizedRopesAndCables.Rope.IsRopeSettingsChanged end.*/


        }
    });
    /*GogoGaga.OptimizedRopesAndCables.Rope end.*/

    /*GogoGaga.OptimizedRopesAndCables.RopeMesh start.*/
    Bridge.define("GogoGaga.OptimizedRopesAndCables.RopeMesh", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                ColorID: 0,
                TwoHalfColor1ID: 0,
                TwoHalfColor2ID: 0,
                TwoHalfMaskSTID: 0,
                BaseColorID: 0,
                TintColorID: 0,
                EmissionColorID: 0,
                MainColorID: 0,
                TintID: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.RopeMesh#init", this ); }

                    this.ColorID = UnityEngine.Shader.PropertyToID("_Color");
                    this.TwoHalfColor1ID = UnityEngine.Shader.PropertyToID("_TwoHalfColorsColor1");
                    this.TwoHalfColor2ID = UnityEngine.Shader.PropertyToID("_TwoHalfColorsColor2");
                    this.TwoHalfMaskSTID = UnityEngine.Shader.PropertyToID("_TwoHalfColorsMaskTex_ST");
                    this.BaseColorID = UnityEngine.Shader.PropertyToID("_BaseColor");
                    this.TintColorID = UnityEngine.Shader.PropertyToID("_TintColor");
                    this.EmissionColorID = UnityEngine.Shader.PropertyToID("_EmissionColor");
                    this.MainColorID = UnityEngine.Shader.PropertyToID("_MainColor");
                    this.TintID = UnityEngine.Shader.PropertyToID("_Tint");
                }
            }
        },
        fields: {
            OverallDivision: 0,
            ropeWidth: 0,
            radialDivision: 0,
            material: null,
            tilingPerMeter: 0,
            rope: null,
            meshFilter: null,
            meshRenderer: null,
            ropeMesh: null,
            isStartOrEndPointMissing: false,
            vertices: null,
            triangles: null,
            uvs: null,
            RopeLogic: null,
            StartPoint: null,
            EndPoint: null,
            FirstHalfColor: null,
            SecondHalfColor: null,
            ThresholdDistance: 0,
            ThresholdOffsetY: 0,
            UpdateRate: 0,
            frameCounter: 0,
            EnableDebugColorLogs: false,
            OverrideColorProperty: null,
            overrideColorID: 0,
            lastColorPropertyUsed: null,
            RebuildOnEveryFrame: false,
            MinSecondsBetweenRebuilds: 0,
            RebuildMovementThreshold: 0,
            RecalculateNormals: false,
            lastStartPointPos: null,
            lastEndPointPos: null,
            lastOverallDivision: 0,
            lastRadialDivision: 0,
            lastRopeWidth: 0,
            lastTilingPerMeter: 0,
            lastRebuildTime: 0,
            firstRuntimeFrame: false,
            points: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.RopeMesh#init", this ); }

                this.FirstHalfColor = new UnityEngine.Color();
                this.SecondHalfColor = new UnityEngine.Color();
                this.lastStartPointPos = new UnityEngine.Vector3();
                this.lastEndPointPos = new UnityEngine.Vector3();
                this.OverallDivision = 6;
                this.ropeWidth = 0.3;
                this.radialDivision = 8;
                this.tilingPerMeter = 1.0;
                this.vertices = new (System.Collections.Generic.List$1(UnityEngine.Vector3)).ctor();
                this.triangles = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                this.uvs = new (System.Collections.Generic.List$1(UnityEngine.Vector2)).ctor();
                this.ThresholdDistance = 1.0;
                this.ThresholdOffsetY = -0.5;
                this.UpdateRate = 5;
                this.overrideColorID = -1;
                this.RebuildOnEveryFrame = false;
                this.MinSecondsBetweenRebuilds = 0.02;
                this.RebuildMovementThreshold = 0.0005;
                this.RecalculateNormals = true;
                this.firstRuntimeFrame = true;
            }
        },
        methods: {
            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.RopeMesh#Awake", this ); }

                this.InitializeComponents(false);
                this.SubscribeToRopeEvents();
                this.CacheOverrideColorID();
            },
            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.Awake end.*/

            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.RopeMesh#OnEnable", this ); }

                if (!UnityEngine.Application.isPlaying) {
                }
                this.SubscribeToRopeEvents();
                this.ReOffsetTextureTwoHalf();
            },
            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.OnEnable end.*/

            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.RopeMesh#OnDisable", this ); }

                this.UnsubscribeFromRopeEvents();
            },
            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.OnDisable end.*/

            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.InitializeComponents start.*/
            InitializeComponents: function (assignMeshToFilter) {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.RopeMesh#InitializeComponents", this ); }

                var $t;
                if (assignMeshToFilter === void 0) { assignMeshToFilter = true; }
                if (!UnityEngine.Object.op_Implicit(this.rope)) {
                    this.rope = this.GetComponent(GogoGaga.OptimizedRopesAndCables.Rope);
                }
                if (!UnityEngine.Object.op_Implicit(this.meshFilter)) {
                    this.meshFilter = this.GetComponent(UnityEngine.MeshFilter);
                }
                if (!UnityEngine.Object.op_Implicit(this.meshRenderer)) {
                    this.meshRenderer = this.GetComponent(UnityEngine.MeshRenderer);
                }

                if (this.ropeMesh == null) {
                    this.ropeMesh = ($t = new UnityEngine.Mesh.ctor(), $t.name = "RopeMesh", $t);
                    this.ropeMesh.MarkDynamic();
                }

                // Only assign to MeshFilter when it's safe (not from OnValidate)
                if (assignMeshToFilter && UnityEngine.Object.op_Implicit(this.meshFilter) && !Bridge.referenceEquals(this.meshFilter.sharedMesh, this.ropeMesh)) {
                    this.meshFilter.sharedMesh = this.ropeMesh;
                }

                this.CheckEndPoints();
            },
            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.InitializeComponents end.*/

            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.CheckEndPoints start.*/
            CheckEndPoints: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.RopeMesh#CheckEndPoints", this ); }

                // // Check if start and end points are assigned
                // if (gameObject.scene.rootCount == 0)
                // {
                //     isStartOrEndPointMissing = false;
                //     return;
                // }

                if (UnityEngine.Component.op_Equality(this.rope.StartPoint, null) || UnityEngine.Component.op_Equality(this.rope.EndPoint, null)) {
                    this.isStartOrEndPointMissing = true;
                    UnityEngine.Debug.LogError$2("StartPoint or EndPoint is not assigned.", this.gameObject);
                } else {
                    this.isStartOrEndPointMissing = false;
                }
            },
            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.CheckEndPoints end.*/

            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.SubscribeToRopeEvents start.*/
            SubscribeToRopeEvents: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.RopeMesh#SubscribeToRopeEvents", this ); }

                this.UnsubscribeFromRopeEvents();
                if (UnityEngine.MonoBehaviour.op_Inequality(this.rope, null)) {
                    this.rope.addOnPointsChanged(Bridge.fn.cacheBind(this, this.GenerateMesh));
                }
            },
            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.SubscribeToRopeEvents end.*/

            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.UnsubscribeFromRopeEvents start.*/
            UnsubscribeFromRopeEvents: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.RopeMesh#UnsubscribeFromRopeEvents", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.rope, null)) {
                    this.rope.removeOnPointsChanged(Bridge.fn.cacheBind(this, this.GenerateMesh));
                }
            },
            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.UnsubscribeFromRopeEvents end.*/

            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.CreateRopeMesh start.*/
            CreateRopeMesh: function (points, radius, segmentsPerWire) {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.RopeMesh#CreateRopeMesh", this ); }

                var $t;
                if (points == null || points.length < 2) {
                    UnityEngine.Debug.LogError$2("Need at least two points to create a rope mesh.", this.gameObject);
                    return;
                }

                if (this.ropeMesh == null) {
                    this.ropeMesh = ($t = new UnityEngine.Mesh.ctor(), $t.name = "RopeMesh", $t);
                    this.ropeMesh.MarkDynamic();
                }

                // Safe to assign here (not during OnValidate)
                if (UnityEngine.Object.op_Implicit(this.meshFilter) && !Bridge.referenceEquals(this.meshFilter.sharedMesh, this.ropeMesh)) {
                    this.meshFilter.sharedMesh = this.ropeMesh;
                }

                this.ropeMesh.Clear();

                // Reserve capacity (approx) to reduce list reallocations
                var rings = points.length;
                var vertsPerRing = (segmentsPerWire + 1) | 0;
                var estimatedVerts = (Bridge.Int.mul(rings, vertsPerRing) + Bridge.Int.mul((((segmentsPerWire + 2) | 0)), 2)) | 0; // + caps
                if (this.vertices.Capacity < estimatedVerts) {
                    this.vertices.Capacity = estimatedVerts;
                }
                if (this.uvs.Capacity < estimatedVerts) {
                    this.uvs.Capacity = estimatedVerts;
                }
                var estimatedTriangles = (Bridge.Int.mul(Bridge.Int.mul((((rings - 1) | 0)), segmentsPerWire), 6) + Bridge.Int.mul(Bridge.Int.mul(segmentsPerWire, 3), 2)) | 0; // body + caps
                if (this.triangles.Capacity < estimatedTriangles) {
                    this.triangles.Capacity = estimatedTriangles;
                }

                // Clear the lists before using them
                this.vertices.clear();
                this.triangles.clear();
                this.uvs.clear();

                var currentLength = 0.0;

                // Generate vertices and UVs for each segment along the points
                for (var i = 0; i < points.length; i = (i + 1) | 0) {
                    var direction = i < ((points.length - 1) | 0) ? points[((i + 1) | 0)].$clone().sub( points[i] ) : points[i].$clone().sub( points[((i - 1) | 0)] );
                    // Guard against zero-length direction which causes Quaternion.LookRotation to throw
                    if (direction.lengthSq() < 1E-06) {
                        // Try fallback to previous segment
                        if (i > 0) {
                            direction = points[i].$clone().sub( points[((i - 1) | 0)] );
                        }
                    }
                    if (direction.lengthSq() < 1E-06) {
                        // Try fallback to next segment
                        if (i < ((points.length - 1) | 0)) {
                            direction = points[((i + 1) | 0)].$clone().sub( points[i] );
                        }
                    }
                    if (direction.lengthSq() < 1E-06) {
                        // Ultimate fallback: a stable forward vector
                        direction = new pc.Vec3( 0, 0, 1 );
                    }
                    var rotation = new pc.Quat().lookRotation( direction.clone().normalize(), pc.Vec3.UP.clone() );

                    // Create vertices around a circle at this point
                    for (var j = 0; j <= segmentsPerWire; j = (j + 1) | 0) {
                        var angle = j * UnityEngine.Mathf.PI * 2.0 / segmentsPerWire;
                        var offset = new pc.Vec3( Math.cos(angle), Math.sin(angle), 0 ).clone().scale( radius );
                        this.vertices.add(this.transform.InverseTransformPoint(points[i].$clone().add( rotation.transformVector( offset ) )));

                        var u = j / segmentsPerWire;
                        var v = currentLength * this.tilingPerMeter;
                        this.uvs.add(new pc.Vec2( u, v ));
                    }

                    if (i < ((points.length - 1) | 0)) {
                        currentLength += pc.Vec3.distance( points[i], points[((i + 1) | 0)] );
                    }
                }

                // Generate triangles for each segment
                for (var i1 = 0; i1 < ((points.length - 1) | 0); i1 = (i1 + 1) | 0) {
                    for (var j1 = 0; j1 < segmentsPerWire; j1 = (j1 + 1) | 0) {
                        var current = (Bridge.Int.mul(i1, (((segmentsPerWire + 1) | 0))) + j1) | 0;
                        var next = (current + 1) | 0;
                        var nextSegment = (((current + segmentsPerWire) | 0) + 1) | 0;
                        var nextSegmentNext = (nextSegment + 1) | 0;

                        this.triangles.add(current);
                        this.triangles.add(next);
                        this.triangles.add(nextSegment);

                        this.triangles.add(next);
                        this.triangles.add(nextSegmentNext);
                        this.triangles.add(nextSegment);
                    }
                }

                // Generate vertices, triangles, and UVs for the start cap
                var startCapCenterIndex = this.vertices.Count;
                this.vertices.add(this.transform.InverseTransformPoint(points[0]));
                this.uvs.add(new pc.Vec2( 0.5, 0 )); // Center of the cap
                // Guard start cap rotation against zero-length vector
                var startDir = (points.length > 1) ? (points[1].$clone().sub( points[0] )) : new pc.Vec3( 0, 0, 1 );
                if (startDir.lengthSq() < 1E-06) {
                    startDir = new pc.Vec3( 0, 0, 1 );
                }
                var startRotation = new pc.Quat().lookRotation( startDir.clone().normalize(), pc.Vec3.UP.clone() );
                for (var j2 = 0; j2 <= segmentsPerWire; j2 = (j2 + 1) | 0) {
                    var angle1 = j2 * UnityEngine.Mathf.PI * 2.0 / segmentsPerWire;
                    var offset1 = new pc.Vec3( Math.cos(angle1), Math.sin(angle1), 0 ).clone().scale( radius );
                    this.vertices.add(this.transform.InverseTransformPoint(points[0].$clone().add( startRotation.transformVector( offset1 ) )));

                    if (j2 < segmentsPerWire) {
                        this.triangles.add(startCapCenterIndex);
                        this.triangles.add(((((startCapCenterIndex + j2) | 0) + 1) | 0));
                        this.triangles.add(((((startCapCenterIndex + j2) | 0) + 2) | 0));
                    }

                    this.uvs.add(new pc.Vec2( (Math.cos(angle1) + 1) / 2, (Math.sin(angle1) + 1) / 2 ));
                }

                // Generate vertices, triangles, and UVs for the end cap
                var endCapCenterIndex = this.vertices.Count;
                this.vertices.add(this.transform.InverseTransformPoint(points[((points.length - 1) | 0)]));
                this.uvs.add(new pc.Vec2( 0.5, currentLength * this.tilingPerMeter )); // Center of the cap
                // Guard end cap rotation against zero-length vector
                var endDir = (points.length > 1) ? (points[((points.length - 1) | 0)].$clone().sub( points[((points.length - 2) | 0)] )) : new pc.Vec3( 0, 0, 1 );
                if (endDir.lengthSq() < 1E-06) {
                    endDir = new pc.Vec3( 0, 0, 1 );
                }
                var endRotation = new pc.Quat().lookRotation( endDir.clone().normalize(), pc.Vec3.UP.clone() );
                for (var j3 = 0; j3 <= segmentsPerWire; j3 = (j3 + 1) | 0) {
                    var angle2 = j3 * UnityEngine.Mathf.PI * 2.0 / segmentsPerWire;
                    var offset2 = new pc.Vec3( Math.cos(angle2), Math.sin(angle2), 0 ).clone().scale( radius );
                    this.vertices.add(this.transform.InverseTransformPoint(points[((points.length - 1) | 0)].$clone().add( endRotation.transformVector( offset2 ) )));

                    if (j3 < segmentsPerWire) {
                        this.triangles.add(endCapCenterIndex);
                        this.triangles.add(((((endCapCenterIndex + j3) | 0) + 1) | 0));
                        this.triangles.add(((((endCapCenterIndex + j3) | 0) + 2) | 0));
                    }

                    this.uvs.add(new pc.Vec2( (Math.cos(angle2) + 1) / 2, (Math.sin(angle2) + 1) / 2 ));
                }

                this.ropeMesh.SetVertices(this.vertices);
                this.ropeMesh.SetTriangles$1(this.triangles, 0, true);
                this.ropeMesh.SetUVs(0, this.uvs);
                if (this.RecalculateNormals) {
                    this.ropeMesh.RecalculateNormals();
                }
            },
            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.CreateRopeMesh end.*/

            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.GenerateMesh start.*/
            GenerateMesh: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.RopeMesh#GenerateMesh", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this, null) || UnityEngine.MonoBehaviour.op_Equality(this.rope, null) || UnityEngine.Component.op_Equality(this.meshFilter, null)) {
                    return;
                }

                if (this.isStartOrEndPointMissing) {
                    if (this.meshFilter.sharedMesh != null) {
                        this.meshFilter.sharedMesh.Clear();
                    }
                    return;
                }
                if (this.points == null || this.points.length !== ((this.OverallDivision + 1) | 0)) {
                    this.points = System.Array.init(((this.OverallDivision + 1) | 0), function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                }

                for (var i = 0; i < this.points.length; i = (i + 1) | 0) {
                    this.points[i] = this.rope.GetPointAt(i / this.OverallDivision);
                }
                this.CreateRopeMesh(this.points, this.ropeWidth, this.radialDivision);
            },
            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.GenerateMesh end.*/

            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.RopeMesh#Update", this ); }

                if (this.rope.IsPrefab) {
                    return;
                }

                if (!UnityEngine.Application.isPlaying) {
                    // In editor (not playing) keep previous behaviour for immediate feedback
                    this.GenerateMesh();
                    return;
                }

                var needRebuild = this.RebuildOnEveryFrame;

                // Detect endpoint movement
                if (!this.isStartOrEndPointMissing && UnityEngine.Object.op_Implicit(this.rope.StartPoint) && UnityEngine.Object.op_Implicit(this.rope.EndPoint)) {
                    var sp = this.rope.StartPoint.position.$clone();
                    var ep = this.rope.EndPoint.position.$clone();
                    if (this.firstRuntimeFrame || (sp.$clone().sub( this.lastStartPointPos ).lengthSq() > this.RebuildMovementThreshold) || (ep.$clone().sub( this.lastEndPointPos ).lengthSq() > this.RebuildMovementThreshold)) {
                        needRebuild = true;
                    }
                }

                // Detect parameter changes
                if (this.OverallDivision !== this.lastOverallDivision || this.radialDivision !== this.lastRadialDivision || !UnityEngine.Mathf.Approximately(this.ropeWidth, this.lastRopeWidth) || !UnityEngine.Mathf.Approximately(this.tilingPerMeter, this.lastTilingPerMeter)) {
                    needRebuild = true;
                }

                // Throttle rebuilds
                if (needRebuild) {
                    var t = UnityEngine.Time.time;
                    if ((t - this.lastRebuildTime) >= this.MinSecondsBetweenRebuilds || this.firstRuntimeFrame) {
                        this.GenerateMesh();
                        this.lastRebuildTime = t;
                        this.firstRuntimeFrame = false;
                        if (UnityEngine.Object.op_Implicit(this.rope.StartPoint)) {
                            this.lastStartPointPos = this.rope.StartPoint.position.$clone();
                        }
                        if (UnityEngine.Object.op_Implicit(this.rope.EndPoint)) {
                            this.lastEndPointPos = this.rope.EndPoint.position.$clone();
                        }
                        this.lastOverallDivision = this.OverallDivision;
                        this.lastRadialDivision = this.radialDivision;
                        this.lastRopeWidth = this.ropeWidth;
                        this.lastTilingPerMeter = this.tilingPerMeter;
                    }
                }

                if (this.frameCounter > this.UpdateRate) {
                    this.ReOffsetTextureTwoHalf();
                    this.frameCounter = 0;
                }
                this.frameCounter = (this.frameCounter + 1) | 0;
            },
            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.Update end.*/

            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.DelayedGenerateMesh start.*/
            DelayedGenerateMesh: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.RopeMesh#DelayedGenerateMesh", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this, null)) {
                    this.GenerateMesh();
                }
            },
            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.DelayedGenerateMesh end.*/

            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.RopeMesh#OnDestroy", this ); }

                this.UnsubscribeFromRopeEvents();

                if (UnityEngine.Component.op_Inequality(this.meshRenderer, null)) {
                    UnityEngine.Object.Destroy(this.meshRenderer);
                }
                if (UnityEngine.Component.op_Inequality(this.meshFilter, null)) {
                    UnityEngine.Object.Destroy(this.meshFilter);
                }
            },
            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.OnDestroy end.*/

            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.CacheOverrideColorID start.*/
            CacheOverrideColorID: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.RopeMesh#CacheOverrideColorID", this ); }

                if (!System.String.isNullOrEmpty(this.OverrideColorProperty)) {
                    this.overrideColorID = UnityEngine.Shader.PropertyToID(this.OverrideColorProperty);
                } else {
                    this.overrideColorID = -1;
                }
            },
            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.CacheOverrideColorID end.*/

            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.TrySetSingleColor start.*/
            TrySetSingleColor: function (mat, color) {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.RopeMesh#TrySetSingleColor", this ); }

                if (mat == null) {
                    return false;
                }
                // 1) Manual override
                if (this.overrideColorID !== -1 && mat.HasProperty(this.overrideColorID)) {
                    mat.SetColor(this.overrideColorID, color);
                    this.lastColorPropertyUsed = this.OverrideColorProperty;
                    return true;
                }
                // 2) Common properties (order of preference)
                if (mat.HasProperty(GogoGaga.OptimizedRopesAndCables.RopeMesh.BaseColorID)) {
                    mat.SetColor(GogoGaga.OptimizedRopesAndCables.RopeMesh.BaseColorID, color);
                    this.lastColorPropertyUsed = "_BaseColor";
                    return true;
                }
                if (mat.HasProperty(GogoGaga.OptimizedRopesAndCables.RopeMesh.ColorID)) {
                    mat.SetColor(GogoGaga.OptimizedRopesAndCables.RopeMesh.ColorID, color);
                    this.lastColorPropertyUsed = "_Color";
                    return true;
                }
                if (mat.HasProperty(GogoGaga.OptimizedRopesAndCables.RopeMesh.MainColorID)) {
                    mat.SetColor(GogoGaga.OptimizedRopesAndCables.RopeMesh.MainColorID, color);
                    this.lastColorPropertyUsed = "_MainColor";
                    return true;
                }
                if (mat.HasProperty(GogoGaga.OptimizedRopesAndCables.RopeMesh.TintColorID)) {
                    mat.SetColor(GogoGaga.OptimizedRopesAndCables.RopeMesh.TintColorID, color);
                    this.lastColorPropertyUsed = "_TintColor";
                    return true;
                }
                if (mat.HasProperty(GogoGaga.OptimizedRopesAndCables.RopeMesh.TintID)) {
                    mat.SetColor(GogoGaga.OptimizedRopesAndCables.RopeMesh.TintID, color);
                    this.lastColorPropertyUsed = "_Tint";
                    return true;
                }
                if (mat.HasProperty(GogoGaga.OptimizedRopesAndCables.RopeMesh.EmissionColorID)) {
                    mat.SetColor(GogoGaga.OptimizedRopesAndCables.RopeMesh.EmissionColorID, color);
                    this.lastColorPropertyUsed = "_EmissionColor";
                    mat.EnableKeyword("_EMISSION");
                    return true;
                }
                return false;
            },
            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.TrySetSingleColor end.*/

            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.SetColor start.*/
            SetColor: function (_color) {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.RopeMesh#SetColor", this ); }

                if (UnityEngine.Component.op_Inequality(this.meshRenderer, null)) {
                    var mat = this.meshRenderer.material; // instance material
                    if (this.TrySetSingleColor(mat, _color)) {
                        if (this.EnableDebugColorLogs) {
                            UnityEngine.Debug.Log$1(System.String.format("[RopeMesh] Applied color {0} using property '{1}' on material '{2}'.", _color.$clone(), this.lastColorPropertyUsed, mat.name), this);
                        }
                    } else if (this.EnableDebugColorLogs) {
                        UnityEngine.Debug.LogWarning$1("[RopeMesh] Kh\u00f4ng t\u00ecm th\u1ea5y property m\u00e0u ph\u00f9 h\u1ee3p. H\u00e3y set OverrideColorProperty ho\u1eb7c d\u00f9ng menu 'Log Material Color Props' \u0111\u1ec3 ki\u1ec3m tra.", this);
                    }
                } else if (this.EnableDebugColorLogs) {
                    UnityEngine.Debug.LogWarning$1("[RopeMesh] meshRenderer null, kh\u00f4ng set \u0111\u01b0\u1ee3c m\u00e0u.", this);
                }
            },
            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.SetColor end.*/

            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.SetColor$1 start.*/
            SetColor$1: function (_firstColor, _secondColor) {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.RopeMesh#SetColor$1", this ); }

                this.FirstHalfColor = _firstColor.$clone();
                this.SecondHalfColor = _secondColor.$clone();
                if (UnityEngine.Component.op_Inequality(this.meshRenderer, null)) {
                    var mat = this.meshRenderer.material;
                    var anyApplied = false;
                    if (mat.HasProperty(GogoGaga.OptimizedRopesAndCables.RopeMesh.TwoHalfColor1ID)) {
                        mat.SetColor(GogoGaga.OptimizedRopesAndCables.RopeMesh.TwoHalfColor1ID, this.FirstHalfColor);
                        anyApplied = true;
                    }
                    if (mat.HasProperty(GogoGaga.OptimizedRopesAndCables.RopeMesh.TwoHalfColor2ID)) {
                        mat.SetColor(GogoGaga.OptimizedRopesAndCables.RopeMesh.TwoHalfColor2ID, this.SecondHalfColor);
                        anyApplied = true;
                    }

                    if (!anyApplied) {
                        // Fallback: if special two-half properties don't exist, just blend single color (average) or first color
                        var fallback = pc.Color.lerp( this.FirstHalfColor, this.SecondHalfColor, 0.5 );
                        if (this.TrySetSingleColor(mat, fallback)) {
                            if (this.EnableDebugColorLogs) {
                                UnityEngine.Debug.Log$1(System.String.format("[RopeMesh] TwoHalf properties missing; d\u00f9ng m\u00e0u tr\u1ed9n {0} cho property '{1}'.", fallback.$clone(), this.lastColorPropertyUsed), this);
                            }
                        } else if (this.EnableDebugColorLogs) {
                            UnityEngine.Debug.LogWarning$1("[RopeMesh] Kh\u00f4ng c\u00f3 TwoHalf properties v\u00e0 c\u0169ng kh\u00f4ng c\u00f3 property m\u00e0u c\u01a1 b\u1ea3n trong material \u0111\u1ec3 fallback.", this);
                        }
                    } else if (this.EnableDebugColorLogs) {
                        UnityEngine.Debug.Log$1(System.String.format("[RopeMesh] Applied two-half colors {0} / {1}.", this.FirstHalfColor.$clone(), this.SecondHalfColor.$clone()), this);
                    }
                } else if (this.EnableDebugColorLogs) {
                    UnityEngine.Debug.LogWarning$1("[RopeMesh] meshRenderer null, kh\u00f4ng set \u0111\u01b0\u1ee3c hai m\u00e0u.", this);
                }
            },
            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.SetColor$1 end.*/

            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.TestRandomColor start.*/
            TestRandomColor: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.RopeMesh#TestRandomColor", this ); }

                this.SetColor(new pc.Color( UnityEngine.Random.value, UnityEngine.Random.value, UnityEngine.Random.value, 1 ));
            },
            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.TestRandomColor end.*/

            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.ReOffsetTextureTwoHalf start.*/
            ReOffsetTextureTwoHalf: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.RopeMesh#ReOffsetTextureTwoHalf", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.rope, null) || UnityEngine.Component.op_Equality(this.rope.EndPoint, null) || UnityEngine.Component.op_Equality(this.rope.StartPoint, null) || UnityEngine.Component.op_Equality(this.meshRenderer, null)) {
                    return;
                }

                var mat = this.meshRenderer.material;
                if (mat == null) {
                    return;
                }

                var currentDist = pc.Vec3.distance( this.rope.StartPoint.position, this.rope.EndPoint.position );
                var distRatio = this.ThresholdDistance > 0.0001 ? (currentDist / this.ThresholdDistance) : 0.0;
                var rsOffsetY = distRatio * this.ThresholdOffsetY;

                if (mat.HasProperty(GogoGaga.OptimizedRopesAndCables.RopeMesh.TwoHalfMaskSTID)) {
                    mat.SetVector(GogoGaga.OptimizedRopesAndCables.RopeMesh.TwoHalfMaskSTID, new pc.Vec4( 1.0, 1.0, 0.0, rsOffsetY ));
                } else if (this.EnableDebugColorLogs) {
                    UnityEngine.Debug.LogWarning$1("[RopeMesh] Material kh\u00f4ng c\u00f3 property _TwoHalfColorsMaskTex_ST \u0111\u1ec3 offset.", this);
                }
            },
            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.ReOffsetTextureTwoHalf end.*/

            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.SetColorGreen start.*/
            SetColorGreen: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.RopeMesh#SetColorGreen", this ); }

                this.SetColor(new pc.Color( 0, 1, 0, 1 ));
            },
            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.SetColorGreen end.*/

            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.SetColorRed start.*/
            SetColorRed: function () {
if ( TRACE ) { TRACE( "GogoGaga.OptimizedRopesAndCables.RopeMesh#SetColorRed", this ); }

                this.SetColor(new pc.Color( 1, 0, 0, 1 ));
            },
            /*GogoGaga.OptimizedRopesAndCables.RopeMesh.SetColorRed end.*/


        },
        overloads: {
            "SetColor(Color, Color)": "SetColor$1"
        }
    });
    /*GogoGaga.OptimizedRopesAndCables.RopeMesh end.*/

    /*Grid3DLayout start.*/
    Bridge.define("Grid3DLayout", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            columns: 0,
            spacing: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Grid3DLayout#init", this ); }

                this.columns = 3;
                this.spacing = 2.0;
            }
        },
        methods: {
            /*Grid3DLayout.ArrangeChildren start.*/
            ArrangeChildren: function () {
if ( TRACE ) { TRACE( "Grid3DLayout#ArrangeChildren", this ); }

                for (var i = 0; i < this.transform.childCount; i = (i + 1) | 0) {
                    var row = (Bridge.Int.div(i, this.columns)) | 0;
                    var col = i % this.columns;
                    this.transform.GetChild(i).localPosition = new pc.Vec3( col * this.spacing, ((-row) | 0) * this.spacing, 0.0 );
                }
            },
            /*Grid3DLayout.ArrangeChildren end.*/


        }
    });
    /*Grid3DLayout end.*/

    /*GridGenerator start.*/
    Bridge.define("GridGenerator", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            gridSize: null,
            BlockScale: null,
            pixelArrangeSpace: 0,
            YOffset: 0,
            pixelsParent: null,
            pixelMaterial: null,
            PrefabSource: null,
            AlreadyHave: null,
            paintingGridObject: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "GridGenerator#init", this ); }

                this.gridSize = new UnityEngine.Vector2();
                this.BlockScale = new UnityEngine.Vector3();
                this.gridSize = new pc.Vec2( 20, 40 );
                this.BlockScale = new pc.Vec3( 1, 1, 1 );
                this.pixelArrangeSpace = 1.0;
                this.YOffset = 0.0;
                this.AlreadyHave = new (System.Collections.Generic.List$1(PaintingGridObject)).ctor();
            }
        },
        methods: {
            /*GridGenerator.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "GridGenerator#Reset", this ); }

                // Default values when component is added
                this.gridSize = new pc.Vec2( 20, 40 ); // 20 columns, 40 rows
                this.BlockScale = new pc.Vec3( 1, 1, 1 );
                this.pixelArrangeSpace = 1.0;
            },
            /*GridGenerator.Reset end.*/

            /*GridGenerator.ContextGenerateGrid start.*/
            ContextGenerateGrid: function () {
if ( TRACE ) { TRACE( "GridGenerator#ContextGenerateGrid", this ); }

                this.GenerateGrid();
            },
            /*GridGenerator.ContextGenerateGrid end.*/

            /*GridGenerator.ContextClearGrid start.*/
            ContextClearGrid: function () {
if ( TRACE ) { TRACE( "GridGenerator#ContextClearGrid", this ); }

                this.ClearGrid();
            },
            /*GridGenerator.ContextClearGrid end.*/

            /*GridGenerator.GenerateGrid start.*/
            GenerateGrid: function () {
if ( TRACE ) { TRACE( "GridGenerator#GenerateGrid", this ); }

                this.paintingGridObject = null;
                // Create or get the grid object to use as parent for pixels
                var gridObj = null;

                if (UnityEngine.Component.op_Inequality(this.pixelsParent, null)) {
                    // Use the provided parent transform
                    gridObj = this.pixelsParent.gameObject;
                } else {
                    // Create a new GameObject to hold the pixels
                    gridObj = new UnityEngine.GameObject.$ctor2("PaintingGridObject");
                    gridObj.transform.SetParent(this.transform);
                    this.paintingGridObject = gridObj.AddComponent(PaintingGridObject);
                }

                // If the parent doesn't have the PaintingGridObject component, add it
                if (UnityEngine.MonoBehaviour.op_Equality(this.paintingGridObject, null)) {
                    this.paintingGridObject = gridObj.GetComponent(PaintingGridObject);
                    if (UnityEngine.MonoBehaviour.op_Equality(this.paintingGridObject, null)) {
                        this.paintingGridObject = gridObj.AddComponent(PaintingGridObject);
                    }
                }

                // Initialize the grid
                // csharp
                // Inside GenerateGrid(), replace the InitializeGrid call with:
                this.paintingGridObject.InitializeGrid(this.gridSize, this.pixelArrangeSpace, this.PrefabSource.DefaultBlockPrefab, this.BlockScale, this.PrefabSource, this.pixelMaterial);


                // Generate the grid using the PaintingGridObject component
                this.paintingGridObject.GenerateGrid(this.YOffset);

                this.AlreadyHave.add(this.paintingGridObject);
            },
            /*GridGenerator.GenerateGrid end.*/

            /*GridGenerator.ClearGrid start.*/
            ClearGrid: function () {
if ( TRACE ) { TRACE( "GridGenerator#ClearGrid", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.paintingGridObject, null)) {
                    this.paintingGridObject.DestroyAllPixelsObjects();
                }
            },
            /*GridGenerator.ClearGrid end.*/

            /*GridGenerator.GetTotalPixels start.*/
            GetTotalPixels: function () {
if ( TRACE ) { TRACE( "GridGenerator#GetTotalPixels", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.paintingGridObject, null)) {
                    return this.paintingGridObject.GetTotalPixels();
                }
                return 0;
            },
            /*GridGenerator.GetTotalPixels end.*/


        }
    });
    /*GridGenerator end.*/

    /*HelperCoroutine start.*/
    Bridge.define("HelperCoroutine", {
        statics: {
            fields: {
                MAX_CACHE_SIZE: 0,
                _waitForSeconds: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "HelperCoroutine#init", this ); }

                    this.MAX_CACHE_SIZE = 120;
                    this._waitForSeconds = new (System.Collections.Generic.Dictionary$2(System.Single,UnityEngine.WaitForSeconds)).ctor();
                }
            },
            methods: {
                /*HelperCoroutine.WaitSeconds:static start.*/
                WaitSeconds: function (seconds) {
if ( TRACE ) { TRACE( "HelperCoroutine#WaitSeconds", this ); }

                    var wait = { };
                    if (!HelperCoroutine._waitForSeconds.tryGetValue(seconds, wait)) {
                        wait.v = new UnityEngine.WaitForSeconds(seconds);
                        HelperCoroutine._waitForSeconds.setItem(seconds, wait.v);

                        // Prevent memory leak by limiting cache size
                        if (HelperCoroutine._waitForSeconds.Count > HelperCoroutine.MAX_CACHE_SIZE) {
                            HelperCoroutine._waitForSeconds.clear();
                        }
                    }
                    return wait.v;
                },
                /*HelperCoroutine.WaitSeconds:static end.*/

                /*HelperCoroutine.ClearCache:static start.*/
                /**
                 * Clear the cached WaitForSeconds objects to free memory
                 *
                 * @static
                 * @public
                 * @this HelperCoroutine
                 * @memberof HelperCoroutine
                 * @return  {void}
                 */
                ClearCache: function () {
if ( TRACE ) { TRACE( "HelperCoroutine#ClearCache", this ); }

                    HelperCoroutine._waitForSeconds.clear();
                },
                /*HelperCoroutine.ClearCache:static end.*/

                /*HelperCoroutine.DelaySeconds:static start.*/
                DelaySeconds: function (mono, seconds, callback) {
if ( TRACE ) { TRACE( "HelperCoroutine#DelaySeconds", this ); }

                    if (UnityEngine.MonoBehaviour.op_Equality(mono, null) || Bridge.staticEquals(callback, null) || !mono.gameObject.activeInHierarchy) {
                        return;
                    } // Don't start coroutine if GameObject is inactive

                    mono.StartCoroutine$1(HelperCoroutine.DelayCall$1(seconds, callback));
                },
                /*HelperCoroutine.DelaySeconds:static end.*/

                /*HelperCoroutine.DelayFrames:static start.*/
                DelayFrames: function (mono, frames, callback) {
if ( TRACE ) { TRACE( "HelperCoroutine#DelayFrames", this ); }

                    if (UnityEngine.MonoBehaviour.op_Equality(mono, null) || Bridge.staticEquals(callback, null) || !mono.gameObject.activeInHierarchy) {
                        return;
                    } // Don't start coroutine if GameObject is inactive

                    mono.StartCoroutine$1(HelperCoroutine.DelayCall(frames, callback));
                },
                /*HelperCoroutine.DelayFrames:static end.*/

                /*HelperCoroutine.RunOnSeconds:static start.*/
                RunOnSeconds: function (mono, seconds, callback) {
if ( TRACE ) { TRACE( "HelperCoroutine#RunOnSeconds", this ); }

                    if (UnityEngine.MonoBehaviour.op_Equality(mono, null) || Bridge.staticEquals(callback, null) || !mono.gameObject.activeInHierarchy) {
                        return;
                    } // Don't start coroutine if GameObject is inactive

                    mono.StartCoroutine$1(HelperCoroutine.RunCall$1(seconds, callback));
                },
                /*HelperCoroutine.RunOnSeconds:static end.*/

                /*HelperCoroutine.RunOnFrames:static start.*/
                RunOnFrames: function (mono, frames, callback) {
if ( TRACE ) { TRACE( "HelperCoroutine#RunOnFrames", this ); }

                    if (UnityEngine.MonoBehaviour.op_Equality(mono, null) || Bridge.staticEquals(callback, null) || !mono.gameObject.activeInHierarchy) {
                        return;
                    } // Don't start coroutine if GameObject is inactive

                    mono.StartCoroutine$1(HelperCoroutine.RunCall(frames, callback));
                },
                /*HelperCoroutine.RunOnFrames:static end.*/

                /*HelperCoroutine.DelayCall$1:static start.*/
                DelayCall$1: function (seconds, callback) {
if ( TRACE ) { TRACE( "HelperCoroutine#DelayCall$1", this ); }

                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        $async_e;

                    var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        $enumerator.current = HelperCoroutine.WaitSeconds(seconds);
                                            $step = 1;
                                            return true;
                                    }
                                    case 1: {
                                        callback();

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                },
                /*HelperCoroutine.DelayCall$1:static end.*/

                /*HelperCoroutine.DelayCall:static start.*/
                DelayCall: function (frames, callback) {
if ( TRACE ) { TRACE( "HelperCoroutine#DelayCall", this ); }

                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        i,
                        $async_e;

                    var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        i = 0;
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( i < frames ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 5;
                                        continue;
                                    }
                                    case 2: {
                                        $enumerator.current = null;
                                            $step = 3;
                                            return true;
                                    }
                                    case 3: {
                                        $step = 4;
                                        continue;
                                    }
                                    case 4: {
                                        i = (i + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 5: {
                                        callback();

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                },
                /*HelperCoroutine.DelayCall:static end.*/

                /*HelperCoroutine.RunCall$1:static start.*/
                RunCall$1: function (seconds, callback) {
if ( TRACE ) { TRACE( "HelperCoroutine#RunCall$1", this ); }

                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        time,
                        $async_e;

                    var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        time = 0.0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 1: {
                                        if ( time < seconds ) {
                                                $step = 2;
                                                continue;
                                            } 
                                            $step = 4;
                                            continue;
                                    }
                                    case 2: {
                                        time += UnityEngine.Time.deltaTime;
                                            callback();
                                            $enumerator.current = null;
                                            $step = 3;
                                            return true;
                                    }
                                    case 3: {
                                        
                                            $step = 1;
                                            continue;
                                    }
                                    case 4: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                },
                /*HelperCoroutine.RunCall$1:static end.*/

                /*HelperCoroutine.RunCall:static start.*/
                RunCall: function (frames, callback) {
if ( TRACE ) { TRACE( "HelperCoroutine#RunCall", this ); }

                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        i,
                        $async_e;

                    var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        i = 0;
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( i < frames ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 5;
                                        continue;
                                    }
                                    case 2: {
                                        callback();
                                            $enumerator.current = null;
                                            $step = 3;
                                            return true;
                                    }
                                    case 3: {
                                        $step = 4;
                                        continue;
                                    }
                                    case 4: {
                                        i = (i + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 5: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                },
                /*HelperCoroutine.RunCall:static end.*/


            }
        }
    });
    /*HelperCoroutine end.*/

    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty start.*/
    Bridge.define("IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty", {
        inherits: [UnityEngine.MonoBehaviour]
    });
    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty end.*/

    /*IdleMoveUpDown start.*/
    Bridge.define("IdleMoveUpDown", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            target: null,
            moveAmount: 0,
            duration: 0,
            ease: 0,
            moveTween: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "IdleMoveUpDown#init", this ); }

                this.moveAmount = 0.2;
                this.duration = 0.5;
                this.ease = DG.Tweening.Ease.InOutSine;
            }
        },
        methods: {
            /*IdleMoveUpDown.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "IdleMoveUpDown#Awake", this ); }

                this.CreateMoveTween();
            },
            /*IdleMoveUpDown.Awake end.*/

            /*IdleMoveUpDown.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "IdleMoveUpDown#OnDisable", this ); }

                this.StopTween();
            },
            /*IdleMoveUpDown.OnDisable end.*/

            /*IdleMoveUpDown.CreateMoveTween start.*/
            CreateMoveTween: function () {
if ( TRACE ) { TRACE( "IdleMoveUpDown#CreateMoveTween", this ); }

                if (UnityEngine.Component.op_Equality(this.target, null)) {
                    this.target = this.transform;
                }

                var startPos = this.target.localPosition.$clone();
                var upPos = startPos.$clone().add( new pc.Vec3( 0.0, this.moveAmount, 0.0 ) );

                this.moveTween = DG.Tweening.TweenSettingsExtensions.SetAutoKill$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenExtensions.Pause(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOLocalMoveY(this.target, upPos.y, this.duration), this.ease), -1, DG.Tweening.LoopType.Yoyo)), false);
            },
            /*IdleMoveUpDown.CreateMoveTween end.*/

            /*IdleMoveUpDown.PlayTween start.*/
            PlayTween: function () {
if ( TRACE ) { TRACE( "IdleMoveUpDown#PlayTween", this ); }

                DG.Tweening.TweenExtensions.Play(DG.Tweening.Tween, this.moveTween);
            },
            /*IdleMoveUpDown.PlayTween end.*/

            /*IdleMoveUpDown.StopTween start.*/
            StopTween: function () {
if ( TRACE ) { TRACE( "IdleMoveUpDown#StopTween", this ); }

                DG.Tweening.TweenExtensions.Pause(DG.Tweening.Tween, this.moveTween);
            },
            /*IdleMoveUpDown.StopTween end.*/


        }
    });
    /*IdleMoveUpDown end.*/

    /*IdleRotate start.*/
    Bridge.define("IdleRotate", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            Active: false,
            target: null,
            rotationSpeed: null,
            frameInterval: 0,
            frameCounter: 0,
            temporarySpeedBoost: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "IdleRotate#init", this ); }

                this.rotationSpeed = new UnityEngine.Vector3();
                this.rotationSpeed = new pc.Vec3( 0, 90.0, 0 );
                this.frameInterval = 1;
                this.frameCounter = 0;
                this.temporarySpeedBoost = 1;
            }
        },
        methods: {
            /*IdleRotate.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "IdleRotate#OnEnable", this ); }

                this.frameCounter = 0;
                this.temporarySpeedBoost = 1;
            },
            /*IdleRotate.OnEnable end.*/

            /*IdleRotate.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "IdleRotate#Update", this ); }

                if (!this.Active) {
                    return;
                }

                this.frameCounter = (this.frameCounter + 1) | 0;

                if (this.frameCounter >= this.frameInterval) {
                    var delta = UnityEngine.Time.deltaTime;
                    this.target.Rotate$2(this.rotationSpeed.$clone().clone().scale( delta ).clone().scale( this.temporarySpeedBoost ), UnityEngine.Space.Self);

                    this.frameCounter = 0;
                }
            },
            /*IdleRotate.Update end.*/

            /*IdleRotate.StartRotate start.*/
            StartRotate: function () {
if ( TRACE ) { TRACE( "IdleRotate#StartRotate", this ); }

                this.Active = true;
            },
            /*IdleRotate.StartRotate end.*/

            /*IdleRotate.StopRotate start.*/
            StopRotate: function () {
if ( TRACE ) { TRACE( "IdleRotate#StopRotate", this ); }

                this.Active = false;
            },
            /*IdleRotate.StopRotate end.*/

            /*IdleRotate.BoostSpeed start.*/
            BoostSpeed: function (speed) {
if ( TRACE ) { TRACE( "IdleRotate#BoostSpeed", this ); }

                this.temporarySpeedBoost = speed;
            },
            /*IdleRotate.BoostSpeed end.*/


        }
    });
    /*IdleRotate end.*/

    /*InGameEffectOptions start.*/
    Bridge.define("InGameEffectOptions", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            BulletSpeed: 0,
            BulletScale: 0,
            ChangeBulletColor: false,
            ChangeOutlineColor: false,
            IdleRate: 0,
            RabbitRandomIdleAnimation: false,
            RabbitEarAnimation: false,
            ShakeNeighborBlocks: false,
            ShakeValue: 0,
            BlockScaleFactorWhenDestroyed: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "InGameEffectOptions#init", this ); }

                this.BulletSpeed = 25.0;
                this.BulletScale = 1.0;
                this.ChangeBulletColor = true;
                this.ChangeOutlineColor = false;
                this.IdleRate = 50;
                this.RabbitRandomIdleAnimation = true;
                this.RabbitEarAnimation = true;
                this.ShakeNeighborBlocks = true;
                this.ShakeValue = 20;
                this.BlockScaleFactorWhenDestroyed = 1.5;
            }
        }
    });
    /*InGameEffectOptions end.*/

    /*InputManager start.*/
    Bridge.define("InputManager", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            clickCooldown: 0,
            lastClickTime: 0,
            gamePlayCamera: null,
            BlockInput: false,
            IsChoosingBlock: false,
            IsFreePicking: false,
            CubeLayermask: null,
            cachedRay: null,
            cachedMousePosition: null,
            collectorLayerMask: 0,
            hitInfo: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "InputManager#init", this ); }

                this.CubeLayermask = new UnityEngine.LayerMask();
                this.cachedRay = new UnityEngine.Ray();
                this.cachedMousePosition = new UnityEngine.Vector3();
                this.hitInfo = new UnityEngine.RaycastHit();
                this.lastClickTime = -10.0;
                this.BlockInput = false;
                this.IsChoosingBlock = false;
                this.IsFreePicking = false;
            }
        },
        methods: {
            /*InputManager.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "InputManager#Awake", this ); }

                // Cache layer mask  trnh tnh ton mi frame
                this.collectorLayerMask = 4096;
                this.UnBlockGameplayInput();
                GameplayEventsManager.OnBlockGamePlayInput = Bridge.fn.combine(GameplayEventsManager.OnBlockGamePlayInput, Bridge.fn.bind(this, function (block) {
                    this.BlockInput = block;
                }));
            },
            /*InputManager.Awake end.*/

            /*InputManager.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "InputManager#OnDestroy", this ); }

                GameplayEventsManager.OnBlockGamePlayInput = Bridge.fn.remove(GameplayEventsManager.OnBlockGamePlayInput, Bridge.fn.bind(this, function (block) {
                    this.BlockInput = block;
                }));
            },
            /*InputManager.OnDestroy end.*/

            /*InputManager.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "InputManager#Update", this ); }

                if (this.IsChoosingBlock) {
                    this.HandleSuperRabbitBoosterInput();
                }

                if (!this.BlockInput) {
                    this.HandleCollectorChoosenInput();
                }

                if (this.IsFreePicking) {
                    this.HandleBoosterCollectorChoosenInput();
                }
            },
            /*InputManager.Update end.*/

            /*InputManager.CanProcessInput start.*/
            CanProcessInput: function () {
if ( TRACE ) { TRACE( "InputManager#CanProcessInput", this ); }

                if (this.BlockInput) {
                    return false;
                }
                if (UnityEngine.Time.time - this.lastClickTime < this.clickCooldown) {
                    return false;
                }

                this.lastClickTime = UnityEngine.Time.time;
                return true;
            },
            /*InputManager.CanProcessInput end.*/

            /*InputManager.PerformRaycast start.*/
            PerformRaycast: function (screenPoint, mask) {
if ( TRACE ) { TRACE( "InputManager#PerformRaycast", this ); }

                this.cachedRay = this.gamePlayCamera.ScreenPointToRay(screenPoint);

                if (UnityEngine.Physics.Raycast$1(this.cachedRay, Bridge.ref(this, "hitInfo"), 100.0, UnityEngine.LayerMask.op_Implicit(mask.$clone()))) {
                    return this.hitInfo.$clone();
                }
                return null;
            },
            /*InputManager.PerformRaycast end.*/

            /*InputManager.HandleCollectorChoosenInput start.*/
            HandleCollectorChoosenInput: function () {
if ( TRACE ) { TRACE( "InputManager#HandleCollectorChoosenInput", this ); }

                if (UnityEngine.Input.GetMouseButtonDown(0)) {
                    if (!this.CanProcessInput()) {
                        return;
                    }

                    var inputPos = UnityEngine.Input.mousePosition.$clone();
                    var hit = this.PerformRaycast(inputPos, UnityEngine.LayerMask.op_Implicit$1(this.collectorLayerMask));

                    if (System.Nullable.hasValue(hit)) {
                        var collector = System.Nullable.getValue(hit).collider.GetComponent(CollectorController);
                        if (UnityEngine.MonoBehaviour.op_Inequality(collector, null)) {
                            CollectorGameManager.Instance.RequestMoveCollector(collector);
                        }
                    }
                }
            },
            /*InputManager.HandleCollectorChoosenInput end.*/

            /*InputManager.HandleBoosterCollectorChoosenInput start.*/
            HandleBoosterCollectorChoosenInput: function () {
if ( TRACE ) { TRACE( "InputManager#HandleBoosterCollectorChoosenInput", this ); }

                if (UnityEngine.Input.GetMouseButtonDown(0)) {
                    if (!this.CanProcessInput()) {
                        return;
                    }

                    var inputPos = UnityEngine.Input.mousePosition.$clone();
                    var hit = this.PerformRaycast(inputPos, UnityEngine.LayerMask.op_Implicit$1(this.collectorLayerMask));

                    if (System.Nullable.hasValue(hit)) {
                        var collector = System.Nullable.getValue(hit).collider.GetComponent(CollectorController);
                        if (UnityEngine.MonoBehaviour.op_Inequality(collector, null)) {
                            CollectorGameManager.Instance.ForceMoveCollector(collector);
                            !Bridge.staticEquals(GameplayEventsManager.OnFreePickACollector, null) ? GameplayEventsManager.OnFreePickACollector(collector) : null;
                            return;
                        }
                    }
                }
            },
            /*InputManager.HandleBoosterCollectorChoosenInput end.*/

            /*InputManager.HandleSuperRabbitBoosterInput start.*/
            HandleSuperRabbitBoosterInput: function () {
if ( TRACE ) { TRACE( "InputManager#HandleSuperRabbitBoosterInput", this ); }

                if (UnityEngine.Input.GetMouseButtonDown(0)) {
                    var inputPos = UnityEngine.Input.mousePosition.$clone();
                    var hit = this.PerformRaycast(inputPos, this.CubeLayermask);

                    if (System.Nullable.hasValue(hit)) {
                        var paintingPixel = System.Nullable.getValue(hit).collider.GetComponent(PaintingPixelComponent);
                        if (UnityEngine.MonoBehaviour.op_Inequality(paintingPixel, null)) {
                            !Bridge.staticEquals(GameplayEventsManager.OnSuperRabbitBlockSelected, null) ? GameplayEventsManager.OnSuperRabbitBlockSelected(paintingPixel.PixelData.colorCode) : null;
                            return;
                        }

                        var wallObject = System.Nullable.getValue(hit).collider.transform.parent.GetComponent(WallObject);
                        if (UnityEngine.MonoBehaviour.op_Inequality(wallObject, null)) {
                            !Bridge.staticEquals(GameplayEventsManager.OnSuperRabbitBlockSelected, null) ? GameplayEventsManager.OnSuperRabbitBlockSelected(wallObject.ColorCode) : null;
                            return;
                        }
                    }
                }
            },
            /*InputManager.HandleSuperRabbitBoosterInput end.*/

            /*InputManager.UpdateLastClickTime start.*/
            UpdateLastClickTime: function () {
if ( TRACE ) { TRACE( "InputManager#UpdateLastClickTime", this ); }

                this.lastClickTime = UnityEngine.Time.time;
            },
            /*InputManager.UpdateLastClickTime end.*/

            /*InputManager.BlockGameplayInput start.*/
            BlockGameplayInput: function () {
if ( TRACE ) { TRACE( "InputManager#BlockGameplayInput", this ); }

                this.BlockInput = true;
            },
            /*InputManager.BlockGameplayInput end.*/

            /*InputManager.UnBlockGameplayInput start.*/
            UnBlockGameplayInput: function () {
if ( TRACE ) { TRACE( "InputManager#UnBlockGameplayInput", this ); }

                this.BlockInput = false;
            },
            /*InputManager.UnBlockGameplayInput end.*/

            /*InputManager.StartAllowPlayerToChooseBlock start.*/
            StartAllowPlayerToChooseBlock: function () {
if ( TRACE ) { TRACE( "InputManager#StartAllowPlayerToChooseBlock", this ); }

                this.IsChoosingBlock = true;
            },
            /*InputManager.StartAllowPlayerToChooseBlock end.*/

            /*InputManager.StopAllowPlayerToChooseBlock start.*/
            StopAllowPlayerToChooseBlock: function () {
if ( TRACE ) { TRACE( "InputManager#StopAllowPlayerToChooseBlock", this ); }

                this.IsChoosingBlock = false;
            },
            /*InputManager.StopAllowPlayerToChooseBlock end.*/

            /*InputManager.StartAllowPlayerToFreelyPick start.*/
            StartAllowPlayerToFreelyPick: function () {
if ( TRACE ) { TRACE( "InputManager#StartAllowPlayerToFreelyPick", this ); }

                this.IsFreePicking = true;
            },
            /*InputManager.StartAllowPlayerToFreelyPick end.*/

            /*InputManager.StopAllowPlayerToFreePick start.*/
            StopAllowPlayerToFreePick: function () {
if ( TRACE ) { TRACE( "InputManager#StopAllowPlayerToFreePick", this ); }

                this.IsFreePicking = false;
            },
            /*InputManager.StopAllowPlayerToFreePick end.*/


        }
    });
    /*InputManager end.*/

    /*KeyObject start.*/
    Bridge.define("KeyObject", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            KeyTransform: null,
            PaintingPixelsCovered: null,
            BorderPixels: null,
            KeyRenderer: null,
            Rotating: null,
            IdleMoving: null,
            CollectedFX: null,
            TwinkleFX: null,
            KeyAudioSource: null,
            CollectedSoundFX: null,
            KeyFlySoundFX: null,
            CurrentState: 0
        },
        props: {
            Locked: {
                get: function () {
if ( TRACE ) { TRACE( "KeyObject#Locked#get", this ); }

                    return this.CurrentState === KeyObject.KeyState.Locked;
                }
            },
            Collected: {
                get: function () {
if ( TRACE ) { TRACE( "KeyObject#Collected#get", this ); }

                    return this.CurrentState === KeyObject.KeyState.Collected;
                }
            },
            ReadyToCollected: {
                get: function () {
if ( TRACE ) { TRACE( "KeyObject#ReadyToCollected#get", this ); }

                    return this.CurrentState === KeyObject.KeyState.ReadyToCollect;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "KeyObject#init", this ); }

                this.CurrentState = KeyObject.KeyState.Locked;
            }
        },
        methods: {
            /*KeyObject.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "KeyObject#Awake", this ); }

                GameplayEventsManager.OnGridObjectChanged = Bridge.fn.combine(GameplayEventsManager.OnGridObjectChanged, Bridge.fn.cacheBind(this, this.OnGridChange));
            },
            /*KeyObject.Awake end.*/

            /*KeyObject.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "KeyObject#OnDestroy", this ); }

                GameplayEventsManager.OnGridObjectChanged = Bridge.fn.remove(GameplayEventsManager.OnGridObjectChanged, Bridge.fn.cacheBind(this, this.OnGridChange));
            },
            /*KeyObject.OnDestroy end.*/

            /*KeyObject.OnGridChange start.*/
            OnGridChange: function (gridObject) {
if ( TRACE ) { TRACE( "KeyObject#OnGridChange", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.BorderPixels);
                try {
                    while ($t.moveNext()) {
                        var pixel = $t.Current.$clone();
                        if (gridObject.IsPixelDestroyed(Bridge.Int.clip32(pixel.x), Bridge.Int.clip32(pixel.y))) {
                            this.OnAPixelBorderDestroyed();
                            return;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*KeyObject.OnGridChange end.*/

            /*KeyObject.Initialize start.*/
            /**
             * Initialize the pipe structure with head and body parts
             *
             * @instance
             * @public
             * @this KeyObject
             * @memberof KeyObject
             * @param   {System.Collections.Generic.List$1}    pipePixels
             * @return  {void}
             */
            Initialize: function (pipePixels) {
if ( TRACE ) { TRACE( "KeyObject#Initialize", this ); }

                this.CurrentState = KeyObject.KeyState.Locked;
                this.PaintingPixelsCovered = pipePixels || new (System.Collections.Generic.List$1(PaintingPixel)).ctor();
                this.BorderPixels = new (System.Collections.Generic.List$1(UnityEngine.Vector2)).ctor();
                this.Rotating.StartRotate();
                this.IdleMoving.PlayTween();
                this.TwinkleFX.Play();
            },
            /*KeyObject.Initialize end.*/

            /*KeyObject.OnAPixelBorderDestroyed start.*/
            OnAPixelBorderDestroyed: function () {
if ( TRACE ) { TRACE( "KeyObject#OnAPixelBorderDestroyed", this ); }

                if (this.Collected) {
                    return;
                }
                this.CurrentState = KeyObject.KeyState.ReadyToCollect;
                !Bridge.staticEquals(GameplayEventsManager.OnAKeyReadyToBeCollected, null) ? GameplayEventsManager.OnAKeyReadyToBeCollected() : null;
            },
            /*KeyObject.OnAPixelBorderDestroyed end.*/

            /*KeyObject.OnCollectedByLock start.*/
            OnCollectedByLock: function (_unlocker) {
if ( TRACE ) { TRACE( "KeyObject#OnCollectedByLock", this ); }

                _unlocker.LockController.Unlock();
                this.CurrentState = KeyObject.KeyState.Collected;
                for (var i = 0; i < this.PaintingPixelsCovered.Count; i = (i + 1) | 0) {
                    this.PaintingPixelsCovered.getItem(i).DestroyPixel(false, void 0);
                }
                this.OnCollected(_unlocker);
                !Bridge.staticEquals(GameplayEventsManager.OnCollectAKey, null) ? GameplayEventsManager.OnCollectAKey() : null;
            },
            /*KeyObject.OnCollectedByLock end.*/

            /*KeyObject.OnCollected start.*/
            OnCollected: function (_locker) {
if ( TRACE ) { TRACE( "KeyObject#OnCollected", this ); }

                //TODO: Add collected animation
                this.TwinkleFX.Stop();
                this.CollectedFX.Play();
                this.Rotating.BoostSpeed(25);
                this.KeyAudioSource.PlayOneShot(this.CollectedSoundFX);
                var _unlockTween = DG.Tweening.DOTween.Sequence();
                DG.Tweening.TweenSettingsExtensions.Append(_unlockTween, DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMoveY(this.KeyTransform, this.KeyTransform.position.y + 2, 1.5), Bridge.fn.bind(this, function () {
                    this.KeyAudioSource.PlayOneShot(this.KeyFlySoundFX);
                })));
                DG.Tweening.TweenSettingsExtensions.Append(_unlockTween, DG.Tweening.ShortcutExtensions.DOMove(this.KeyTransform, _locker.transform.position.$clone(), 0.8));
                DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Sequence, _unlockTween, Bridge.fn.bind(this, function () {
                    _locker.LockController.UnlockWithVisual();
                    this.KeyRenderer.enabled = false;
                    this.Rotating.StopRotate();
                    this.IdleMoving.StopTween();
                }));

            },
            /*KeyObject.OnCollected end.*/

            /*KeyObject.SelfDestroy start.*/
            SelfDestroy: function () {
if ( TRACE ) { TRACE( "KeyObject#SelfDestroy", this ); }

                if (UnityEngine.Application.isPlaying) {
                    UnityEngine.Object.Destroy(this.gameObject);
                } else {
                    UnityEngine.Object.DestroyImmediate(this.gameObject);
                }
            },
            /*KeyObject.SelfDestroy end.*/

            /*KeyObject.BorderContains start.*/
            BorderContains: function (_pixel) {
if ( TRACE ) { TRACE( "KeyObject#BorderContains", this ); }

                return System.Linq.Enumerable.from(this.BorderPixels, UnityEngine.Vector2).any(function (x) {
                        return x.x === _pixel.column && x.y === _pixel.row;
                    });
            },
            /*KeyObject.BorderContains end.*/


        }
    });
    /*KeyObject end.*/

    /*KeyObject+KeyState start.*/
    Bridge.define("KeyObject.KeyState", {
        $kind: 1006,
        statics: {
            fields: {
                Locked: 0,
                ReadyToCollect: 1,
                Collected: 2
            }
        }
    });
    /*KeyObject+KeyState end.*/

    /*KeyObjectConfigSetup start.*/
    /**
     * Helper method to validate pipe orientation using PaintingPixelComponents
     * Import all pipe configurations from this setup to a PaintingConfig asset
     *
     * @public
     * @class KeyObjectConfigSetup
     * @augments UnityEngine.MonoBehaviour
     * @return  {[type]}        True if pipe orientation is valid, false otherwise
     */
    Bridge.define("KeyObjectConfigSetup", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            PaintingSetupModule: null,
            CurrentLevelKeyObjectSetups: null,
            keyObjectSetups: null,
            KeyPixelComponents: null
        },
        methods: {
            /*KeyObjectConfigSetup.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "KeyObjectConfigSetup#Awake", this ); }

                if (this.keyObjectSetups == null) {
                    this.keyObjectSetups = new (System.Collections.Generic.List$1(KeyObjectSetup)).ctor();
                }
            },
            /*KeyObjectConfigSetup.Awake end.*/

            /*KeyObjectConfigSetup.AddKeySetup start.*/
            /**
             * Add a pipe setup to the list
             *
             * @instance
             * @public
             * @this KeyObjectConfigSetup
             * @memberof KeyObjectConfigSetup
             * @param   {KeyObjectSetup}    keySetup    The pipe setup to add
             * @return  {void}
             */
            AddKeySetup: function (keySetup) {
if ( TRACE ) { TRACE( "KeyObjectConfigSetup#AddKeySetup", this ); }

                if (this.keyObjectSetups == null) {
                    this.keyObjectSetups = new (System.Collections.Generic.List$1(KeyObjectSetup)).ctor();
                }
                if (keySetup != null && !this.keyObjectSetups.contains(keySetup)) {
                    this.keyObjectSetups.add(keySetup);
                }
            },
            /*KeyObjectConfigSetup.AddKeySetup end.*/

            /*KeyObjectConfigSetup.RemoveKeySetup start.*/
            /**
             * Remove a pipe setup from the list
             *
             * @instance
             * @public
             * @this KeyObjectConfigSetup
             * @memberof KeyObjectConfigSetup
             * @param   {KeyObjectSetup}    keySetup    The key setup to remove
             * @return  {void}
             */
            RemoveKeySetup: function (keySetup) {
if ( TRACE ) { TRACE( "KeyObjectConfigSetup#RemoveKeySetup", this ); }

                if (keySetup != null) {
                    this.keyObjectSetups.remove(keySetup);
                }
            },
            /*KeyObjectConfigSetup.RemoveKeySetup end.*/

            /*KeyObjectConfigSetup.RemoveKeyObjectAndItConfig start.*/
            RemoveKeyObjectAndItConfig: function (_keyObject, save) {
if ( TRACE ) { TRACE( "KeyObjectConfigSetup#RemoveKeyObjectAndItConfig", this ); }

                if (this.PaintingSetupModule.CurrentGridObject.KeyObjects != null && this.PaintingSetupModule.CurrentGridObject.KeyObjects.Count > 0) {
                    this.PaintingSetupModule.CurrentGridObject.RemoveKeyObject(_keyObject);

                    var _keySetupConfig = this.PaintingSetupModule.CurrentPaintingConfig.GetKeySetup(_keyObject.PaintingPixelsCovered.getItem(0), _keyObject.PaintingPixelsCovered.getItem(((_keyObject.PaintingPixelsCovered.Count - 1) | 0)));
                    if (_keySetupConfig != null) {
                        this.PaintingSetupModule.CurrentPaintingConfig.KeySetups.remove(_keySetupConfig);
                        this.RemoveKeySetup(_keySetupConfig);
                        if (save) {
                            this.PaintingSetupModule.Save();
                        }

                    }
                }
            },
            /*KeyObjectConfigSetup.RemoveKeyObjectAndItConfig end.*/

            /*KeyObjectConfigSetup.RemoveKeyObjectAndItConfig$1 start.*/
            RemoveKeyObjectAndItConfig$1: function (_keySetup, save) {
if ( TRACE ) { TRACE( "KeyObjectConfigSetup#RemoveKeyObjectAndItConfig$1", this ); }

                if (this.PaintingSetupModule.CurrentGridObject.KeyObjects != null && this.PaintingSetupModule.CurrentGridObject.KeyObjects.Count > 0) {
                    this.PaintingSetupModule.CurrentGridObject.RemoveKeyObject$1(_keySetup);

                    if (_keySetup != null) {
                        this.PaintingSetupModule.CurrentPaintingConfig.KeySetups.remove(_keySetup);
                        this.RemoveKeySetup(_keySetup);
                        if (save) {
                            this.PaintingSetupModule.Save();
                        }

                    }
                }
            },
            /*KeyObjectConfigSetup.RemoveKeyObjectAndItConfig$1 end.*/

            /*KeyObjectConfigSetup.ClearKeySetups start.*/
            /**
             * Clear all key setups
             *
             * @instance
             * @public
             * @this KeyObjectConfigSetup
             * @memberof KeyObjectConfigSetup
             * @return  {void}
             */
            ClearKeySetups: function () {
if ( TRACE ) { TRACE( "KeyObjectConfigSetup#ClearKeySetups", this ); }

                this.keyObjectSetups.clear();
            },
            /*KeyObjectConfigSetup.ClearKeySetups end.*/

            /*KeyObjectConfigSetup.ClearAllKeySetups start.*/
            ClearAllKeySetups: function () {
if ( TRACE ) { TRACE( "KeyObjectConfigSetup#ClearAllKeySetups", this ); }

                var $t;
                this.ClearKeySetups();

                // Also clear key objects from the grid if they exist
                if (UnityEngine.MonoBehaviour.op_Inequality(this.PaintingSetupModule.CurrentGridObject, null) && this.PaintingSetupModule.CurrentGridObject.KeyObjects != null) {
                    // Destroy the key gameobjects
                    var currentKeys = new (System.Collections.Generic.List$1(KeyObject)).$ctor1(this.PaintingSetupModule.CurrentGridObject.KeyObjects);
                    $t = Bridge.getEnumerator(currentKeys);
                    try {
                        while ($t.moveNext()) {
                            var keyObj = $t.Current;
                            this.PaintingSetupModule.CurrentGridObject.RemoveKeyObject(keyObj);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    this.PaintingSetupModule.CurrentGridObject.KeyObjects.clear();
                }

            },
            /*KeyObjectConfigSetup.ClearAllKeySetups end.*/

            /*KeyObjectConfigSetup.CreateKey$1 start.*/
            /**
             * Create a key between StartPixel and EndPixel based on current settings
             *
             * @instance
             * @public
             * @this KeyObjectConfigSetup
             * @memberof KeyObjectConfigSetup
             * @return  {void}
             */
            CreateKey$1: function () {
if ( TRACE ) { TRACE( "KeyObjectConfigSetup#CreateKey$1", this ); }

                var $t;
                this.keyObjectSetups = new (System.Collections.Generic.List$1(KeyObjectSetup)).$ctor1(this.CurrentLevelKeyObjectSetups);
                if (this.KeyPixelComponents == null || this.KeyPixelComponents.Count <= 0) {
                    UnityEngine.Debug.LogWarning$1("KeyPixelComponents is not valid. Cannot create key.");
                    return;
                }

                // Validate that the key should be straight (horizontal or vertical)
                if (!this.IsValidKeyOrientation$1(this.KeyPixelComponents)) {
                    UnityEngine.Debug.LogWarning$1("Key must be either horizontal (same row) or vertical (same column). Cannot create key.");
                    return;
                }

                // Create and setup the key in the scene - this will also create the key pixels
                var keyPixelConfigs = new (System.Collections.Generic.List$1(PaintingPixelConfig)).ctor();
                $t = Bridge.getEnumerator(this.KeyPixelComponents);
                try {
                    while ($t.moveNext()) {
                        var pixelComponent = $t.Current;
                        keyPixelConfigs.add(new PaintingPixelConfig.$ctor1(pixelComponent.PixelData));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                var keySetup = new KeyObjectSetup.$ctor2(keyPixelConfigs);

                var newKeyObject = this.SetupNewKeyInScene(keySetup);

                if (UnityEngine.MonoBehaviour.op_Inequality(newKeyObject, null)) {
                    this.AddKeySetup(keySetup);
                }
            },
            /*KeyObjectConfigSetup.CreateKey$1 end.*/

            /*KeyObjectConfigSetup.CreateKey start.*/
            CreateKey: function (_startPixel, _endPixel) {
if ( TRACE ) { TRACE( "KeyObjectConfigSetup#CreateKey", this ); }

                var $t;
                this.keyObjectSetups = new (System.Collections.Generic.List$1(KeyObjectSetup)).$ctor1(this.CurrentLevelKeyObjectSetups);
                if (_startPixel == null || _endPixel == null) {
                    UnityEngine.Debug.LogWarning$1("KeyPixelComponents is not valid. Cannot create key.");
                    return null;
                }

                var _listBlocks = new (System.Collections.Generic.List$1(PaintingPixel)).ctor();
                _listBlocks = this.GetPixelsBetweenRectangle(_startPixel, _endPixel);

                // Validate that the key should be straight (horizontal or vertical)
                if (!this.IsValidKeyOrientation(_listBlocks)) {
                    UnityEngine.Debug.LogWarning$1("Key must be either horizontal (same row) or vertical (same column). Cannot create key.");
                    return null;
                }

                // Create and setup the key in the scene - this will also create the key pixels
                var keyPixelConfigs = new (System.Collections.Generic.List$1(PaintingPixelConfig)).ctor();
                $t = Bridge.getEnumerator(_listBlocks);
                try {
                    while ($t.moveNext()) {
                        var pixel = $t.Current;
                        keyPixelConfigs.add(new PaintingPixelConfig.$ctor1(pixel));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                var keySetup = new KeyObjectSetup.$ctor2(keyPixelConfigs);

                var newKeyObject = this.SetupNewKeyInScene(keySetup);

                if (UnityEngine.MonoBehaviour.op_Inequality(newKeyObject, null)) {
                    this.AddKeySetup(keySetup);
                }

                return keySetup;
            },
            /*KeyObjectConfigSetup.CreateKey end.*/

            /*KeyObjectConfigSetup.CreateKey$2 start.*/
            CreateKey$2: function (_keyPixels) {
if ( TRACE ) { TRACE( "KeyObjectConfigSetup#CreateKey$2", this ); }

                var $t;
                this.keyObjectSetups = new (System.Collections.Generic.List$1(KeyObjectSetup)).$ctor1(this.CurrentLevelKeyObjectSetups);

                if (_keyPixels == null || _keyPixels.Count <= 0) {
                    UnityEngine.Debug.LogWarning$1("_keyPixels is not valid. Cannot create key.");
                    return;
                }

                // Validate that the key should be straight (horizontal or vertical)
                if (!this.IsValidKeyOrientation$1(_keyPixels)) {
                    UnityEngine.Debug.LogWarning$1("Key must be either horizontal (same row) or vertical (same column). Cannot create key.");
                    return;
                }

                // Create and setup the key in the scene - this will also create the key pixels
                var keyPixelConfigs = new (System.Collections.Generic.List$1(PaintingPixelConfig)).ctor();
                $t = Bridge.getEnumerator(_keyPixels);
                try {
                    while ($t.moveNext()) {
                        var pixelComponent = $t.Current;
                        keyPixelConfigs.add(new PaintingPixelConfig.$ctor1(pixelComponent.PixelData));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                var keySetup = new KeyObjectSetup.$ctor2(keyPixelConfigs);

                var newKeyObject = this.SetupNewKeyInScene(keySetup);

                if (UnityEngine.MonoBehaviour.op_Inequality(newKeyObject, null)) {
                    this.AddKeySetup(keySetup);
                }
            },
            /*KeyObjectConfigSetup.CreateKey$2 end.*/

            /*KeyObjectConfigSetup.GetPixelsBetweenRectangle start.*/
            GetPixelsBetweenRectangle: function (a, b) {
if ( TRACE ) { TRACE( "KeyObjectConfigSetup#GetPixelsBetweenRectangle", this ); }

                var $t;
                var result = new (System.Collections.Generic.List$1(PaintingPixel)).ctor();

                var minRow = UnityEngine.Mathf.Min(a.row, b.row);
                var maxRow = UnityEngine.Mathf.Max(a.row, b.row);
                var minCol = UnityEngine.Mathf.Min(a.column, b.column);
                var maxCol = UnityEngine.Mathf.Max(a.column, b.column);

                for (var r = minRow; r <= maxRow; r = (r + 1) | 0) {
                    for (var c = minCol; c <= maxCol; c = (c + 1) | 0) {
                        result.add(($t = new PaintingPixel.ctor(), $t.row = r, $t.column = c, $t.worldPos = this.PaintingSetupModule.CurrentGridObject.CalculatePixelPosition(c, r, this.PaintingSetupModule.CurrentGridObject.YOffset), $t));
                    }
                }

                return result;
            },
            /*KeyObjectConfigSetup.GetPixelsBetweenRectangle end.*/

            /*KeyObjectConfigSetup.SetupNewKeyInScene start.*/
            /**
             * Set up the actual key object in the scene
             *
             * @instance
             * @private
             * @this KeyObjectConfigSetup
             * @memberof KeyObjectConfigSetup
             * @param   {KeyObjectSetup}    setup
             * @return  {KeyObject}                  Tuple with the created PipeObject component and list of new key pixels
             */
            SetupNewKeyInScene: function (setup) {
if ( TRACE ) { TRACE( "KeyObjectConfigSetup#SetupNewKeyInScene", this ); }

                var keyObject = this.PaintingSetupModule.CurrentGridObject.CreateKeyObject(setup);

                return keyObject;
            },
            /*KeyObjectConfigSetup.SetupNewKeyInScene end.*/

            /*KeyObjectConfigSetup.IsValidKeyOrientation$1 start.*/
            /**
             * Validates if the pipe orientation is valid (horizontal or vertical only)
             *
             * @instance
             * @public
             * @this KeyObjectConfigSetup
             * @memberof KeyObjectConfigSetup
             * @param   {System.Collections.Generic.List$1}    _keyPixels
             * @return  {boolean}                                            True if pipe orientation is valid, false otherwise
             */
            IsValidKeyOrientation$1: function (_keyPixels) {
if ( TRACE ) { TRACE( "KeyObjectConfigSetup#IsValidKeyOrientation$1", this ); }

                if (_keyPixels == null || _keyPixels.Count === 0) {
                    return false;
                }

                if (_keyPixels.Count === 1) {
                    return true;
                } // A single pixel is always valid

                var minRow = System.Linq.Enumerable.from(_keyPixels, PaintingPixelComponent).min(function (p) {
                        return p.PixelData.row;
                    });
                var maxRow = System.Linq.Enumerable.from(_keyPixels, PaintingPixelComponent).max(function (p) {
                        return p.PixelData.row;
                    });
                var minCol = System.Linq.Enumerable.from(_keyPixels, PaintingPixelComponent).min(function (p) {
                        return p.PixelData.column;
                    });
                var maxCol = System.Linq.Enumerable.from(_keyPixels, PaintingPixelComponent).max(function (p) {
                        return p.PixelData.column;
                    });

                var width = (((maxCol - minCol) | 0) + 1) | 0;
                var height = (((maxRow - minRow) | 0) + 1) | 0;
                var expectedCount = Bridge.Int.mul(width, height);

                if (_keyPixels.Count !== expectedCount) {
                    return false;
                }

                // HashSet<(int, int)> pointSet = _keyPixels
                //     .Select(p => (p.PixelData.row, p.PixelData.column))
                //     .ToHashSet();
                var pointSet = new (System.Collections.Generic.HashSet$1(System.ValueTuple$2(System.Int32,System.Int32))).$ctor1(System.Linq.Enumerable.from(_keyPixels, PaintingPixelComponent).select(function (p) {
                        return new (System.ValueTuple$2(System.Int32,System.Int32)).$ctor1(p.PixelData.row, p.PixelData.column);
                    }));

                for (var r = minRow; r <= maxRow; r = (r + 1) | 0) {
                    for (var c = minCol; c <= maxCol; c = (c + 1) | 0) {
                        if (!pointSet.contains(new (System.ValueTuple$2(System.Int32,System.Int32)).$ctor1(r, c))) {
                            return false;
                        }
                    }
                }

                return true;
            },
            /*KeyObjectConfigSetup.IsValidKeyOrientation$1 end.*/

            /*KeyObjectConfigSetup.IsValidKeyOrientation start.*/
            IsValidKeyOrientation: function (_wallPixels) {
if ( TRACE ) { TRACE( "KeyObjectConfigSetup#IsValidKeyOrientation", this ); }

                if (_wallPixels == null || _wallPixels.Count === 0) {
                    return false;
                }

                var minRow = System.Linq.Enumerable.from(_wallPixels, PaintingPixel).min(function (p) {
                        return p.row;
                    });
                var maxRow = System.Linq.Enumerable.from(_wallPixels, PaintingPixel).max(function (p) {
                        return p.row;
                    });
                var minCol = System.Linq.Enumerable.from(_wallPixels, PaintingPixel).min(function (p) {
                        return p.column;
                    });
                var maxCol = System.Linq.Enumerable.from(_wallPixels, PaintingPixel).max(function (p) {
                        return p.column;
                    });

                var width = (((maxCol - minCol) | 0) + 1) | 0;
                var height = (((maxRow - minRow) | 0) + 1) | 0;
                var expectedCount = Bridge.Int.mul(width, height);

                if (_wallPixels.Count !== expectedCount) {
                    return false;
                }

                // HashSet<(int, int)> pointSet = _wallPixels
                //     .Select(p => (p.row, p.column))
                //     .ToHashSet();
                var pointSet = new (System.Collections.Generic.HashSet$1(System.ValueTuple$2(System.Int32,System.Int32))).$ctor1(System.Linq.Enumerable.from(_wallPixels, PaintingPixel).select(function (p) {
                        return new (System.ValueTuple$2(System.Int32,System.Int32)).$ctor1(p.row, p.column);
                    }));

                for (var r = minRow; r <= maxRow; r = (r + 1) | 0) {
                    for (var c = minCol; c <= maxCol; c = (c + 1) | 0) {
                        if (!pointSet.contains(new (System.ValueTuple$2(System.Int32,System.Int32)).$ctor1(r, c))) {
                            return false;
                        }
                    }
                }

                return true;
            },
            /*KeyObjectConfigSetup.IsValidKeyOrientation end.*/

            /*KeyObjectConfigSetup.GetCenterByBoundingBox start.*/
            GetCenterByBoundingBox: function (points) {
if ( TRACE ) { TRACE( "KeyObjectConfigSetup#GetCenterByBoundingBox", this ); }

                if (points == null || points.Count === 0) {
                    return pc.Vec3.ZERO.clone();
                }

                var minX = System.Linq.Enumerable.from(points, PaintingPixelComponent).min(function (p) {
                        return p.PixelData.worldPos.x;
                    });
                var maxX = System.Linq.Enumerable.from(points, PaintingPixelComponent).max(function (p) {
                        return p.PixelData.worldPos.x;
                    });
                var minY = System.Linq.Enumerable.from(points, PaintingPixelComponent).min(function (p) {
                        return p.PixelData.worldPos.y;
                    });
                var maxY = System.Linq.Enumerable.from(points, PaintingPixelComponent).max(function (p) {
                        return p.PixelData.worldPos.y;
                    });
                var minZ = System.Linq.Enumerable.from(points, PaintingPixelComponent).min(function (p) {
                        return p.PixelData.worldPos.z;
                    });
                var maxZ = System.Linq.Enumerable.from(points, PaintingPixelComponent).max(function (p) {
                        return p.PixelData.worldPos.z;
                    });

                // trung tm bounding box
                return new pc.Vec3( (minX + maxX) * 0.5, (minY + maxY) * 0.5, (minZ + maxZ) * 0.5 );
            },
            /*KeyObjectConfigSetup.GetCenterByBoundingBox end.*/


        },
        overloads: {
            "RemoveKeyObjectAndItConfig(KeyObjectSetup, bool)": "RemoveKeyObjectAndItConfig$1",
            "CreateKey()": "CreateKey$1",
            "CreateKey(List<PaintingPixelComponent>)": "CreateKey$2",
            "IsValidKeyOrientation(List<PaintingPixelComponent>)": "IsValidKeyOrientation$1"
        }
    });
    /*KeyObjectConfigSetup end.*/

    /*KeyObjectSetup start.*/
    Bridge.define("KeyObjectSetup", {
        fields: {
            PixelCovered: null,
            ColorCode: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "KeyObjectSetup#init", this ); }

                this.ColorCode = "KeyColor";
            },
            ctor: function () {
if ( TRACE ) { TRACE( "KeyObjectSetup#ctor", this ); }

                this.$initialize();
                this.PixelCovered = new (System.Collections.Generic.List$1(PaintingPixelConfig)).ctor();
                this.ColorCode = PaintingSharedAttributes.LockKeyColorDefine;
            },
            $ctor1: function (_stock) {
if ( TRACE ) { TRACE( "KeyObjectSetup#$ctor1", this ); }

                var $t;
                this.$initialize();
                this.PixelCovered = new (System.Collections.Generic.List$1(PaintingPixelConfig)).ctor();
                $t = Bridge.getEnumerator(_stock.PixelCovered);
                try {
                    while ($t.moveNext()) {
                        var pixel = $t.Current;
                        this.PixelCovered.add(new PaintingPixelConfig.$ctor2(pixel));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.ColorCode = PaintingSharedAttributes.LockKeyColorDefine;
            },
            $ctor2: function (pixelCovered) {
if ( TRACE ) { TRACE( "KeyObjectSetup#$ctor2", this ); }

                this.$initialize();
                this.PixelCovered = pixelCovered != null ? new (System.Collections.Generic.List$1(PaintingPixelConfig)).$ctor1(pixelCovered) : new (System.Collections.Generic.List$1(PaintingPixelConfig)).ctor();
                this.ColorCode = PaintingSharedAttributes.LockKeyColorDefine;
            }
        }
    });
    /*KeyObjectSetup end.*/

    /*LevelCollectorsConfigSetup start.*/
    Bridge.define("LevelCollectorsConfigSetup", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            CurentCollectorsConfig: null,
            paintingConfig: null,
            NumberOfColumns: 0,
            MaxBulletPerCollector: 0,
            defaultLocked: false,
            defaultHidden: false,
            previewSystem: null,
            ToolActive: false,
            CollectorObjectLayerMask: null,
            CollisionRadius: 0,
            OriginalCollectorPosition: null,
            OriginalLocksPosition: null,
            NumberOfWorkingPixels: 0,
            TotalBulletsCount: 0,
            NumberOfLockedCollector: 0,
            colorSetCounters: null,
            collectorSetCounters: null,
            BGColor: null,
            MoveModule: null,
            SwapModule: null,
            SplitModule: null,
            CombineModule: null,
            ConnectModule: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "LevelCollectorsConfigSetup#init", this ); }

                this.CollectorObjectLayerMask = new UnityEngine.LayerMask();
                this.BGColor = new UnityEngine.Color();
                this.NumberOfColumns = 3;
                this.MaxBulletPerCollector = 20;
                this.defaultLocked = false;
                this.defaultHidden = false;
                this.ToolActive = false;
                this.OriginalCollectorPosition = new (System.Collections.Generic.List$1(UnityEngine.Vector3)).ctor();
                this.OriginalLocksPosition = new (System.Collections.Generic.List$1(UnityEngine.Vector3)).ctor();
                this.NumberOfWorkingPixels = 0;
                this.TotalBulletsCount = 0;
                this.NumberOfLockedCollector = 0;
                this.colorSetCounters = new (System.Collections.Generic.Dictionary$2(System.String,System.Int32)).ctor();
                this.collectorSetCounters = new (System.Collections.Generic.Dictionary$2(System.String,System.Int32)).ctor();
            }
        },
        methods: {
            /*LevelCollectorsConfigSetup.LoadConfigAsset start.*/
            LoadConfigAsset: function (sourceConfig) {
if ( TRACE ) { TRACE( "LevelCollectorsConfigSetup#LoadConfigAsset", this ); }

                if (sourceConfig == null) {
                    UnityEngine.Debug.LogError$2("Source config is null!");
                    return;
                }

                this.CurentCollectorsConfig = sourceConfig;
                UnityEngine.Debug.Log$1(System.String.format("Loaded config asset: {0}", [this.CurentCollectorsConfig.name]));

                // Preview the loaded config if preview system is available
                if (UnityEngine.MonoBehaviour.op_Inequality(this.previewSystem, null)) {
                    this.previewSystem.CurrentLevelCollectorsConfig = this.CurentCollectorsConfig;
                    this.previewSystem.SetupCollectorsAndMechanic();
                }

            },
            /*LevelCollectorsConfigSetup.LoadConfigAsset end.*/

            /*LevelCollectorsConfigSetup.ImportCollectorsFromScene start.*/
            ImportCollectorsFromScene: function () {
if ( TRACE ) { TRACE( "LevelCollectorsConfigSetup#ImportCollectorsFromScene", this ); }

                var $t, $t1, $t2;
                if (UnityEngine.MonoBehaviour.op_Equality(this.previewSystem, null) || this.previewSystem.CurrentCollectors == null || this.previewSystem.CurrentCollectors.Count === 0) {
                    UnityEngine.Debug.LogError$2("Source system or its current collectors is null/empty!");
                    return;
                }

                if (this.CurentCollectorsConfig == null) {
                    UnityEngine.Debug.LogError$2("Target config is null! Please assign a config asset to import to.");
                    return;
                }

                // Clear the target config's existing setups
                this.CurentCollectorsConfig.CollectorColumns.clear();

                // Import collector data from the system's current collectors
                $t = Bridge.getEnumerator(this.previewSystem.ObjectsInColumns);
                try {
                    while ($t.moveNext()) {
                        var col = $t.Current;
                        var locksRow = 0;
                        var newColumn = new ColumnOfCollectorConfig.ctor();
                        $t1 = Bridge.getEnumerator(col.CollectorsInColumn);
                        try {
                            while ($t1.moveNext()) {
                                var _object = $t1.Current;
                                if (UnityEngine.MonoBehaviour.op_Equality(_object, null)) {
                                    continue;
                                }
                                if (Bridge.is(_object, ColorPixelsCollectorObject)) {
                                    var _collector = Bridge.as(_object, ColorPixelsCollectorObject);
                                    var newCollector = ($t2 = new SingleColorCollectorConfig.ctor(), $t2.ID = _collector.ID, $t2.ColorCode = _collector.CollectorColor, $t2.Bullets = _collector.BulletCapacity, $t2.Locked = _collector.IsLocked, $t2.Hidden = _collector.IsHidden, $t2.ConnectedCollectorsIDs = new (System.Collections.Generic.List$1(System.Int32)).$ctor1(_collector.ConnectedCollectorsIDs), $t2);
                                    newColumn.Collectors.add(newCollector);
                                } else if (Bridge.is(_object, LockObject)) {
                                    var _lock = Bridge.as(_object, LockObject);
                                    var newLock = ($t2 = new LockObjectConfig(), $t2.ID = _lock.ID, $t2.Row = locksRow, $t2);
                                    newColumn.Locks.add(newLock);
                                }
                                locksRow = (locksRow + 1) | 0;
                            }
                        } finally {
                            if (Bridge.is($t1, System.IDisposable)) {
                                $t1.System$IDisposable$Dispose();
                            }
                        }
                        if (newColumn.Collectors.Count > 0) {
                            this.CurentCollectorsConfig.CollectorColumns.add(newColumn);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                // Update the number of columns (might need to set this manually or estimate)
                // For now, we'll keep the existing number of columns or default to 1 if not set
                this.EnsureBidirectionalConnections(false);
                UnityEngine.Debug.Log$1(System.String.format("Imported {0} collector data from LevelCollectorsSystem to {1}", Bridge.box(this.previewSystem.CurrentCollectors.Count, System.Int32), this.CurentCollectorsConfig.name));
            },
            /*LevelCollectorsConfigSetup.ImportCollectorsFromScene end.*/

            /*LevelCollectorsConfigSetup.EnsureBidirectionalConnections start.*/
            EnsureBidirectionalConnections: function (save) {
if ( TRACE ) { TRACE( "LevelCollectorsConfigSetup#EnsureBidirectionalConnections", this ); }

                var $t, $t1;
                if (save === void 0) { save = true; }
                if (this.CurentCollectorsConfig == null || this.CurentCollectorsConfig.CollectorColumns == null || this.CurentCollectorsConfig.CollectorColumns.Count <= 0) {
                    UnityEngine.Debug.LogError$2("Config asset or collector setups is null!");
                    return;
                }

                var allCollectorConfig = new (System.Collections.Generic.List$1(SingleColorCollectorConfig)).ctor();

                $t = Bridge.getEnumerator(this.CurentCollectorsConfig.CollectorColumns);
                try {
                    while ($t.moveNext()) {
                        var column = $t.Current;
                        allCollectorConfig.AddRange(column.Collectors);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                if (allCollectorConfig.Count <= 0) {
                    return;
                }

                // Iterate through each collector in the config
                for (var i = 0; i < allCollectorConfig.Count; i = (i + 1) | 0) {
                    var collector = allCollectorConfig.getItem(i);

                    // For each connection in this collector, ensure the reverse connection exists
                    $t1 = Bridge.getEnumerator(collector.ConnectedCollectorsIDs);
                    try {
                        while ($t1.moveNext()) {
                            var connectedID = $t1.Current;
                            if (connectedID === collector.ID) {
                                continue;
                            }
                            if (connectedID >= 0) {
                                var targetCollector = PaintingSharedAttributes.GetCollectorConfigByID(allCollectorConfig, connectedID);
                                if (targetCollector == null || targetCollector.ID === collector.ID) {
                                    return;
                                }

                                // If the target collector doesn't have this collector in its connections, add it
                                if (!targetCollector.ConnectedCollectorsIDs.contains(collector.ID)) {
                                    targetCollector.ConnectedCollectorsIDs.add(collector.ID);
                                    UnityEngine.Debug.Log$1(System.String.format("Added reverse connection: Collector {0} now connected to ID {1}", Bridge.box(connectedID, System.Int32), Bridge.box(collector.ID, System.Int32)));
                                }
                            } else {
                                UnityEngine.Debug.LogWarning$1(System.String.format("Invalid connection index {0} in collector {1}", Bridge.box(connectedID, System.Int32), Bridge.box(i, System.Int32)));
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                }

                UnityEngine.Debug.Log$1(System.String.format("Ensured bidirectional connections for {0} collectors in {1}", Bridge.box(allCollectorConfig.Count, System.Int32), allCollectorConfig));

                if (save) {
                    this.Save();
                }
            },
            /*LevelCollectorsConfigSetup.EnsureBidirectionalConnections end.*/

            /*LevelCollectorsConfigSetup.GenerateCollectorsFromPaintingConfig start.*/
            GenerateCollectorsFromPaintingConfig: function () {
if ( TRACE ) { TRACE( "LevelCollectorsConfigSetup#GenerateCollectorsFromPaintingConfig", this ); }

                var $t, $t1;
                if (this.paintingConfig == null) {
                    UnityEngine.Debug.LogError$2("PaintingConfig is null! Please assign a painting config to generate collectors from.");
                    return;
                }

                if (this.CurentCollectorsConfig == null) {
                    UnityEngine.Debug.LogError$2("Config asset is null! Please assign a LevelColorCollectorsConfig asset to populate.");
                    return;
                }

                // Clear existing collector setups
                if (this.CurentCollectorsConfig.CollectorColumns == null) {
                    this.CurentCollectorsConfig.CollectorColumns = new (System.Collections.Generic.List$1(ColumnOfCollectorConfig)).ctor();
                }
                this.CurentCollectorsConfig.CollectorColumns.clear();

                // Collect all pixels from painting config (PaintingConfig.Pixels) and from pipe setups (PixelCovered)
                var allWorkingPixels = this.paintingConfig.GetAllWorkingPixels();
                var allPixels = new (System.Collections.Generic.List$1(PaintingPixel)).ctor();

                for (var i = 0; i < allWorkingPixels.Count; i = (i + 1) | 0) {
                    var pConfig = allWorkingPixels.getItem(i);
                    var pixel = ($t = new PaintingPixel.ctor(), $t.column = pConfig.column, $t.row = pConfig.row, $t.color = pConfig.color.$clone(), $t.colorCode = pConfig.colorCode, $t.Hearts = 1, $t.Hidden = pConfig.Hidden, $t);
                    allPixels.add(pixel);
                }

                // Group pixels by outline based on painting size
                var outlines = this.ExtractOutlinesByDepth_Custom(allPixels);

                // Process each outline to create collectors
                var outlineCount = outlines.Count;
                var allCollectorConfigs = new (System.Collections.Generic.List$1(SingleColorCollectorConfig)).ctor();

                var id = 0;
                var keyColorNeedToArrange = 0;
                for (var i1 = 0; i1 < outlineCount; i1 = (i1 + 1) | 0) {
                    var outline = outlines.getItem(i1);

                    // Categorize pixels by color in this outline
                    var colorCounts = new (System.Collections.Generic.Dictionary$2(System.String,System.Int32)).ctor();
                    $t = Bridge.getEnumerator(outline);
                    try {
                        while ($t.moveNext()) {
                            var pixel1 = $t.Current;
                            if (pixel1.Hidden || System.String.equals(pixel1.colorCode, PaintingSharedAttributes.TransparentColorKey) || System.String.equals(pixel1.colorCode, PaintingSharedAttributes.LockKeyColorDefine) || System.String.equals(pixel1.colorCode, "WhiteDefault")) {
                                continue;
                            } // Skip hidden pixels
                            if (colorCounts.containsKey(pixel1.colorCode)) {
                                colorCounts.setItem(pixel1.colorCode, (colorCounts.getItem(pixel1.colorCode) + pixel1.Hearts) | 0); // Count hearts as multiples
                            } else {
                                colorCounts.setItem(pixel1.colorCode, pixel1.Hearts);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    // Create collectors based on color counts
                    var colorSetCount = colorCounts.Count;
                    var hasKey = false;
                    for (var j = 0; j < colorSetCount; j = (j + 1) | 0) {
                        var colorCount = System.Linq.Enumerable.from(colorCounts, System.Collections.Generic.KeyValuePair$2(System.String,System.Int32)).elementAt(j);
                        var colorCode = colorCount.key;
                        var totalPixels = colorCount.value;

                        if (!hasKey && System.String.equals(colorCode, PaintingSharedAttributes.LockKeyColorDefine)) {
                            keyColorNeedToArrange = (keyColorNeedToArrange + colorCount.value) | 0;
                            hasKey = true;
                            continue;
                        }

                        // Create as many collectors as needed to handle the total pixel count
                        var remainingPixels = totalPixels;

                        while (remainingPixels > 0) {
                            var bulletsForThisCollector = UnityEngine.Mathf.Min(remainingPixels, this.MaxBulletPerCollector);

                            var collector = ($t1 = new SingleColorCollectorConfig.ctor(), $t1.ID = id, $t1.ColorCode = colorCode, $t1.Bullets = bulletsForThisCollector, $t1.Locked = this.defaultLocked, $t1.Hidden = this.defaultHidden, $t1.ConnectedCollectorsIDs = new (System.Collections.Generic.List$1(System.Int32)).ctor(), $t1);

                            allCollectorConfigs.add(collector);

                            remainingPixels = (remainingPixels - bulletsForThisCollector) | 0;
                            id = (id + 1) | 0;
                        }
                    }

                    if (i1 === ((outlineCount - 1) | 0)) {
                        ($t1 = allCollectorConfigs.getItem(((allCollectorConfigs.Count - 1) | 0))).Bullets = ($t1.Bullets + keyColorNeedToArrange) | 0;
                    }
                }

                var collectorCount = allCollectorConfigs.Count;

                allCollectorConfigs = this.ReArrangeCollectorBullets(allCollectorConfigs, this.MaxBulletPerCollector);

                for (var i2 = 0; i2 < allCollectorConfigs.Count; i2 = (i2 + 1) | 0) {
                    allCollectorConfigs.getItem(i2).ID = i2; // Re-assign IDs after rearrangement
                }

                var columnsConfig = new (System.Collections.Generic.List$1(ColumnOfCollectorConfig)).ctor();
                for (var colIdx = 0; colIdx < this.NumberOfColumns; colIdx = (colIdx + 1) | 0) {
                    var column = new ColumnOfCollectorConfig.ctor();
                    // Add collectors to this column (every nth collector where n is the number of columns)
                    // In row-major order, collectors in the same column are at indices: colIdx, colIdx+numberOfColumns, colIdx+2*numberOfColumns, etc.
                    for (var idx = colIdx; idx < collectorCount; idx = (idx + this.NumberOfColumns) | 0) {
                        if (idx < allCollectorConfigs.Count) {
                            column.Collectors.add(allCollectorConfigs.getItem(idx));
                        }
                    }
                    columnsConfig.add(column);
                }
                this.CurentCollectorsConfig.CollectorColumns = columnsConfig;
                //var a = SumColorBullets(configAsset.GetAllCollectorConfigs());

                UnityEngine.Debug.Log$1(System.String.format("Generated {0} collector setups from painting config '{1}'", Bridge.box(this.CurentCollectorsConfig.CollectorColumns.Count, System.Int32), this.paintingConfig.name));

                this.Save();
            },
            /*LevelCollectorsConfigSetup.GenerateCollectorsFromPaintingConfig end.*/

            /*LevelCollectorsConfigSetup.UpdateCollectorsFromPaintingConfig start.*/
            UpdateCollectorsFromPaintingConfig: function () {
if ( TRACE ) { TRACE( "LevelCollectorsConfigSetup#UpdateCollectorsFromPaintingConfig", this ); }

                var $t, $t1, $t2;
                if (this.paintingConfig == null) {
                    UnityEngine.Debug.LogError$2("PaintingConfig is null! Please assign a painting config to generate collectors from.");
                    return;
                }

                if (this.CurentCollectorsConfig == null) {
                    UnityEngine.Debug.LogError$2("Config asset is null! Please assign a LevelColorCollectorsConfig asset to populate.");
                    return;
                }

                // Collect all pixels from painting config (PaintingConfig.Pixels) and from pipe setups (PixelCovered)
                var allWorkingPixels = this.paintingConfig.GetAllWorkingPixels();
                var allPixels = new (System.Collections.Generic.List$1(PaintingPixel)).ctor();

                for (var i = 0; i < allWorkingPixels.Count; i = (i + 1) | 0) {
                    var pConfig = allWorkingPixels.getItem(i);
                    var pixel = ($t = new PaintingPixel.ctor(), $t.column = pConfig.column, $t.row = pConfig.row, $t.color = pConfig.color.$clone(), $t.colorCode = pConfig.colorCode, $t.Hearts = 1, $t.Hidden = pConfig.Hidden, $t);
                    allPixels.add(pixel);
                }

                // Group pixels by outline based on painting size
                var outlines = this.ExtractOutlinesByDepth_Custom(allPixels);

                // Process each outline to create collectors
                var outlineCount = outlines.Count;
                var allCollectorConfigs = new (System.Collections.Generic.List$1(SingleColorCollectorConfig)).ctor();

                var id = 0;
                for (var i1 = 0; i1 < outlineCount; i1 = (i1 + 1) | 0) {
                    var outline = outlines.getItem(i1);

                    // Categorize pixels by color in this outline
                    var colorCounts = new (System.Collections.Generic.Dictionary$2(System.String,System.Int32)).ctor();
                    $t = Bridge.getEnumerator(outline);
                    try {
                        while ($t.moveNext()) {
                            var pixel1 = $t.Current;
                            if (pixel1.Hidden || System.String.equals(pixel1.colorCode, PaintingSharedAttributes.TransparentColorKey) || System.String.equals(pixel1.colorCode, PaintingSharedAttributes.LockKeyColorDefine) || System.String.equals(pixel1.colorCode, "WhiteDefault")) {
                                continue;
                            } // Skip hidden pixels
                            if (colorCounts.containsKey(pixel1.colorCode)) {
                                colorCounts.setItem(pixel1.colorCode, (colorCounts.getItem(pixel1.colorCode) + pixel1.Hearts) | 0); // Count hearts as multiples
                            } else {
                                colorCounts.setItem(pixel1.colorCode, pixel1.Hearts);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    // Create collectors based on color counts
                    var colorSetCount = colorCounts.Count;
                    for (var j = 0; j < colorSetCount; j = (j + 1) | 0) {
                        var colorCount = System.Linq.Enumerable.from(colorCounts, System.Collections.Generic.KeyValuePair$2(System.String,System.Int32)).elementAt(j);
                        var colorCode = colorCount.key;
                        var totalPixels = colorCount.value;

                        // Create as many collectors as needed to handle the total pixel count
                        var remainingPixels = totalPixels;

                        while (remainingPixels > 0) {
                            var bulletsForThisCollector = UnityEngine.Mathf.Min(remainingPixels, this.MaxBulletPerCollector);

                            var collector = ($t1 = new SingleColorCollectorConfig.ctor(), $t1.ID = id, $t1.ColorCode = colorCode, $t1.Bullets = bulletsForThisCollector, $t1.Locked = this.defaultLocked, $t1.Hidden = this.defaultHidden, $t1.ConnectedCollectorsIDs = new (System.Collections.Generic.List$1(System.Int32)).ctor(), $t1);

                            allCollectorConfigs.add(collector);

                            remainingPixels = (remainingPixels - bulletsForThisCollector) | 0;
                            id = (id + 1) | 0;
                        }
                    }
                }

                var collectorCount = allCollectorConfigs.Count;

                allCollectorConfigs = this.ReArrangeCollectorBullets(allCollectorConfigs, this.MaxBulletPerCollector);

                for (var i2 = 0; i2 < allCollectorConfigs.Count; i2 = (i2 + 1) | 0) {
                    allCollectorConfigs.getItem(i2).ID = i2; // Re-assign IDs after rearrangement
                }

                var columnCount = this.CurentCollectorsConfig.NumberOfColumns();

                var columnsConfig = new (System.Collections.Generic.List$1(ColumnOfCollectorConfig)).ctor();
                for (var colIdx = 0; colIdx < columnCount; colIdx = (colIdx + 1) | 0) {
                    var column = new ColumnOfCollectorConfig.ctor();
                    // Add collectors to this column (every nth collector where n is the number of columns)
                    // In row-major order, collectors in the same column are at indices: colIdx, colIdx+numberOfColumns, colIdx+2*numberOfColumns, etc.
                    for (var idx = colIdx; idx < collectorCount; idx = (idx + columnCount) | 0) {
                        if (idx < allCollectorConfigs.Count) {
                            column.Collectors.add(allCollectorConfigs.getItem(idx));
                        }
                    }
                    columnsConfig.add(column);
                }
                //configAsset.CollectorColumns = columnsConfig;
                var oldCollectors = this.SumColorBullets(this.CurentCollectorsConfig.GetAllCollectorConfigs());
                var newCollector = this.SumColorBullets(allCollectorConfigs);
                var colorDiff = this.Diff(oldCollectors, newCollector);
                var rsCollectors = this.CurentCollectorsConfig.GetAllCollectorConfigs();
                $t1 = Bridge.getEnumerator(colorDiff);
                try {
                    while ($t1.moveNext()) {
                        var colorSet = $t1.Current;
                        if (colorSet.value === 0) {
                            continue;
                        }
                        if (System.String.equals(colorSet.key, PaintingSharedAttributes.LockKeyColorDefine)) {
                            continue;
                        } else {
                            if (colorSet.value > 0) {
                                var bulletsToAdd = colorSet.value;
                                var allOldCollectorCount = this.CurentCollectorsConfig.GetAllCollectorConfigs().Count;
                                for (var i3 = (allOldCollectorCount - 1) | 0; i3 >= 0; i3 = (i3 - 1) | 0) {
                                    var collector1 = rsCollectors.getItem(i3);
                                    if (Bridge.referenceEquals(collector1.ColorCode, colorSet.key)) {
                                        var canAdd = (this.MaxBulletPerCollector - collector1.Bullets) | 0;
                                        if (canAdd > 0) {
                                            var adding = UnityEngine.Mathf.Min(canAdd, bulletsToAdd);
                                            collector1.Bullets = (collector1.Bullets + adding) | 0;
                                            bulletsToAdd = (bulletsToAdd - adding) | 0;
                                        }
                                    }
                                }
                                if (bulletsToAdd > 0) {
                                    while (bulletsToAdd > 0) {
                                        var newCollectorConfig = ($t2 = new SingleColorCollectorConfig.ctor(), $t2.ID = rsCollectors.Count, $t2.ColorCode = colorSet.key, $t2.Bullets = UnityEngine.Mathf.Min(bulletsToAdd, this.MaxBulletPerCollector), $t2.Locked = this.defaultLocked, $t2.Hidden = this.defaultHidden, $t2.ConnectedCollectorsIDs = new (System.Collections.Generic.List$1(System.Int32)).ctor(), $t2);
                                        rsCollectors.add(newCollectorConfig);
                                        bulletsToAdd = (bulletsToAdd - newCollectorConfig.Bullets) | 0;
                                    }
                                }
                            } else {
                                var bulletsToRemove = (-colorSet.value) | 0;
                                var allOldCollectorCount1 = this.CurentCollectorsConfig.GetAllCollectorConfigs().Count;
                                for (var i4 = (allOldCollectorCount1 - 1) | 0; i4 >= 0; i4 = (i4 - 1) | 0) {
                                    var collector2 = rsCollectors.getItem(i4);
                                    if (Bridge.referenceEquals(collector2.ColorCode, colorSet.key) && collector2.Bullets > 0) {
                                        if (collector2.Bullets > 0) {
                                            var removing = UnityEngine.Mathf.Min(collector2.Bullets, bulletsToRemove);
                                            collector2.Bullets = (collector2.Bullets - removing) | 0;
                                            bulletsToRemove = (bulletsToRemove - removing) | 0;
                                        }
                                    }

                                    if (collector2.Bullets <= 0) {
                                        this.CurentCollectorsConfig.RemoveCollector(collector2.ID);
                                    }
                                }
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                this.Save();
            },
            /*LevelCollectorsConfigSetup.UpdateCollectorsFromPaintingConfig end.*/

            /*LevelCollectorsConfigSetup.SumColorBullets start.*/
            SumColorBullets: function (collectors) {
if ( TRACE ) { TRACE( "LevelCollectorsConfigSetup#SumColorBullets", this ); }

                var $t;
                var map = new (System.Collections.Generic.Dictionary$2(System.String,System.Int32)).ctor();

                $t = Bridge.getEnumerator(collectors);
                try {
                    while ($t.moveNext()) {
                        var c = $t.Current;
                        if (!map.containsKey(c.ColorCode)) {
                            map.setItem(c.ColorCode, 0);
                        }

                        map.setItem(c.ColorCode, (map.getItem(c.ColorCode) + c.Bullets) | 0);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                return map;
            },
            /*LevelCollectorsConfigSetup.SumColorBullets end.*/

            /*LevelCollectorsConfigSetup.Diff start.*/
            Diff: function (oldDict, newDict) {
if ( TRACE ) { TRACE( "LevelCollectorsConfigSetup#Diff", this ); }

                var $t;
                var diff = new (System.Collections.Generic.Dictionary$2(System.String,System.Int32)).ctor();

                // ly tt c key t old + new
                var allKeys = new (System.Collections.Generic.HashSet$1(System.String)).$ctor1(oldDict.Keys);
                allKeys.unionWith(newDict.Keys);

                $t = Bridge.getEnumerator(allKeys);
                try {
                    while ($t.moveNext()) {
                        var key = $t.Current;
                        var o = { };
                        var oldValue = oldDict.tryGetValue(key, o) ? o.v : 0;
                        var n = { };
                        var newValue = newDict.tryGetValue(key, n) ? n.v : 0;

                        diff.setItem(key, (newValue - oldValue) | 0); // + tng, - gim, 0 = khng i
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                return diff;
            },
            /*LevelCollectorsConfigSetup.Diff end.*/

            /*LevelCollectorsConfigSetup.CleanupZeroCollectors start.*/
            CleanupZeroCollectors: function (list) {
if ( TRACE ) { TRACE( "LevelCollectorsConfigSetup#CleanupZeroCollectors", this ); }

                list.RemoveAll(function (c) {
                    return c.Bullets <= 0;
                });
            },
            /*LevelCollectorsConfigSetup.CleanupZeroCollectors end.*/

            /*LevelCollectorsConfigSetup.ExtractOutlinesByDepth start.*/
            ExtractOutlinesByDepth: function (allPixels, paintingSize) {
if ( TRACE ) { TRACE( "LevelCollectorsConfigSetup#ExtractOutlinesByDepth", this ); }

                var $t, $t1;
                var outlines = new (System.Collections.Generic.List$1(System.Collections.Generic.List$1(PaintingPixel))).ctor();
                if (allPixels == null || allPixels.Count === 0) {
                    return outlines;
                }

                // Clone the list to avoid modifying the original
                var workingPixels = new (System.Collections.Generic.List$1(PaintingPixel)).$ctor1(allPixels);

                // Keep looping while there are still pixels
                while (workingPixels.Count > 0) {
                    // Determine current bounds (outermost rectangle of remaining pixels)
                    var minCol = 2147483647, maxCol = -2147483648;
                    var minRow = 2147483647, maxRow = -2147483648;

                    $t = Bridge.getEnumerator(workingPixels);
                    try {
                        while ($t.moveNext()) {
                            var pixel = $t.Current;
                            if (pixel.Hidden) {
                                continue;
                            }
                            if (pixel.column < minCol) {
                                minCol = pixel.column;
                            }
                            if (pixel.column > maxCol) {
                                maxCol = pixel.column;
                            }
                            if (pixel.row < minRow) {
                                minRow = pixel.row;
                            }
                            if (pixel.row > maxRow) {
                                maxRow = pixel.row;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    var currentOutline = new (System.Collections.Generic.List$1(PaintingPixel)).ctor();

                    // Top edge
                    for (var col = minCol; col <= maxCol; col = (col + 1) | 0) {
                        var p = this.FindNonHiddenPixelsAt(workingPixels, col, minRow);
                        if (p != null) {
                            currentOutline.AddRange(p);
                        }
                    }

                    // Right edge
                    for (var row = (minRow + 1) | 0; row <= ((maxRow - 1) | 0); row = (row + 1) | 0) {
                        var p1 = this.FindNonHiddenPixelsAt(workingPixels, maxCol, row);
                        if (p1 != null) {
                            currentOutline.AddRange(p1);
                        }
                    }

                    // Bottom edge
                    for (var col1 = maxCol; col1 >= minCol; col1 = (col1 - 1) | 0) {
                        var p2 = this.FindNonHiddenPixelsAt(workingPixels, col1, maxRow);
                        if (p2 != null) {
                            currentOutline.AddRange(p2);
                        }
                    }

                    // Left edge
                    for (var row1 = (maxRow - 1) | 0; row1 >= ((minRow + 1) | 0); row1 = (row1 - 1) | 0) {
                        var p3 = this.FindNonHiddenPixelsAt(workingPixels, minCol, row1);
                        if (p3 != null) {
                            currentOutline.AddRange(p3);
                        }
                    }

                    // Remove found pixels from working list
                    $t1 = Bridge.getEnumerator(currentOutline);
                    try {
                        while ($t1.moveNext()) {
                            var p4 = $t1.Current;
                            workingPixels.remove(p4);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }

                    // Add to results if we found any
                    if (currentOutline.Count > 0) {
                        outlines.add(currentOutline);
                    } else {
                        // No outline found  break to avoid infinite loop
                        break;
                    }
                }

                return outlines;
            },
            /*LevelCollectorsConfigSetup.ExtractOutlinesByDepth end.*/

            /*LevelCollectorsConfigSetup.ExtractOutlinesByDepth_Custom start.*/
            ExtractOutlinesByDepth_Custom: function (allPixels) {
if ( TRACE ) { TRACE( "LevelCollectorsConfigSetup#ExtractOutlinesByDepth_Custom", this ); }

                var $t;
                var outlines = new (System.Collections.Generic.List$1(System.Collections.Generic.List$1(PaintingPixel))).ctor();

                var workingPixels = System.Linq.Enumerable.from(allPixels, PaintingPixel).where(function (p) {
                        return p != null && !p.destroyed && !p.Hidden;
                    }).toList(PaintingPixel);

                while (workingPixels.Count > 0) {
                    var currentOutline = this.SelectOutlinePixelsFromList(workingPixels);

                    if (currentOutline.Count === 0) {
                        break;
                    }

                    outlines.add(currentOutline);

                    $t = Bridge.getEnumerator(currentOutline);
                    try {
                        while ($t.moveNext()) {
                            var p = $t.Current;
                            workingPixels.remove(p);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                return outlines;
            },
            /*LevelCollectorsConfigSetup.ExtractOutlinesByDepth_Custom end.*/

            /*LevelCollectorsConfigSetup.SelectOutlinePixelsFromList start.*/
            SelectOutlinePixelsFromList: function (pixels) {
if ( TRACE ) { TRACE( "LevelCollectorsConfigSetup#SelectOutlinePixelsFromList", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5;
                var outlinePixels = new (System.Collections.Generic.List$1(PaintingPixel)).ctor();
                var addedPixels = new (System.Collections.Generic.HashSet$1(PaintingPixel)).ctor();

                var pixelsByRow = System.Linq.Enumerable.from(pixels, PaintingPixel).groupBy(function (p) {
                        return p.row;
                    }).toList(System.Linq.Grouping$2);
                var pixelsByColumn = System.Linq.Enumerable.from(pixels, PaintingPixel).groupBy(function (p) {
                        return p.column;
                    }).toList(System.Linq.Grouping$2);

                $t = Bridge.getEnumerator(pixelsByRow);
                try {
                    while ($t.moveNext()) {
                        var rowGroup = $t.Current;
                        var rowPixels = rowGroup.toList(PaintingPixel);
                        var minCol = 2147483647, maxCol = -2147483648;

                        $t1 = Bridge.getEnumerator(rowPixels);
                        try {
                            while ($t1.moveNext()) {
                                var pixel = $t1.Current;
                                minCol = UnityEngine.Mathf.Min(minCol, pixel.column);
                                maxCol = UnityEngine.Mathf.Max(maxCol, pixel.column);
                            }
                        } finally {
                            if (Bridge.is($t1, System.IDisposable)) {
                                $t1.System$IDisposable$Dispose();
                            }
                        }

                        $t2 = Bridge.getEnumerator(rowPixels);
                        try {
                            while ($t2.moveNext()) {
                                var pixel1 = $t2.Current;
                                if (pixel1.column === minCol || pixel1.column === maxCol) {
                                    if (addedPixels.add(pixel1)) {
                                        outlinePixels.add(pixel1);
                                    }
                                }
                            }
                        } finally {
                            if (Bridge.is($t2, System.IDisposable)) {
                                $t2.System$IDisposable$Dispose();
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                $t3 = Bridge.getEnumerator(pixelsByColumn);
                try {
                    while ($t3.moveNext()) {
                        var colGroup = $t3.Current;
                        var colPixels = colGroup.toList(PaintingPixel);
                        var minRow = 2147483647, maxRow = -2147483648;

                        $t4 = Bridge.getEnumerator(colPixels);
                        try {
                            while ($t4.moveNext()) {
                                var pixel2 = $t4.Current;
                                minRow = UnityEngine.Mathf.Min(minRow, pixel2.row);
                                maxRow = UnityEngine.Mathf.Max(maxRow, pixel2.row);
                            }
                        } finally {
                            if (Bridge.is($t4, System.IDisposable)) {
                                $t4.System$IDisposable$Dispose();
                            }
                        }

                        $t5 = Bridge.getEnumerator(colPixels);
                        try {
                            while ($t5.moveNext()) {
                                var pixel3 = $t5.Current;
                                if (pixel3.row === minRow || pixel3.row === maxRow) {
                                    if (addedPixels.add(pixel3)) {
                                        outlinePixels.add(pixel3);
                                    }
                                }
                            }
                        } finally {
                            if (Bridge.is($t5, System.IDisposable)) {
                                $t5.System$IDisposable$Dispose();
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t3, System.IDisposable)) {
                        $t3.System$IDisposable$Dispose();
                    }
                }

                return outlinePixels;
            },
            /*LevelCollectorsConfigSetup.SelectOutlinePixelsFromList end.*/

            /*LevelCollectorsConfigSetup.FindNonHiddenPixelsAt start.*/
            FindNonHiddenPixelsAt: function (pixels, column, row) {
if ( TRACE ) { TRACE( "LevelCollectorsConfigSetup#FindNonHiddenPixelsAt", this ); }

                var rs = new (System.Collections.Generic.List$1(PaintingPixel)).ctor();
                for (var i = 0; i < pixels.Count; i = (i + 1) | 0) {
                    if (pixels.getItem(i).column === column && pixels.getItem(i).row === row && !pixels.getItem(i).Hidden) {
                        rs.add(pixels.getItem(i));
                    }
                }
                return rs;
            },
            /*LevelCollectorsConfigSetup.FindNonHiddenPixelsAt end.*/

            /*LevelCollectorsConfigSetup.StartUpTool start.*/
            StartUpTool: function () {
if ( TRACE ) { TRACE( "LevelCollectorsConfigSetup#StartUpTool", this ); }

                this.ToolActive = !this.ToolActive;
                if (this.ToolActive) {
                    this.CountGunnersAsSet();

                    this.ReCountCollectors();

                    this.LoadConfigAsset(this.CurentCollectorsConfig);
                }
            },
            /*LevelCollectorsConfigSetup.StartUpTool end.*/

            /*LevelCollectorsConfigSetup.CountGunnersAsSet start.*/
            CountGunnersAsSet: function () {
if ( TRACE ) { TRACE( "LevelCollectorsConfigSetup#CountGunnersAsSet", this ); }

                var $t;
                var allWorkingPixels = this.paintingConfig.GetAllWorkingPixels();
                this.NumberOfWorkingPixels = allWorkingPixels.Count;
                this.colorSetCounters.clear();
                $t = Bridge.getEnumerator(allWorkingPixels);
                try {
                    while ($t.moveNext()) {
                        var pixel = $t.Current;
                        if (pixel.Hidden || pixel == null || pixel.colorCode == null) {
                            continue;
                        } // Skip hidden pixels
                        if (this.colorSetCounters.containsKey(pixel.colorCode)) {
                            this.colorSetCounters.setItem(pixel.colorCode, (this.colorSetCounters.getItem(pixel.colorCode) + 1) | 0);
                        } else {
                            this.colorSetCounters.setItem(pixel.colorCode, 1);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*LevelCollectorsConfigSetup.CountGunnersAsSet end.*/

            /*LevelCollectorsConfigSetup.BakeCollectorsPositionInTool start.*/
            BakeCollectorsPositionInTool: function () {
if ( TRACE ) { TRACE( "LevelCollectorsConfigSetup#BakeCollectorsPositionInTool", this ); }

                this.OriginalCollectorPosition.clear();
                for (var i = 0; i < this.previewSystem.CurrentCollectors.Count; i = (i + 1) | 0) {
                    this.OriginalCollectorPosition.add(this.previewSystem.CurrentCollectors.getItem(i).transform.position.$clone());
                }

                this.OriginalLocksPosition.clear();
                for (var i1 = 0; i1 < this.previewSystem.CurrentLocks.Count; i1 = (i1 + 1) | 0) {
                    this.OriginalLocksPosition.add(this.previewSystem.CurrentLocks.getItem(i1).transform.position.$clone());
                }
            },
            /*LevelCollectorsConfigSetup.BakeCollectorsPositionInTool end.*/

            /*LevelCollectorsConfigSetup.ReApplyCollectorsPosition start.*/
            ReApplyCollectorsPosition: function () {
if ( TRACE ) { TRACE( "LevelCollectorsConfigSetup#ReApplyCollectorsPosition", this ); }

                for (var i = 0; i < this.previewSystem.CurrentCollectors.Count; i = (i + 1) | 0) {
                    this.previewSystem.CurrentCollectors.getItem(i).transform.position = this.OriginalCollectorPosition.getItem(i).$clone();
                }

                for (var i1 = 0; i1 < this.previewSystem.CurrentLocks.Count; i1 = (i1 + 1) | 0) {
                    this.previewSystem.CurrentLocks.getItem(i1).transform.position = this.OriginalLocksPosition.getItem(i1).$clone();
                }
            },
            /*LevelCollectorsConfigSetup.ReApplyCollectorsPosition end.*/

            /*LevelCollectorsConfigSetup.ReCountCollectors start.*/
            ReCountCollectors: function () {
if ( TRACE ) { TRACE( "LevelCollectorsConfigSetup#ReCountCollectors", this ); }

                var $t;
                this.TotalBulletsCount = 0;
                this.collectorSetCounters.clear();
                $t = Bridge.getEnumerator(this.previewSystem.CurrentCollectors);
                try {
                    while ($t.moveNext()) {
                        var collector = $t.Current;
                        if (this.collectorSetCounters.containsKey(collector.CollectorColor)) {
                            this.collectorSetCounters.setItem(collector.CollectorColor, (this.collectorSetCounters.getItem(collector.CollectorColor) + 1) | 0);
                        } else {
                            this.collectorSetCounters.setItem(collector.CollectorColor, 1);
                        }
                        this.TotalBulletsCount = (this.TotalBulletsCount + collector.BulletCapacity) | 0;
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.NumberOfLockedCollector = this.previewSystem.CurrentLocks.Count;
            },
            /*LevelCollectorsConfigSetup.ReCountCollectors end.*/

            /*LevelCollectorsConfigSetup.ReArrangeCollectorBullets start.*/
            ReArrangeCollectorBullets: function (_collectors, maxBullets) {
if ( TRACE ) { TRACE( "LevelCollectorsConfigSetup#ReArrangeCollectorBullets", this ); }

                if (maxBullets === void 0) { maxBullets = 20; }
                var rs = new (System.Collections.Generic.List$1(SingleColorCollectorConfig)).$ctor1(_collectors);
                if (rs == null || rs.Count === 0) {
                    return null;
                }

                var i = 0;
                while (i < rs.Count) {
                    var current = rs.getItem(i);

                    if (current.Bullets >= maxBullets) {
                        i = (i + 1) | 0;
                        continue;
                    }

                    var j = (i + 1) | 0;
                    while (j < rs.Count && current.Bullets < maxBullets) {
                        var donor = rs.getItem(j);
                        if (Bridge.referenceEquals(donor.ColorCode, current.ColorCode) && donor.Bullets > 0) {
                            var needed = (maxBullets - current.Bullets) | 0;
                            var take = UnityEngine.Mathf.Min(needed, donor.Bullets);
                            current.Bullets = (current.Bullets + take) | 0;
                            donor.Bullets = (donor.Bullets - take) | 0;

                            if (donor.Bullets === 0) {
                                rs.removeAt(j);
                                j = (j - 1) | 0;
                            }
                        }

                        j = (j + 1) | 0;
                    }

                    i = (i + 1) | 0;
                }

                return rs;
            },
            /*LevelCollectorsConfigSetup.ReArrangeCollectorBullets end.*/

            /*LevelCollectorsConfigSetup.SwapCollectors start.*/
            SwapCollectors: function (a, b) {
if ( TRACE ) { TRACE( "LevelCollectorsConfigSetup#SwapCollectors", this ); }

                var $t;
                if (UnityEngine.MonoBehaviour.op_Equality(a, null) || UnityEngine.MonoBehaviour.op_Equality(b, null) || UnityEngine.MonoBehaviour.op_Equality(a, b)) {
                    return;
                }

                var columnA = null;
                var columnB = null;

                $t = Bridge.getEnumerator(this.previewSystem.ObjectsInColumns);
                try {
                    while ($t.moveNext()) {
                        var column = $t.Current;
                        if (column.CollectorsInColumn.contains(a)) {
                            columnA = column;
                        }
                        if (column.CollectorsInColumn.contains(b)) {
                            columnB = column;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                // Khng tm thy column th khng swap c
                if (columnA == null || columnB == null) {
                    return;
                }

                var listA = columnA.CollectorsInColumn;
                var listB = columnB.CollectorsInColumn;

                // Ly v tr
                var indexA = listA.indexOf(a);
                var indexB = listB.indexOf(b);

                // --- Nu cng column, swap trc tip ---
                if (Bridge.referenceEquals(columnA, columnB)) {
                    Bridge.Deconstruct(new (System.ValueTuple$2(CollectorMachanicObjectBase,CollectorMachanicObjectBase)).$ctor1(listA.getItem(indexB), listA.getItem(indexA)).$clone(), Bridge.ref(listA.getItem(indexA)), Bridge.ref(listA.getItem(indexB)));
                } else {
                    listA.removeAt(indexA);
                    listB.removeAt(indexB);

                    listA.insert(indexA, b);
                    listB.insert(indexB, a);
                }

                this.previewSystem.ReArrangePosition();
                this.previewSystem.SetupConnectedCollectors();
            },
            /*LevelCollectorsConfigSetup.SwapCollectors end.*/

            /*LevelCollectorsConfigSetup.InsertAmongOtherCollector start.*/
            InsertAmongOtherCollector: function (itemToInsert, originItem, higher) {
if ( TRACE ) { TRACE( "LevelCollectorsConfigSetup#InsertAmongOtherCollector", this ); }

                var $t;
                var sameColumn = false;
                var targetColumnToMoveTo = null;
                var originColumn = null;
                $t = Bridge.getEnumerator(this.previewSystem.ObjectsInColumns);
                try {
                    while ($t.moveNext()) {
                        var column = $t.Current;
                        if (column.CollectorsInColumn.contains(originItem)) {
                            targetColumnToMoveTo = column;
                            if (column.CollectorsInColumn.contains(itemToInsert)) {
                                sameColumn = true;
                                break;
                            }
                        }

                        if (column.CollectorsInColumn.contains(itemToInsert)) {
                            originColumn = column;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                if (sameColumn) {
                    PaintingSharedAttributes.MoveRelative(CollectorMachanicObjectBase, targetColumnToMoveTo.CollectorsInColumn, itemToInsert, originItem, higher);
                } else {
                    originColumn.CollectorsInColumn.remove(itemToInsert);
                    PaintingSharedAttributes.InsertRelative(CollectorMachanicObjectBase, targetColumnToMoveTo.CollectorsInColumn, itemToInsert, originItem, higher);
                }
                this.previewSystem.ReArrangePosition();
                this.previewSystem.SetupConnectedCollectors();
            },
            /*LevelCollectorsConfigSetup.InsertAmongOtherCollector end.*/

            /*LevelCollectorsConfigSetup.InsertNewToOtherCollector start.*/
            InsertNewToOtherCollector: function (itemToInsert, originItem, higher) {
if ( TRACE ) { TRACE( "LevelCollectorsConfigSetup#InsertNewToOtherCollector", this ); }

                var $t;
                var sameColumn = false;
                var targetColumnToMoveTo = null;
                var originColumn = null;
                $t = Bridge.getEnumerator(this.previewSystem.ObjectsInColumns);
                try {
                    while ($t.moveNext()) {
                        var column = $t.Current;
                        if (column.CollectorsInColumn.contains(originItem)) {
                            targetColumnToMoveTo = column;
                            if (column.CollectorsInColumn.contains(itemToInsert)) {
                                sameColumn = true;
                                break;
                            }
                        }

                        if (column.CollectorsInColumn.contains(originItem)) {
                            originColumn = column;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                if (sameColumn) {
                    PaintingSharedAttributes.MoveRelative(CollectorMachanicObjectBase, targetColumnToMoveTo.CollectorsInColumn, itemToInsert, originItem, higher);
                } else {
                    originColumn.CollectorsInColumn.remove(itemToInsert);
                    PaintingSharedAttributes.InsertRelative(CollectorMachanicObjectBase, targetColumnToMoveTo.CollectorsInColumn, itemToInsert, originItem, higher);
                }
                this.previewSystem.ReArrangePosition();
                this.previewSystem.SetupConnectedCollectors();
            },
            /*LevelCollectorsConfigSetup.InsertNewToOtherCollector end.*/

            /*LevelCollectorsConfigSetup.SplitACollector start.*/
            SplitACollector: function (originItem) {
if ( TRACE ) { TRACE( "LevelCollectorsConfigSetup#SplitACollector", this ); }

                var maxBullets = originItem.BulletCapacity;
                if (maxBullets <= 1) {
                    return;
                }
                var originObjBullets = (Bridge.Int.div(maxBullets, 2)) | 0;
                var cloneObjBullets = (maxBullets - originObjBullets) | 0;

                var newCollector = this.previewSystem.CloneNewFromCollector(originItem);

                originItem.BulletCapacity = originObjBullets;
                newCollector.BulletCapacity = cloneObjBullets;

                this.InsertNewToOtherCollector(newCollector, originItem, false);

                this.previewSystem.ReArrangePosition();
                this.previewSystem.SetupConnectedCollectors();
            },
            /*LevelCollectorsConfigSetup.SplitACollector end.*/

            /*LevelCollectorsConfigSetup.Save start.*/
            Save: function () {
if ( TRACE ) { TRACE( "LevelCollectorsConfigSetup#Save", this ); }
 },
            /*LevelCollectorsConfigSetup.Save end.*/


        }
    });
    /*LevelCollectorsConfigSetup end.*/

    /*LevelCollectorsSystem start.*/
    Bridge.define("LevelCollectorsSystem", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                _staticProcessedIndices: null,
                _staticQueue: null,
                _tempVisited: null,
                _tempQueue: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "LevelCollectorsSystem#init", this ); }

                    this._staticProcessedIndices = new (System.Collections.Generic.HashSet$1(System.Int32)).ctor();
                    this._staticQueue = new (System.Collections.Generic.Queue$1(ColorPixelsCollectorObject)).ctor();
                    this._tempVisited = new (System.Collections.Generic.HashSet$1(CollectorController)).ctor();
                    this._tempQueue = new (System.Collections.Generic.Queue$1(CollectorController)).ctor();
                }
            }
        },
        fields: {
            LevelSetup: null,
            CurrentLevelCollectorsConfig: null,
            FormationCenter: null,
            SpaceBetweenColumns: 0,
            SpaceBetweenCollectors: 0,
            CollectorContainer: null,
            CollectorRotation: null,
            PrefabSource: null,
            CurrentLocks: null,
            CurrentCollectors: null,
            ObjectsInColumns: null,
            CollectorControllersColumns: null,
            CurrentTotalCollectors: 0,
            _tempProgressedIndex: null,
            _tempCurrentGroup: null,
            _collectorIndexByID: null,
            collectorControllersByID: null,
            _collectorsByID: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "LevelCollectorsSystem#init", this ); }

                this.CollectorRotation = new UnityEngine.Vector3();
                this.SpaceBetweenColumns = 1.0;
                this.SpaceBetweenCollectors = 1.0;
                this.CollectorRotation = pc.Vec3.ZERO.clone();
                this.CurrentTotalCollectors = 0;
                this.collectorControllersByID = new (System.Collections.Generic.Dictionary$2(System.Int32,CollectorController)).ctor();
                this._collectorsByID = new (System.Collections.Generic.Dictionary$2(System.Int32,ColorPixelsCollectorObject)).ctor();
            }
        },
        methods: {
            /*LevelCollectorsSystem.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "LevelCollectorsSystem#Awake", this ); }

                GameplayEventsManager.GetFirstCollector = Bridge.fn.combine(GameplayEventsManager.GetFirstCollector, Bridge.fn.cacheBind(this, this.GetFirstCollector));
                GameplayEventsManager.OnCollectAKey = Bridge.fn.combine(GameplayEventsManager.OnCollectAKey, Bridge.fn.cacheBind(this, this.OnPlayerCollectAKey));
            },
            /*LevelCollectorsSystem.Awake end.*/

            /*LevelCollectorsSystem.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "LevelCollectorsSystem#OnDestroy", this ); }

                GameplayEventsManager.GetFirstCollector = Bridge.fn.remove(GameplayEventsManager.GetFirstCollector, Bridge.fn.cacheBind(this, this.GetFirstCollector));
                GameplayEventsManager.OnCollectAKey = Bridge.fn.remove(GameplayEventsManager.OnCollectAKey, Bridge.fn.cacheBind(this, this.OnPlayerCollectAKey));
            },
            /*LevelCollectorsSystem.OnDestroy end.*/

            /*LevelCollectorsSystem.GetFirstCollector start.*/
            GetFirstCollector: function () {
if ( TRACE ) { TRACE( "LevelCollectorsSystem#GetFirstCollector", this ); }

                if (this.CurrentCollectors.Count > 0) {
                    return this.CurrentCollectors.getItem(0).transform;
                }
                return null;
            },
            /*LevelCollectorsSystem.GetFirstCollector end.*/

            /*LevelCollectorsSystem.SetupCollectorsAndMechanic start.*/
            SetupCollectorsAndMechanic: function () {
if ( TRACE ) { TRACE( "LevelCollectorsSystem#SetupCollectorsAndMechanic", this ); }

                // Clear any existing collectors
                this.ClearExistingLocks();
                this.ClearExistingCollectors();

                if (this.CurrentLevelCollectorsConfig == null) {
                    UnityEngine.Debug.LogWarning$1("No LevelColorCollectorsConfig assigned!");
                    return;
                }

                if (UnityEngine.GameObject.op_Equality(this.PrefabSource.GunnerPrefab, null)) {
                    UnityEngine.Debug.LogError$2("CollectorPrefab is not assigned!");
                    return;
                }

                if (this.CurrentLevelCollectorsConfig.CollectorColumns == null || this.CurrentLevelCollectorsConfig.CollectorColumns.Count === 0) {
                    UnityEngine.Debug.LogWarning$1("No collector setups found in the config!");
                    return;
                }

                var numberOfColumns = this.CurrentLevelCollectorsConfig.NumberOfColumns();

                if (numberOfColumns <= 0) {
                    UnityEngine.Debug.LogWarning$1("NumberOfColumns must be greater than 0!");
                    numberOfColumns = 1; // Default to 1 column if not set properly
                }

                // Initialize lists with capacity to avoid resizing
                this.InitializeCollections();

                this.SetUpAndArrangePosition(numberOfColumns);
                this.SetupConnectedCollectors();
            },
            /*LevelCollectorsSystem.SetupCollectorsAndMechanic end.*/

            /*LevelCollectorsSystem.InitializeCollections start.*/
            InitializeCollections: function () {
if ( TRACE ) { TRACE( "LevelCollectorsSystem#InitializeCollections", this ); }

                // Reuse existing collections instead of creating new ones
                this.CurrentLocks = this.CurrentLocks || new (System.Collections.Generic.List$1(LockObject)).ctor();
                this.CurrentCollectors = this.CurrentCollectors || new (System.Collections.Generic.List$1(ColorPixelsCollectorObject)).ctor();
                this.ObjectsInColumns = this.ObjectsInColumns || new (System.Collections.Generic.List$1(CollectorColumn)).ctor();
                this.CollectorControllersColumns = this.CollectorControllersColumns || new (System.Collections.Generic.List$1(System.Collections.Generic.List$1(CollectorController))).ctor();
                this._tempProgressedIndex = this._tempProgressedIndex || new (System.Collections.Generic.List$1(System.Int32)).ctor();
                this._tempCurrentGroup = this._tempCurrentGroup || new (System.Collections.Generic.List$1(ColorPixelsCollectorObject)).ctor();
                this._collectorIndexByID = this._collectorIndexByID || new (System.Collections.Generic.Dictionary$2(System.Int32,System.Int32)).ctor();
                this._collectorsByID = this._collectorsByID || new (System.Collections.Generic.Dictionary$2(System.Int32,ColorPixelsCollectorObject)).ctor();

                // Clear existing data
                this.CurrentLocks.clear();
                this.CurrentCollectors.clear();
                this.ObjectsInColumns.clear();
                this.CollectorControllersColumns.clear();
                this.collectorControllersByID.clear();
                this._collectorIndexByID.clear();
                this._collectorsByID.clear();
            },
            /*LevelCollectorsSystem.InitializeCollections end.*/

            /*LevelCollectorsSystem.CreateLockObject start.*/
            CreateLockObject: function () {
if ( TRACE ) { TRACE( "LevelCollectorsSystem#CreateLockObject", this ); }

                var config = new LockObjectConfig();
                // Spawn the collector with specified rotation

                var spawnPosition = this.FormationCenter.position.$clone();

                // Apply horizontal offset (perpendicular to forward direction) based on column
                spawnPosition = spawnPosition.$clone().add( this.FormationCenter.right.$clone().clone().scale( (0 - (((this.CurrentLevelCollectorsConfig.NumberOfColumns() - 1) | 0)) / 2.0) ).clone().scale( this.SpaceBetweenColumns ) );

                // Apply depth offset (opposite to forward direction) based on row
                spawnPosition = spawnPosition.$clone().sub( this.FormationCenter.forward.$clone().clone().scale( (this.ObjectsInColumns.getItem(0).CollectorsInColumn.Count) ).clone().scale( this.SpaceBetweenCollectors ) );

                var lockGO = UnityEngine.Object.Instantiate$3(UnityEngine.GameObject, this.PrefabSource.LockPrefab, spawnPosition, pc.Quat.IDENTITY.clone(), this.CollectorContainer);
                lockGO.transform.localEulerAngles = this.CollectorRotation.$clone();
                var lockObj = lockGO.GetComponent(LockObject);

                if (UnityEngine.MonoBehaviour.op_Inequality(lockObj, null)) {
                    lockObj.ID = config.ID;
                    lockObj.Row = config.Row;

                    // Add to our lists
                    this.ObjectsInColumns.getItem(0).CollectorsInColumn.add(lockObj);
                    this.CurrentLocks.add(lockObj);
                }
            },
            /*LevelCollectorsSystem.CreateLockObject end.*/

            /*LevelCollectorsSystem.ClearExistingCollectors start.*/
            ClearExistingCollectors: function () {
if ( TRACE ) { TRACE( "LevelCollectorsSystem#ClearExistingCollectors", this ); }

                var $t;
                if (this.CurrentCollectors != null) {
                    $t = Bridge.getEnumerator(this.CurrentCollectors);
                    try {
                        while ($t.moveNext()) {
                            var collector = $t.Current;
                            if (UnityEngine.MonoBehaviour.op_Inequality(collector, null)) {
                                UnityEngine.Object.DestroyImmediate(collector.gameObject);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    this.CurrentCollectors.clear();
                }

                if (this.ObjectsInColumns != null) {
                    this.ObjectsInColumns.clear();
                }

                if (this.CollectorControllersColumns != null) {
                    this.CollectorControllersColumns.clear();
                }
            },
            /*LevelCollectorsSystem.ClearExistingCollectors end.*/

            /*LevelCollectorsSystem.SetupConnectedCollectors start.*/
            SetupConnectedCollectors: function () {
if ( TRACE ) { TRACE( "LevelCollectorsSystem#SetupConnectedCollectors", this ); }

                var $t;
                // Reuse pre-allocated collections to avoid GC allocations
                this._tempProgressedIndex.clear();
                this._tempCurrentGroup.clear();

                for (var i = 0; i < this.CurrentCollectors.Count; i = (i + 1) | 0) {
                    var collector = this.CurrentCollectors.getItem(i);
                    if (UnityEngine.MonoBehaviour.op_Equality(collector, null)) {
                        continue;
                    }

                    if (this._tempProgressedIndex.contains(i)) {
                        continue;
                    }

                    if (collector.ConnectedCollectorsIDs.Count <= 0) {
                        this._tempProgressedIndex.add(i);
                        collector.VisualHandler.SetupRope(false, null);
                        continue;
                    }

                    this._tempCurrentGroup.clear();
                    this._tempCurrentGroup.add(collector);
                    this._tempProgressedIndex.add(i);

                    // Tm tt c cc collector c kt ni (optimized BFS)
                    LevelCollectorsSystem._staticProcessedIndices.clear();
                    LevelCollectorsSystem._staticProcessedIndices.unionWith(this._tempProgressedIndex);
                    LevelCollectorsSystem._staticQueue.Clear();
                    LevelCollectorsSystem._staticQueue.Enqueue(collector);

                    while (LevelCollectorsSystem._staticQueue.Count > 0) {
                        var currentCollector = LevelCollectorsSystem._staticQueue.Dequeue();

                        $t = Bridge.getEnumerator(currentCollector.ConnectedCollectorsIDs);
                        try {
                            while ($t.moveNext()) {
                                var _id = $t.Current;
                                var _index = { };
                                var connectTarget = this.GetCollectorByID(_id, _index);

                                if (_index.v === -1) {
                                    continue;
                                }
                                if (LevelCollectorsSystem._staticProcessedIndices.contains(_index.v)) {
                                    continue;
                                }

                                LevelCollectorsSystem._staticProcessedIndices.add(_index.v);
                                this._tempCurrentGroup.add(connectTarget);
                                LevelCollectorsSystem._staticQueue.Enqueue(connectTarget);
                            }
                        } finally {
                            if (Bridge.is($t, System.IDisposable)) {
                                $t.System$IDisposable$Dispose();
                            }
                        }
                    }

                    // Setup ropes between connected collectors to form a chain (like connected rope)
                    for (var j = 0; j < ((this._tempCurrentGroup.Count - 1) | 0); j = (j + 1) | 0) {
                        this._tempCurrentGroup.getItem(j).VisualHandler.SetupRope(true, this._tempCurrentGroup.getItem(((j + 1) | 0)).VisualHandler);
                        // #if UNITY_EDITOR
                        //                 _tempCurrentGroup[j].VisualHandler.TankRopeMesh.OnValidate();
                        // #endif
                    }
                }

                this.SetupCollectorControllersConnect();
            },
            /*LevelCollectorsSystem.SetupConnectedCollectors end.*/

            /*LevelCollectorsSystem.SetupCollectorControllersConnect start.*/
            SetupCollectorControllersConnect: function () {
if ( TRACE ) { TRACE( "LevelCollectorsSystem#SetupCollectorControllersConnect", this ); }

                var $t;
                // S dng Dictionary  to  bc 1
                if (this.collectorControllersByID == null) {
                    return;
                }

                $t = Bridge.getEnumerator(this.collectorControllersByID.Values);
                try {
                    while ($t.moveNext()) {
                        var controller = { v : $t.Current };
                        // Reset danh sch kt ni
                        controller.v.collectorConnect != null ? controller.v.collectorConnect.clear() : null;
                        if (controller.v.collectorConnect == null) {
                            controller.v.collectorConnect = new (System.Collections.Generic.List$1(CollectorController)).ctor();
                        }

                        // Tm tt c cc controller trong nhm kt ni ca controller ny
                        var connectedGroup = this.FindConnectedGroup(controller.v);

                        // Sp xp theo th t ct
                        var sortedGroup = System.Linq.Enumerable.from(connectedGroup, CollectorController).orderBy(function (c) {
                                return c.ColumnIndex;
                            }).toList(CollectorController);

                        // Gn nhm  sp xp cho controller
                        controller.v.collectorConnect.AddRange(sortedGroup);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*LevelCollectorsSystem.SetupCollectorControllersConnect end.*/

            /*LevelCollectorsSystem.FindConnectedGroup start.*/
            FindConnectedGroup: function (startController) {
if ( TRACE ) { TRACE( "LevelCollectorsSystem#FindConnectedGroup", this ); }

                var $t;
                // Clear static collections to avoid allocations
                LevelCollectorsSystem._tempVisited.clear();
                LevelCollectorsSystem._tempQueue.Clear();

                LevelCollectorsSystem._tempVisited.add(startController);
                LevelCollectorsSystem._tempQueue.Enqueue(startController);

                while (LevelCollectorsSystem._tempQueue.Count > 0) {
                    var current = LevelCollectorsSystem._tempQueue.Dequeue();
                    var cp = current.ColorCollector;
                    if (UnityEngine.MonoBehaviour.op_Equality(cp, null) || cp.ConnectedCollectorsIDs == null) {
                        continue;
                    }

                    $t = Bridge.getEnumerator(cp.ConnectedCollectorsIDs);
                    try {
                        while ($t.moveNext()) {
                            var nextId = $t.Current;
                            var nextController = this.FindCollectorControllerByID(nextId);
                            if (UnityEngine.MonoBehaviour.op_Inequality(nextController, null) && !LevelCollectorsSystem._tempVisited.contains(nextController)) {
                                LevelCollectorsSystem._tempVisited.add(nextController);
                                LevelCollectorsSystem._tempQueue.Enqueue(nextController);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                // Return the visited set (this is the static one, be careful with reuse)
                return LevelCollectorsSystem._tempVisited;
            },
            /*LevelCollectorsSystem.FindConnectedGroup end.*/

            /*LevelCollectorsSystem.FindCollectorControllerByID start.*/
            FindCollectorControllerByID: function (id) {
if ( TRACE ) { TRACE( "LevelCollectorsSystem#FindCollectorControllerByID", this ); }

                var controller = { };
                this.collectorControllersByID.tryGetValue(id, controller);
                return controller.v; // S tr v controller nu tm thy, hoc null nu khng.
            },
            /*LevelCollectorsSystem.FindCollectorControllerByID end.*/

            /*LevelCollectorsSystem.SetUpAndArrangePosition start.*/
            SetUpAndArrangePosition: function (collumnCount) {
if ( TRACE ) { TRACE( "LevelCollectorsSystem#SetUpAndArrangePosition", this ); }

                var $t;
                this.ObjectsInColumns = new (System.Collections.Generic.List$1(CollectorColumn)).ctor();
                this.CollectorControllersColumns = new (System.Collections.Generic.List$1(System.Collections.Generic.List$1(CollectorController))).ctor();
                this.collectorControllersByID.clear();
                var col = 0;
                $t = Bridge.getEnumerator(this.CurrentLevelCollectorsConfig.CollectorColumns);
                try {
                    while ($t.moveNext()) {
                        var colConfig = $t.Current;
                        var row = 0;
                        var locks = colConfig.Locks;
                        var collectors = colConfig.Collectors;
                        var colObjects = new CollectorColumn();
                        var collectorControllersInThisColumn = new (System.Collections.Generic.List$1(CollectorController)).ctor();

                        var totalObjectCount = (collectors.Count + locks.Count) | 0;

                        var lockIndex = 0;
                        var collectorIndex = 0;

                        for (var i = { v : 0 }; i.v < totalObjectCount; i.v = (i.v + 1) | 0) {

                            // Calculate the position relative to the formation center (which is the highest point)
                            // Use the formation center's transform to properly orient the formation
                            var spawnPosition = this.FormationCenter.position.$clone();

                            // Apply horizontal offset (perpendicular to forward direction) based on column
                            spawnPosition = spawnPosition.$clone().add( this.FormationCenter.right.$clone().clone().scale( (col - (((collumnCount - 1) | 0)) / 2.0) ).clone().scale( this.SpaceBetweenColumns ) );

                            // Apply depth offset (opposite to forward direction) based on row
                            spawnPosition = spawnPosition.$clone().sub( this.FormationCenter.forward.$clone().clone().scale( row ).clone().scale( this.SpaceBetweenCollectors ) );

                            if (System.Linq.Enumerable.from(locks, LockObjectConfig).any((function ($me, i) {
                                    return function (x) {
                                        return x.Row === i.v;
                                    };
                                })(this, i))) {
                                var config = locks.getItem(lockIndex);
                                // Spawn the collector with specified rotation
                                var lockGO = UnityEngine.Object.Instantiate$3(UnityEngine.GameObject, this.PrefabSource.LockPrefab, spawnPosition, pc.Quat.IDENTITY.clone(), this.CollectorContainer);
                                lockGO.transform.localEulerAngles = this.CollectorRotation.$clone();
                                var lockObj = lockGO.GetComponent(LockObject);

                                if (UnityEngine.MonoBehaviour.op_Inequality(lockObj, null)) {
                                    lockObj.ID = config.ID;
                                    lockObj.Row = config.Row;
                                    // Add to our lists
                                    colObjects.CollectorsInColumn.add(lockObj);
                                    this.CurrentLocks.add(lockObj);
                                    var controller = lockObj.GetComponent(CollectorController);

                                    if (!this.collectorControllersByID.containsKey(lockObj.ID)) {
                                        this.collectorControllersByID.add(lockObj.ID, controller);
                                    } else {
                                        UnityEngine.Debug.LogWarning$1(System.String.format("Tr\u00f9ng l\u1eb7p ID c\u1ee7a Lock: {0}. S\u1ebd ghi \u0111\u00e8.", [Bridge.box(lockObj.ID, System.Int32)]), this);
                                        this.collectorControllersByID.setItem(lockObj.ID, controller);
                                    }
                                    controller.IndexInColumn = row;
                                    controller.LockController = lockObj;
                                    controller.IsLockObject = true;
                                    controller.ColumnIndex = col;
                                    collectorControllersInThisColumn.add(controller);
                                }
                                lockIndex = (lockIndex + 1) | 0;
                            } else {
                                var config1 = collectors.getItem(collectorIndex);

                                // Spawn the collector with specified rotation
                                var collectorObj = UnityEngine.Object.Instantiate$3(UnityEngine.GameObject, this.PrefabSource.GunnerPrefab, spawnPosition, pc.Quat.IDENTITY.clone(), this.CollectorContainer);
                                collectorObj.transform.localEulerAngles = this.CollectorRotation.$clone();
                                var controller1 = collectorObj.GetComponent(CollectorController);
                                if (UnityEngine.MonoBehaviour.op_Equality(controller1, null)) {
                                    UnityEngine.Debug.LogError$2("CollectorPrefab does not have CollectorController component!");
                                    continue;
                                }
                                var pixelsCollector = controller1.ColorCollector;

                                if (UnityEngine.MonoBehaviour.op_Inequality(pixelsCollector, null)) {
                                    controller1.IndexInColumn = i.v;
                                    controller1.ColumnIndex = col;
                                    controller1.LockController = null;
                                    controller1.IsLockObject = false;
                                    pixelsCollector.ID = config1.ID;
                                    controller1.SetFadeBulletText(controller1.IndexInColumn > 0);
                                    if (!this.collectorControllersByID.containsKey(pixelsCollector.ID)) {
                                        this.collectorControllersByID.add(pixelsCollector.ID, controller1);
                                    } else {
                                        UnityEngine.Debug.LogWarning$1(System.String.format("Tr\u00f9ng l\u1eb7p ID c\u1ee7a Collector: {0}. S\u1ebd ghi \u0111\u00e8.", [Bridge.box(pixelsCollector.ID, System.Int32)]), this);
                                        this.collectorControllersByID.setItem(pixelsCollector.ID, controller1);
                                    }
                                    // Find color from palette based on ColorCode
                                    if (this.PrefabSource.ColorPallete != null && this.PrefabSource.ColorPallete.colorPallete.containsKey(config1.ColorCode)) {
                                        // Set the collector's color and shooting color
                                        pixelsCollector.CollectorColor = config1.ColorCode;
                                        pixelsCollector.VisualHandler.SetColor(config1.ColorCode);
                                    } else {
                                        pixelsCollector.CollectorColor = "Undefined";
                                    }

                                    // Apply bullet settings
                                    pixelsCollector.BulletCapacity = config1.Bullets;
                                    pixelsCollector.BulletLeft = config1.Bullets;
                                    pixelsCollector.ConnectedCollectorsIDs = new (System.Collections.Generic.List$1(System.Int32)).$ctor1(config1.ConnectedCollectorsIDs);
                                    pixelsCollector.IsLocked = config1.Locked;
                                    pixelsCollector.IsHidden = config1.Hidden;
                                    pixelsCollector.CurrentGrid = this.LevelSetup.CurrentGridObject;
                                    pixelsCollector.IsCollectorActive = false;
                                    // Set locked state (this might be handled by deactivating the collector)
                                    if (false) {
                                        pixelsCollector.SetCollectorActive(!config1.Locked);
                                    }

                                    //pixelsCollector.IsCollectorActive = false;
                                    pixelsCollector.ApplyHiddenState();
                                    pixelsCollector.ApplyLockedState();

                                    // Add to our lists
                                    colObjects.CollectorsInColumn.add(pixelsCollector);
                                    this.CurrentCollectors.add(pixelsCollector);
                                    // Update index dictionary for O(1) lookup
                                    this._collectorIndexByID.setItem(pixelsCollector.ID, (this.CurrentCollectors.Count - 1) | 0);
                                    // Also add to the direct collectors dictionary for O(1) lookup
                                    if (!this._collectorsByID.containsKey(pixelsCollector.ID)) {
                                        this._collectorsByID.add(pixelsCollector.ID, pixelsCollector);
                                    } else {
                                        // In case of ID collision, log a warning and overwrite
                                        UnityEngine.Debug.LogWarning$1(System.String.format("Tr\u00f9ng l\u1eb7p ID c\u1ee7a Collector trong _collectorsByID: {0}. S\u1ebd ghi \u0111\u00e8.", [Bridge.box(pixelsCollector.ID, System.Int32)]), this);
                                        this._collectorsByID.setItem(pixelsCollector.ID, pixelsCollector);
                                    }
                                    collectorControllersInThisColumn.add(controller1);
                                }
                                collectorIndex = (collectorIndex + 1) | 0;
                            }

                            row = (row + 1) | 0;
                        }
                        this.CollectorControllersColumns.add(collectorControllersInThisColumn);
                        col = (col + 1) | 0;
                        this.ObjectsInColumns.add(colObjects);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                this.CurrentTotalCollectors = this.CurrentCollectors.Count;
                this.OnInitializedCollectors();
            },
            /*LevelCollectorsSystem.SetUpAndArrangePosition end.*/

            /*LevelCollectorsSystem.ReArrangePosition start.*/
            ReArrangePosition: function () {
if ( TRACE ) { TRACE( "LevelCollectorsSystem#ReArrangePosition", this ); }

                var $t;
                var col = 0;
                $t = Bridge.getEnumerator(this.ObjectsInColumns);
                try {
                    while ($t.moveNext()) {
                        var column = $t.Current;
                        var row = 0;
                        var columnCount = this.ObjectsInColumns.Count;
                        var collectors = column.CollectorsInColumn;
                        for (var i = 0; i < collectors.Count; i = (i + 1) | 0) {
                            // Calculate the position relative to the formation center (which is the highest point)
                            // Use the formation center's transform to properly orient the formation
                            var spawnPosition = this.FormationCenter.position.$clone();

                            // Apply horizontal offset (perpendicular to forward direction) based on column
                            spawnPosition = spawnPosition.$clone().add( this.FormationCenter.right.clone().scale( (col - (((columnCount - 1) | 0)) / 2.0) * this.SpaceBetweenColumns ) );

                            // Apply depth offset (opposite to forward direction) based on row
                            spawnPosition = spawnPosition.$clone().sub( this.FormationCenter.forward.clone().scale( row * this.SpaceBetweenCollectors ) );

                            // Spawn the collector with specified rotation
                            collectors.getItem(i).transform.position = spawnPosition.$clone();
                            collectors.getItem(i).transform.localEulerAngles = this.CollectorRotation.$clone();
                            var colorCollector;
                            // Update index dictionary if this is a ColorPixelsCollectorObject
                            // Avoid expensive CurrentCollectors.IndexOf call by using the collector's ID directly
                            if (UnityEngine.MonoBehaviour.op_Inequality(((colorCollector = Bridge.as(collectors.getItem(i), ColorPixelsCollectorObject))), null)) {
                                // We don't need to update the index in _collectorIndexByID here because the position in the CurrentCollectors list hasn't changed
                                // The positions are just being updated in the world, not the order in the list
                                // Only update if the collector is in our main dictionary
                                if (this._collectorsByID.containsKey(colorCollector.ID)) {
                                    // The index in CurrentCollectors remains the same, only world position changes
                                    // No need to update the dictionary since the order hasn't changed
                                }
                            }

                            row = (row + 1) | 0;
                        }
                        col = (col + 1) | 0;
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*LevelCollectorsSystem.ReArrangePosition end.*/

            /*LevelCollectorsSystem.OnPlayerCollectAKey start.*/
            OnPlayerCollectAKey: function () {
if ( TRACE ) { TRACE( "LevelCollectorsSystem#OnPlayerCollectAKey", this ); }

                var lockToUnlock = this.GetFirstLockedCollectorMet();
                if (UnityEngine.MonoBehaviour.op_Inequality(lockToUnlock, null)) {
                    lockToUnlock.Unlock();
                }
            },
            /*LevelCollectorsSystem.OnPlayerCollectAKey end.*/

            /*LevelCollectorsSystem.OnInitializedCollectors start.*/
            OnInitializedCollectors: function () {
if ( TRACE ) { TRACE( "LevelCollectorsSystem#OnInitializedCollectors", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.CollectorControllersColumns);
                try {
                    while ($t.moveNext()) {
                        var column = { v : $t.Current };
                        if (column.v != null && column.v.Count > 0 && !column.v.getItem(0).IsLockObject) {
                            !Bridge.staticEquals(GameplayEventsManager.OnCollectorMoveToFirstLine, null) ? GameplayEventsManager.OnCollectorMoveToFirstLine(column.v.getItem(0), column.v.getItem(0).ColorCollector.IsHidden) : null;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*LevelCollectorsSystem.OnInitializedCollectors end.*/

            /*LevelCollectorsSystem.GetFirstLockedCollectorMet start.*/
            GetFirstLockedCollectorMet: function () {
if ( TRACE ) { TRACE( "LevelCollectorsSystem#GetFirstLockedCollectorMet", this ); }

                var $t, $t1;
                $t = Bridge.getEnumerator(this.ObjectsInColumns);
                try {
                    while ($t.moveNext()) {
                        var column = $t.Current;
                        $t1 = Bridge.getEnumerator(column.CollectorsInColumn);
                        try {
                            while ($t1.moveNext()) {
                                var _object = $t1.Current;
                                if (Bridge.is(_object, LockObject)) {
                                    return Bridge.as(_object, LockObject);
                                }
                            }
                        } finally {
                            if (Bridge.is($t1, System.IDisposable)) {
                                $t1.System$IDisposable$Dispose();
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                return null;
            },
            /*LevelCollectorsSystem.GetFirstLockedCollectorMet end.*/

            /*LevelCollectorsSystem.RemoveCollector start.*/
            RemoveCollector: function (target) {
if ( TRACE ) { TRACE( "LevelCollectorsSystem#RemoveCollector", this ); }

                var $t;
                // Remove from dictionaries first
                if (UnityEngine.MonoBehaviour.op_Inequality(target, null)) {
                    this._collectorIndexByID.remove(target.ID);
                    this._collectorsByID.remove(target.ID);
                }

                this.CurrentCollectors.remove(target);
                $t = Bridge.getEnumerator(this.ObjectsInColumns);
                try {
                    while ($t.moveNext()) {
                        var colObjects = $t.Current;
                        if (colObjects.CollectorsInColumn.contains(target)) {
                            colObjects.CollectorsInColumn.remove(target);
                            break;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                UnityEngine.Object.DestroyImmediate(target.gameObject);
                this.ReArrangePosition();
                this.SetupConnectedCollectors();
            },
            /*LevelCollectorsSystem.RemoveCollector end.*/

            /*LevelCollectorsSystem.CloneNewFromCollector start.*/
            CloneNewFromCollector: function (original) {
if ( TRACE ) { TRACE( "LevelCollectorsSystem#CloneNewFromCollector", this ); }

                // Spawn the collector with specified rotation
                var collectorObj = UnityEngine.Object.Instantiate$3(UnityEngine.GameObject, this.PrefabSource.GunnerPrefab, pc.Vec3.ZERO.clone(), pc.Quat.IDENTITY.clone(), this.CollectorContainer);
                collectorObj.transform.localEulerAngles = this.CollectorRotation.$clone();
                var collector = collectorObj.GetComponent(ColorPixelsCollectorObject);

                if (UnityEngine.MonoBehaviour.op_Inequality(collector, null)) {
                    collector.ID = -1;

                    // Find color from palette based on ColorCode
                    if (this.PrefabSource.ColorPallete != null && this.PrefabSource.ColorPallete.colorPallete.containsKey(original.CollectorColor)) {
                        // Set the collector's color and shooting color
                        collector.CollectorColor = original.CollectorColor;
                        collector.VisualHandler.SetColor(original.CollectorColor);
                    }

                    // Apply bullet settings
                    collector.BulletCapacity = original.BulletCapacity;
                    collector.BulletLeft = original.BulletCapacity;
                    collector.ConnectedCollectorsIDs = new (System.Collections.Generic.List$1(System.Int32)).$ctor1(original.ConnectedCollectorsIDs);
                    collector.IsLocked = original.IsLocked;
                    collector.IsHidden = original.IsHidden;

                    // Set locked state (this might be handled by deactivating the collector)
                    if (false) {
                        collector.SetCollectorActive(!original.IsLocked);
                    }

                    collector.ApplyHiddenState();
                    collector.ApplyLockedState();

                    this.CurrentCollectors.add(collector);
                    // Update index dictionary for O(1) lookup
                    this._collectorIndexByID.setItem(collector.ID, (this.CurrentCollectors.Count - 1) | 0);
                    // Also add to the direct collectors dictionary for O(1) lookup if it has a valid ID
                    if (collector.ID !== -1 && !this._collectorsByID.containsKey(collector.ID)) {
                        this._collectorsByID.add(collector.ID, collector);
                    } else if (collector.ID !== -1) {
                        // In case of ID collision, log a warning and overwrite
                        UnityEngine.Debug.LogWarning$1(System.String.format("Tr\u00f9ng l\u1eb7p ID c\u1ee7a Collector trong _collectorsByID: {0}. S\u1ebd ghi \u0111\u00e8.", [Bridge.box(collector.ID, System.Int32)]), this);
                        this._collectorsByID.setItem(collector.ID, collector);
                    }
                }

                return collector;
            },
            /*LevelCollectorsSystem.CloneNewFromCollector end.*/

            /*LevelCollectorsSystem.GetCollectorByID start.*/
            GetCollectorByID: function (ID, index) {
if ( TRACE ) { TRACE( "LevelCollectorsSystem#GetCollectorByID", this ); }

                var collector = { };
                // First try to get from direct collectors dictionary for O(1) lookup
                if (this._collectorsByID.tryGetValue(ID, collector)) {
                    // Get index from the precomputed dictionary for O(1) lookup instead of O(n)
                    if (this._collectorIndexByID.tryGetValue(ID, index)) {
                        return collector.v;
                    } else {
                        // Fallback: compute index if not in dictionary
                        index.v = this.CurrentCollectors.indexOf(collector.v);
                        if (index.v >= 0) {
                            this._collectorIndexByID.setItem(collector.v.ID, index.v);
                        }
                        return collector.v;
                    }
                }

                // If not found in direct dictionary, try the old method
                var controller = this.FindCollectorControllerByID(ID);
                if (UnityEngine.MonoBehaviour.op_Inequality(controller, null) && !controller.IsLockObject && UnityEngine.MonoBehaviour.op_Inequality(controller.ColorCollector, null)) {
                    collector.v = controller.ColorCollector;
                    // Get index from the precomputed dictionary for O(1) lookup instead of O(n)
                    if (this._collectorIndexByID.tryGetValue(ID, index)) {
                        return collector.v;
                    } else {
                        // Fallback: compute index if not in dictionary
                        index.v = this.CurrentCollectors.indexOf(collector.v);
                        if (index.v >= 0) {
                            this._collectorIndexByID.setItem(collector.v.ID, index.v);
                        }
                        return collector.v;
                    }
                }

                index.v = -1;
                return null;
            },
            /*LevelCollectorsSystem.GetCollectorByID end.*/

            /*LevelCollectorsSystem.ClearExistingLocks start.*/
            ClearExistingLocks: function () {
if ( TRACE ) { TRACE( "LevelCollectorsSystem#ClearExistingLocks", this ); }

                var $t;
                if (this.CurrentLocks != null) {
                    $t = Bridge.getEnumerator(this.CurrentLocks);
                    try {
                        while ($t.moveNext()) {
                            var _lock = $t.Current;
                            if (UnityEngine.MonoBehaviour.op_Inequality(_lock, null)) {
                                UnityEngine.Object.DestroyImmediate(_lock.gameObject);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    this.CurrentLocks.clear();
                }
            },
            /*LevelCollectorsSystem.ClearExistingLocks end.*/

            /*LevelCollectorsSystem.GetBulletsByColor start.*/
            GetBulletsByColor: function (colorCode) {
if ( TRACE ) { TRACE( "LevelCollectorsSystem#GetBulletsByColor", this ); }

                var $t;
                var rs = 0;
                $t = Bridge.getEnumerator(this.CurrentCollectors);
                try {
                    while ($t.moveNext()) {
                        var collector = $t.Current;
                        if (System.String.equals(collector.CollectorColor, colorCode)) {
                            rs = (rs + collector.BulletCapacity) | 0;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return rs;
            },
            /*LevelCollectorsSystem.GetBulletsByColor end.*/


        }
    });
    /*LevelCollectorsSystem end.*/

    /*LevelColorCollectorsConfig start.*/
    Bridge.define("LevelColorCollectorsConfig", {
        inherits: [UnityEngine.ScriptableObject],
        statics: {
            methods: {
                /*LevelColorCollectorsConfig.GetCollectorConfigByID:static start.*/
                GetCollectorConfigByID: function (_list, ID) {
if ( TRACE ) { TRACE( "LevelColorCollectorsConfig#GetCollectorConfigByID", this ); }

                    for (var i = 0; i < _list.Count; i = (i + 1) | 0) {
                        if (_list.getItem(i).ID === ID) {
                            return _list.getItem(i);
                        }
                    }
                    return null;
                },
                /*LevelColorCollectorsConfig.GetCollectorConfigByID:static end.*/


            }
        },
        fields: {
            CollectorColumns: null
        },
        methods: {
            /*LevelColorCollectorsConfig.NumberOfColumns start.*/
            NumberOfColumns: function () {
if ( TRACE ) { TRACE( "LevelColorCollectorsConfig#NumberOfColumns", this ); }

                return this.CollectorColumns.Count;
            },
            /*LevelColorCollectorsConfig.NumberOfColumns end.*/

            /*LevelColorCollectorsConfig.NumberOfCollectors start.*/
            NumberOfCollectors: function () {
if ( TRACE ) { TRACE( "LevelColorCollectorsConfig#NumberOfCollectors", this ); }

                var $t;
                var num = 0;
                $t = Bridge.getEnumerator(this.CollectorColumns);
                try {
                    while ($t.moveNext()) {
                        var col = $t.Current;
                        num = (num + col.Collectors.Count) | 0;
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return num;
            },
            /*LevelColorCollectorsConfig.NumberOfCollectors end.*/

            /*LevelColorCollectorsConfig.GetAllCollectorConfigs start.*/
            GetAllCollectorConfigs: function () {
if ( TRACE ) { TRACE( "LevelColorCollectorsConfig#GetAllCollectorConfigs", this ); }

                var $t, $t1;
                var rs = new (System.Collections.Generic.List$1(SingleColorCollectorConfig)).ctor();
                var maxRow = 0;
                $t = Bridge.getEnumerator(this.CollectorColumns);
                try {
                    while ($t.moveNext()) {
                        var col = $t.Current;
                        if (col.Collectors.Count > maxRow) {
                            maxRow = col.Collectors.Count;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                for (var i = 0; i < maxRow; i = (i + 1) | 0) {
                    $t1 = Bridge.getEnumerator(this.CollectorColumns);
                    try {
                        while ($t1.moveNext()) {
                            var col1 = $t1.Current;
                            if (i < col1.Collectors.Count) {
                                rs.add(col1.Collectors.getItem(i));
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                }

                return rs;
            },
            /*LevelColorCollectorsConfig.GetAllCollectorConfigs end.*/

            /*LevelColorCollectorsConfig.RemoveCollector start.*/
            RemoveCollector: function (id) {
if ( TRACE ) { TRACE( "LevelColorCollectorsConfig#RemoveCollector", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.CollectorColumns);
                try {
                    while ($t.moveNext()) {
                        var col = $t.Current;
                        col.Collectors.RemoveAll(function (c) {
                            return c.ID === id;
                        });
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.ReArrangeID();
            },
            /*LevelColorCollectorsConfig.RemoveCollector end.*/

            /*LevelColorCollectorsConfig.ReArrangeID start.*/
            ReArrangeID: function () {
if ( TRACE ) { TRACE( "LevelColorCollectorsConfig#ReArrangeID", this ); }

                var $t;
                var rs = this.GetAllCollectorConfigs();
                // Create a map oldID -> newID (index in list)
                var idMap = new (System.Collections.Generic.Dictionary$2(System.Int32,System.Int32)).ctor();

                for (var i = 0; i < rs.Count; i = (i + 1) | 0) {
                    idMap.setItem(rs.getItem(i).ID, i);
                }

                // Update IDs to new ids
                for (var i1 = 0; i1 < rs.Count; i1 = (i1 + 1) | 0) {
                    rs.getItem(i1).ID = i1;
                }

                // Update ConnectedIDs according to the map
                $t = Bridge.getEnumerator(rs);
                try {
                    while ($t.moveNext()) {
                        var obj = $t.Current;
                        for (var j = 0; j < obj.ConnectedCollectorsIDs.Count; j = (j + 1) | 0) {
                            var oldID = obj.ConnectedCollectorsIDs.getItem(j);
                            obj.ConnectedCollectorsIDs.setItem(j, idMap.getItem(oldID));
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                for (var i2 = 0; i2 < rs.Count; i2 = (i2 + 1) | 0) {
                    rs.getItem(i2).ID = i2;
                }
            },
            /*LevelColorCollectorsConfig.ReArrangeID end.*/

            /*LevelColorCollectorsConfig.EnsureBidirectionalConnections start.*/
            EnsureBidirectionalConnections: function () {
if ( TRACE ) { TRACE( "LevelColorCollectorsConfig#EnsureBidirectionalConnections", this ); }

                var $t, $t1;
                var allCollectorConfig = new (System.Collections.Generic.List$1(SingleColorCollectorConfig)).ctor();

                $t = Bridge.getEnumerator(this.CollectorColumns);
                try {
                    while ($t.moveNext()) {
                        var column = $t.Current;
                        allCollectorConfig.AddRange(column.Collectors);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                if (allCollectorConfig.Count <= 0) {
                    return;
                }

                // Iterate through each collector in the config
                for (var i = 0; i < allCollectorConfig.Count; i = (i + 1) | 0) {
                    var collector = allCollectorConfig.getItem(i);

                    // For each connection in this collector, ensure the reverse connection exists
                    $t1 = Bridge.getEnumerator(collector.ConnectedCollectorsIDs);
                    try {
                        while ($t1.moveNext()) {
                            var connectedID = $t1.Current;
                            if (connectedID === collector.ID) {
                                continue;
                            }
                            if (connectedID >= 0) {
                                var targetCollector = LevelColorCollectorsConfig.GetCollectorConfigByID(allCollectorConfig, connectedID);
                                if (targetCollector == null || targetCollector.ID === collector.ID) {
                                    return;
                                }

                                // If the target collector doesn't have this collector in its connections, add it
                                if (!targetCollector.ConnectedCollectorsIDs.contains(collector.ID)) {
                                    targetCollector.ConnectedCollectorsIDs.add(collector.ID);
                                    UnityEngine.Debug.Log$1(System.String.format("Added reverse connection: Collector {0} now connected to ID {1}", Bridge.box(connectedID, System.Int32), Bridge.box(collector.ID, System.Int32)));
                                }
                            } else {
                                UnityEngine.Debug.LogWarning$1(System.String.format("Invalid connection index {0} in collector {1}", Bridge.box(connectedID, System.Int32), Bridge.box(i, System.Int32)));
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                }

                UnityEngine.Debug.Log$1(System.String.format("Ensured bidirectional connections for {0} collectors in {1}", Bridge.box(allCollectorConfig.Count, System.Int32), allCollectorConfig));
            },
            /*LevelColorCollectorsConfig.EnsureBidirectionalConnections end.*/

            /*LevelColorCollectorsConfig.NumberOfLocks start.*/
            NumberOfLocks: function () {
if ( TRACE ) { TRACE( "LevelColorCollectorsConfig#NumberOfLocks", this ); }

                var $t;
                var num = 0;
                $t = Bridge.getEnumerator(this.CollectorColumns);
                try {
                    while ($t.moveNext()) {
                        var col = $t.Current;
                        num = (num + col.Locks.Count) | 0;
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return num;
            },
            /*LevelColorCollectorsConfig.NumberOfLocks end.*/

            /*LevelColorCollectorsConfig.ClearData start.*/
            ClearData: function () {
if ( TRACE ) { TRACE( "LevelColorCollectorsConfig#ClearData", this ); }

                this.CollectorColumns = new (System.Collections.Generic.List$1(ColumnOfCollectorConfig)).ctor();
            },
            /*LevelColorCollectorsConfig.ClearData end.*/


        }
    });
    /*LevelColorCollectorsConfig end.*/

    /*LevelColorCollectorsConfigBackUp start.*/
    Bridge.define("LevelColorCollectorsConfigBackUp", {
        fields: {
            DateTime: null,
            CollectorColumns: null
        },
        ctors: {
            ctor: function (_stock) {
if ( TRACE ) { TRACE( "LevelColorCollectorsConfigBackUp#ctor", this ); }

                var $t;
                this.$initialize();
                this.DateTime = System.DateTime.format(System.DateTime.getNow(), "yyyy-MM-dd HH:mm:ss");
                this.CollectorColumns = new (System.Collections.Generic.List$1(ColumnOfCollectorConfig)).ctor();
                $t = Bridge.getEnumerator(_stock.CollectorColumns);
                try {
                    while ($t.moveNext()) {
                        var c = $t.Current;
                        this.CollectorColumns.add(new ColumnOfCollectorConfig.$ctor1(c));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            }
        }
    });
    /*LevelColorCollectorsConfigBackUp end.*/

    /*LevelConfig start.*/
    Bridge.define("LevelConfig", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            BlocksPaintingConfig: null,
            CollectorsConfig: null,
            ColorsUsed: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "LevelConfig#init", this ); }

                this.ColorsUsed = new (System.Collections.Generic.List$1(System.String)).ctor();
            }
        }
    });
    /*LevelConfig end.*/

    /*LevelConfigGetAllColorCode start.*/
    Bridge.define("LevelConfigGetAllColorCode", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            Levels: null
        },
        methods: {
            /*LevelConfigGetAllColorCode.ExtractColorCodes start.*/
            ExtractColorCodes: function () {
if ( TRACE ) { TRACE( "LevelConfigGetAllColorCode#ExtractColorCodes", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.Levels);
                try {
                    while ($t.moveNext()) {
                        var level = $t.Current;
                        if (level.BlocksPaintingConfig != null) {
                            level.ColorsUsed = System.Linq.Enumerable.from(level.BlocksPaintingConfig.Pixels, PaintingPixelConfig).select(function (p) {
                                    return p.colorCode;
                                }).distinct().toList(System.String);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*LevelConfigGetAllColorCode.ExtractColorCodes end.*/


        }
    });
    /*LevelConfigGetAllColorCode end.*/

    /*LevelConfigSetup start.*/
    Bridge.define("LevelConfigSetup", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                tempColorList: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "LevelConfigSetup#init", this ); }

                    this.tempColorList = new (System.Collections.Generic.List$1(System.String)).ctor();
                }
            }
        },
        fields: {
            EDITOR: false,
            NewTargetPainting: null,
            ColorCodesUsed: null,
            CurrentGridObject: null,
            CurrentGridObjects: null,
            CurrentLevel: null,
            CurrentLevelPaintingConfig: null,
            CurrentLevelCollectorConfig: null,
            CurrentLevelPainting: null,
            CurrentLevelColorCodes: null,
            PaintingSetup: null,
            PipeObjectSetup: null,
            WallObjectSetup: null,
            KeyObjectSetup: null,
            LevelCollectorsManager: null,
            LevelCollectorsSetup: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "LevelConfigSetup#init", this ); }

                this.EDITOR = false;
                this.ColorCodesUsed = new (System.Collections.Generic.List$1(System.String)).ctor();
                this.CurrentLevelColorCodes = new (System.Collections.Generic.List$1(System.String)).ctor();
            }
        },
        methods: {
            /*LevelConfigSetup.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "LevelConfigSetup#OnValidate", this ); }

                // Hm ny chy trong editor khi c thay i
                // Nu ang chy game th khng lm g
                if (UnityEngine.Application.isPlaying) {
                    return;
                }
                // Thit lp li cc components
                this.SetUpComponents();
            },
            /*LevelConfigSetup.OnValidate end.*/

            /*LevelConfigSetup.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "LevelConfigSetup#Start", this ); }

                // Nu ch  EDITOR c bt th load level
                if (this.EDITOR) {
                    this.LoadLevel();
                }
            },
            /*LevelConfigSetup.Start end.*/

            /*LevelConfigSetup.LoadLevel$1 start.*/
            LoadLevel$1: function (levelConfig) {
if ( TRACE ) { TRACE( "LevelConfigSetup#LoadLevel$1", this ); }

                // Gn cu hnh level mi
                this.CurrentLevel = levelConfig;
                // Thit lp cc components cn thit cho level
                this.SetUpComponents();
                // Gi phng thc load level khng tham s
                this.LoadLevel();
            },
            /*LevelConfigSetup.LoadLevel$1 end.*/

            /*LevelConfigSetup.LoadLevel start.*/
            LoadLevel: function () {
if ( TRACE ) { TRACE( "LevelConfigSetup#LoadLevel", this ); }

                this.ClearLevel();
                // Kim tra nu khng c level no c gn th khng lm g
                if (this.CurrentLevel == null) {
                    return;
                }
                //Chn grid object ph hp vi kch thc level
                this.SelectGridObject();

                // Thit lp collectors v c ch hot ng
                this.LevelCollectorsManager.SetupCollectorsAndMechanic();
                // Khi to level vi cu hnh painting
                this.CurrentGridObject.InitializeLevel(this.CurrentLevel.BlocksPaintingConfig);
            },
            /*LevelConfigSetup.LoadLevel end.*/

            /*LevelConfigSetup.ClearLevel start.*/
            ClearLevel: function () {
if ( TRACE ) { TRACE( "LevelConfigSetup#ClearLevel", this ); }

                // Xa cc kha hin c
                this.LevelCollectorsManager.ClearExistingLocks();
                // Xa cc collector hin c
                this.LevelCollectorsManager.ClearExistingCollectors();
                // Xa tt c cc key trn grid
                this.CurrentGridObject.ClearAllKeys();
                // Xa tt c cc pipe trn grid
                this.CurrentGridObject.ClearAllPipes();
                // Xa tt c cc wall trn grid
                this.CurrentGridObject.ClearAllWalls();
                // t ton b grid v mu trng
                this.CurrentGridObject.ClearToWhite();
            },
            /*LevelConfigSetup.ClearLevel end.*/

            /*LevelConfigSetup.SetUpComponents start.*/
            /**
             * Thit lp cc components cn thit cho level
             *
             * @instance
             * @public
             * @this LevelConfigSetup
             * @memberof LevelConfigSetup
             * @return  {void}
             */
            SetUpComponents: function () {
if ( TRACE ) { TRACE( "LevelConfigSetup#SetUpComponents", this ); }

                if (this.CurrentLevel == null) {
                    // Nu khng c level no c gn th xa cc cu hnh hin ti
                    this.CurrentLevelPaintingConfig = null;
                    this.CurrentLevelCollectorConfig = null;
                    this.CurrentLevelPainting = null;
                    return;
                }

                // Ti u: S dng danh sch tm  trnh to object mi nhiu ln
                LevelConfigSetup.tempColorList.clear();
                LevelConfigSetup.tempColorList.AddRange(this.CurrentLevel.ColorsUsed);
                this.CurrentLevelColorCodes.clear();
                this.CurrentLevelColorCodes.AddRange(LevelConfigSetup.tempColorList);
                // Gn danh sch m mu cho grid object hin ti
                this.CurrentGridObject.CurrentLevelColor = this.CurrentLevelColorCodes;
                // Gn cu hnh collector cho level hin ti
                this.CurrentLevelCollectorConfig = this.CurrentLevel.CollectorsConfig;
                // Gn cu hnh painting cho level hin ti
                this.CurrentLevelPaintingConfig = this.CurrentLevel.BlocksPaintingConfig;

                // Nu c cu hnh painting th gn sprite cho level hin ti
                if (this.CurrentLevelPaintingConfig != null) {
                    this.CurrentLevelPainting = this.CurrentLevelPaintingConfig.Sprite;
                }

                // Thit lp painting nu tn ti
                if (UnityEngine.Object.op_Implicit(this.PaintingSetup)) {
                    this.PaintingSetup.CurrentGridObject = this.CurrentGridObject;
                    this.PaintingSetup.CurrentPaintingConfig = this.CurrentLevelPaintingConfig;
                }

                // Thit lp pipe object nu tn ti
                if (UnityEngine.Object.op_Implicit(this.PipeObjectSetup)) {
                    this.PipeObjectSetup.CurrentLevelObjectSetups = this.CurrentLevelPaintingConfig.PipeSetups;
                }

                // Thit lp wall object nu tn ti
                if (UnityEngine.Object.op_Implicit(this.WallObjectSetup)) {
                    this.WallObjectSetup.CurrentLevelWallObjectSetups = this.CurrentLevelPaintingConfig.WallSetups;
                }

                // Thit lp level collectors manager nu tn ti
                if (UnityEngine.Object.op_Implicit(this.LevelCollectorsManager)) {
                    this.LevelCollectorsManager.CurrentLevelCollectorsConfig = this.CurrentLevelCollectorConfig;
                }

                // Thit lp level collectors config nu tn ti
                if (UnityEngine.Object.op_Implicit(this.LevelCollectorsSetup)) {
                    this.LevelCollectorsSetup.CurentCollectorsConfig = this.CurrentLevelCollectorConfig;
                    this.LevelCollectorsSetup.paintingConfig = this.CurrentLevelPaintingConfig;
                }

                // Thit lp key object nu tn ti
                if (UnityEngine.Object.op_Implicit(this.KeyObjectSetup)) {
                    this.KeyObjectSetup.CurrentLevelKeyObjectSetups = this.CurrentLevelPaintingConfig.KeySetups;
                }
            },
            /*LevelConfigSetup.SetUpComponents end.*/

            /*LevelConfigSetup.SelectGridObject start.*/
            SelectGridObject: function () {
if ( TRACE ) { TRACE( "LevelConfigSetup#SelectGridObject", this ); }

                // Ti u: n grid object hin ti trc
                UnityEngine.MonoBehaviour.op_Inequality(this.CurrentGridObject, null) ? this.CurrentGridObject.gameObject.SetActive(false) : null;
                var gridObject = null;

                // Ti u: Cache gi tr  trnh truy cp nhiu ln
                var targetSize = this.CurrentLevel.BlocksPaintingConfig.PaintingSize.$clone();

                // Duyt qua danh sch grid objects  tm kch thc ph hp
                for (var i = 0; i < this.CurrentGridObjects.Count; i = (i + 1) | 0) {
                    var _grid = this.CurrentGridObjects.getItem(i);
                    if (pc.Vec2.equals( _grid.gridSize, targetSize )) {
                        gridObject = _grid;
                        break;
                    }
                }
                this.CurrentGridObject = gridObject;
                this.CurrentGridObject.gameObject.SetActive(true);
            },
            /*LevelConfigSetup.SelectGridObject end.*/


        },
        overloads: {
            "LoadLevel(LevelConfig)": "LoadLevel$1"
        }
    });
    /*LevelConfigSetup end.*/

    /*LevelGamePlayConfigSO start.*/
    Bridge.define("LevelGamePlayConfigSO", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            levelConfigDataList: null
        },
        methods: {
            /*LevelGamePlayConfigSO.GetLevelConfigData start.*/
            GetLevelConfigData: function (levelId) {
if ( TRACE ) { TRACE( "LevelGamePlayConfigSO#GetLevelConfigData", this ); }

                if (levelId < 0 || levelId >= this.levelConfigDataList.Count) {
                    UnityEngine.Debug.LogError$2("Level ID is out of range: " + levelId + ". Returning first level config.");
                    return this.levelConfigDataList.getItem(0);
                }

                return this.levelConfigDataList.getItem(levelId); // Khng cn -1
            },
            /*LevelGamePlayConfigSO.GetLevelConfigData end.*/

            /*LevelGamePlayConfigSO.GetLevelToLoad start.*/
            GetLevelToLoad: function (playerCurrentLevel) {
if ( TRACE ) { TRACE( "LevelGamePlayConfigSO#GetLevelToLoad", this ); }

                var levelCount = this.levelConfigDataList.Count;

                // Player level tnh t 1 nn convert v index 0-based
                var levelToLoad = (playerCurrentLevel - 1) | 0;

                if (levelToLoad < 0) {
                    levelToLoad = 0;
                }

                // Loop t level cui
                var loopStart = (levelCount - 1) | 0;

                if (levelToLoad >= levelCount) {
                    levelToLoad = (loopStart + (((levelToLoad - loopStart) | 0)) % 1) | 0;
                }

                return levelToLoad;
            },
            /*LevelGamePlayConfigSO.GetLevelToLoad end.*/


        }
    });
    /*LevelGamePlayConfigSO end.*/

    /*LevelMechanicObjectPrefabs start.*/
    Bridge.define("LevelMechanicObjectPrefabs", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            PipeObjectPrefab: null,
            PipeHeadPrefab: null,
            PipeBodyPrefab: null,
            PipeTailPrefab: null,
            KeyObjectPrefab: null,
            LockPrefab: null,
            BigBlockPrefab: null,
            DefaultBlockPrefab: null,
            GunnerPrefab: null,
            ColorPallete: null
        }
    });
    /*LevelMechanicObjectPrefabs end.*/

    /*LockObjectConfig start.*/
    Bridge.define("LockObjectConfig", {
        fields: {
            ID: 0,
            Row: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "LockObjectConfig#init", this ); }

                this.ID = -1;
                this.Row = -1;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "LockObjectConfig#ctor", this ); }

                this.$initialize();
                this.ID = -1;
                this.Row = -1;
            }
        }
    });
    /*LockObjectConfig end.*/

    /*MathHr start.*/
    Bridge.define("MathHr", {
        statics: {
            methods: {
                /*MathHr.Remap:static start.*/
                Remap: function (main, minIn, maxIn, minOut, maxOut) {
if ( TRACE ) { TRACE( "MathHr#Remap", this ); }

                    if (maxIn - minIn === 0) {
                        return (maxOut + minOut) / 2;
                    }
                    return minOut + (main - minIn) * (maxOut - minOut) / (maxIn - minIn);
                },
                /*MathHr.Remap:static end.*/


            }
        }
    });
    /*MathHr end.*/

    /*MoveCollector start.*/
    Bridge.define("MoveCollector", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            LevelCollectorsSetup: null,
            MoveIndexOne: 0,
            MoveIndexTwo: 0,
            Gunner0ne: null,
            GunnerTwo: null
        },
        methods: {
            /*MoveCollector.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "MoveCollector#OnValidate", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.LevelCollectorsSetup, null)) {
                    return;
                }
                if (this.LevelCollectorsSetup.previewSystem.CurrentCollectors.Count <= 0) {
                    return;
                }
                if (this.MoveIndexOne < 0 || this.MoveIndexOne >= this.LevelCollectorsSetup.previewSystem.CurrentCollectors.Count) {
                    return;
                }
                if (this.MoveIndexTwo < 0 || this.MoveIndexTwo >= this.LevelCollectorsSetup.previewSystem.CurrentCollectors.Count) {
                    return;
                }
                this.Gunner0ne = this.LevelCollectorsSetup.previewSystem.CurrentCollectors.getItem(this.MoveIndexOne);
                this.GunnerTwo = this.LevelCollectorsSetup.previewSystem.CurrentCollectors.getItem(this.MoveIndexTwo);
            },
            /*MoveCollector.OnValidate end.*/

            /*MoveCollector.Move start.*/
            Move: function () {
if ( TRACE ) { TRACE( "MoveCollector#Move", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.Gunner0ne, null) || UnityEngine.MonoBehaviour.op_Equality(this.GunnerTwo, null)) {
                    return;
                }


                this.LevelCollectorsSetup.InsertAmongOtherCollector(this.Gunner0ne, this.GunnerTwo, this.IsInFrontOf(this.Gunner0ne.transform, this.GunnerTwo.transform));

                this.Gunner0ne.VisualHandler.RefreshColor();
                this.GunnerTwo.VisualHandler.RefreshColor();

                this.LevelCollectorsSetup.ImportCollectorsFromScene();
                this.LevelCollectorsSetup.BakeCollectorsPositionInTool();

                this.LevelCollectorsSetup.Save();
            },
            /*MoveCollector.Move end.*/

            /*MoveCollector.Move$1 start.*/
            Move$1: function (first, second) {
if ( TRACE ) { TRACE( "MoveCollector#Move$1", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(first, null) || UnityEngine.MonoBehaviour.op_Equality(second, null)) {
                    return;
                }

                this.LevelCollectorsSetup.InsertAmongOtherCollector(first, second, this.IsInFrontOf(first.transform, second.transform));

                this.LevelCollectorsSetup.ImportCollectorsFromScene();
                this.LevelCollectorsSetup.BakeCollectorsPositionInTool();

                this.LevelCollectorsSetup.Save();
            },
            /*MoveCollector.Move$1 end.*/

            /*MoveCollector.IsInFrontOf start.*/
            IsInFrontOf: function (first, second) {
if ( TRACE ) { TRACE( "MoveCollector#IsInFrontOf", this ); }

                var dirToFirst = first.position.$clone().sub( second.position );
                var dot = second.forward.dot( dirToFirst );
                return dot > 0.0;
            },
            /*MoveCollector.IsInFrontOf end.*/


        },
        overloads: {
            "Move(CollectorMachanicObjectBase, CollectorMachanicObjectBase)": "Move$1"
        }
    });
    /*MoveCollector end.*/

    /*MovementDirection start.*/
    Bridge.define("MovementDirection", {
        $kind: 6,
        statics: {
            fields: {
                HorizontalLeftToRight: 0,
                HorizontalRightToLeft: 1,
                VerticalBottomToTop: 2,
                VerticalTopToBottom: 3,
                Unknown: 4
            }
        }
    });
    /*MovementDirection end.*/

    /*PadController start.*/
    Bridge.define("PadController", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            meshTrans: null,
            startTrans: null,
            PadSmokeFX: null,
            padRotateTween: null,
            padMoveTween: null,
            _pendingCollector: null,
            HasCollectorOnPad: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "PadController#init", this ); }

                this.HasCollectorOnPad = false;
            }
        },
        methods: {
            /*PadController.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "PadController#Start", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(PathTransformBasedCached.Instance, null) && PathTransformBasedCached.Instance.PathPoints.Count > 0) {
                    this.startTrans = PathTransformBasedCached.Instance.PathPoints.getItem(0);
                }
            },
            /*PadController.Start end.*/

            /*PadController.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "PadController#OnDisable", this ); }

                if (!this.gameObject.scene.isLoaded) {
                    return;
                }
                // Kill ton b khi tt  trnh ghost logic
                this.CancelInvoke$1("SetPositionAfterDelay");
                DG.Tweening.ShortcutExtensions.DOKill(this.transform);
            },
            /*PadController.OnDisable end.*/

            /*PadController.OnCollectorEnterPad start.*/
            OnCollectorEnterPad: function (collector) {
if ( TRACE ) { TRACE( "PadController#OnCollectorEnterPad", this ); }

                // 1. NH DU BN NGAY LP TC
                //  hm PushForwardPad khng th tc ng vo na
                this.HasCollectorOnPad = true;

                // 2. NGT MI CHUYN NG C (Rt quan trng khi click nhanh)
                // Nu n ang trt trong pool, bt n dng ngay
                DG.Tweening.ShortcutExtensions.DOKill(this.transform);
                if (this.padMoveTween != null) {
                    DG.Tweening.TweenExtensions.Kill(this.padMoveTween);
                }

                // 3. m bo bt
                if (!this.gameObject.activeSelf) {
                    this.gameObject.SetActive(true);
                }

                // 4. Set v tr cng (Snap)
                // Khng dng Tween  y, snap ngay lp tc  trnh b tri
                if (UnityEngine.Component.op_Equality(this.startTrans, null)) {
                    this.transform.position = collector.GetPositionByTF(0);
                } else {
                    this.transform.position = this.startTrans.position.$clone();
                }

                this.meshTrans.localScale = new pc.Vec3( 1, 1, 1 ).clone().scale( 2.5 );

                // 5. Logic hn gi gn cha
                this._pendingCollector = collector;
                this.CancelInvoke$1("SetPositionAfterDelay");
                this.Invoke("SetPositionAfterDelay", 0.4);

                // 6. Anim xoay (Visual)
                if (this.padRotateTween != null) {
                    DG.Tweening.TweenExtensions.Kill(this.padRotateTween);
                }
                this.padRotateTween = DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Quaternion,DG.Tweening.Plugins.Options.NoOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Quaternion,DG.Tweening.Plugins.Options.NoOptions), DG.Tweening.ShortcutExtensions.DORotateQuaternion(this.transform, new pc.Quat().setFromEulerAngles_Unity( 0.0, 0.0, 0.0 ), 0.2), DG.Tweening.Ease.OutCubic), Bridge.fn.bind(this, function () {
                    UnityEngine.Component.op_Inequality(this.PadSmokeFX, null) ? this.PadSmokeFX.Play() : null;
                }));
            },
            /*PadController.OnCollectorEnterPad end.*/

            /*PadController.SetPositionAfterDelay start.*/
            SetPositionAfterDelay: function () {
if ( TRACE ) { TRACE( "PadController#SetPositionAfterDelay", this ); }

                // Check li ln na xem c b Reset trong lc ch khng
                if (!this.HasCollectorOnPad || UnityEngine.MonoBehaviour.op_Equality(this._pendingCollector, null) || UnityEngine.MonoBehaviour.op_Equality(this, null)) {
                    return;
                }

                if (this.gameObject.activeInHierarchy) {
                    this.transform.SetParent(this._pendingCollector.transform);
                    this.transform.localPosition = pc.Vec3.ZERO.clone();
                }
            },
            /*PadController.SetPositionAfterDelay end.*/

            /*PadController.ResetToDefault start.*/
            ResetToDefault: function (position, parent) {
if ( TRACE ) { TRACE( "PadController#ResetToDefault", this ); }

                if (parent === void 0) { parent = null; }
                // --- FIX LI TT GAME ---
                // Nu Scene ang c unload (Tt game), th khng lm g c.
                // Trnh li c gng SetParent khi object cha ang b hy.
                if (!this.gameObject.scene.isLoaded) {
                    return;
                }
                // ------------------------

                // 1. HY LOGIC C
                this.CancelInvoke$1("SetPositionAfterDelay");
                this._pendingCollector = null;

                // 2. M KHA
                this.HasCollectorOnPad = false;

                // 3. KILL TWEEN
                DG.Tweening.ShortcutExtensions.DOKill(this.transform);
                if (this.padMoveTween != null) {
                    DG.Tweening.TweenExtensions.Kill(this.padMoveTween);
                }
                if (this.padRotateTween != null) {
                    DG.Tweening.TweenExtensions.Kill(this.padRotateTween);
                }

                // 4. THIT LP LI CU TRC
                // Kim tra nu ang trong qu trnh disable  trnh li SetParent
                if (UnityEngine.Component.op_Inequality(parent, null)) {
                    // Check if we're in the middle of activation/deactivation process
                    // In which case Unity doesn't allow changing parents
                    if (this.gameObject.activeInHierarchy) {
                        try {
                            this.transform.SetParent(parent);
                        } catch ($e1) {
                            $e1 = System.Exception.create($e1);
                            // If we still get an error, defer the operation to next frame
                            this.StartCoroutine$1(this.DeferredSetParent(parent));
                        }
                    } else {
                        // If this object is being deactivated, defer the parent change
                        // But only start coroutine if the GameObject is active
                        if (this.gameObject.activeInHierarchy) {
                            this.StartCoroutine$1(this.DeferredSetParent(parent));
                        } else {
                            // If the GameObject is inactive, set the parent directly without coroutine
                            // This prevents the "Coroutine couldn't be started because the game object is inactive" error
                            try {
                                this.transform.SetParent(parent);
                            } catch (ex) {
                                ex = System.Exception.create(ex);
                                UnityEngine.Debug.LogWarning$1(System.String.format("Failed to set parent on inactive object: {0}", [ex.Message]));
                                // Fallback: set to root if we still can't set the parent
                                this.transform.SetParent(null);
                            }
                        }
                    }
                }

                this.transform.position = position.$clone();
                this.transform.rotation = new pc.Quat().setFromEulerAngles_Unity( 0.0, 0.0, 90.0 );
                this.meshTrans.localScale = new pc.Vec3( 1, 1, 1 ).clone().scale( 1.5 );
            },
            /*PadController.ResetToDefault end.*/

            /*PadController.DeferredSetParent start.*/
            DeferredSetParent: function (parent) {
if ( TRACE ) { TRACE( "PadController#DeferredSetParent", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    ex,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    // Wait one frame to ensure the activation/deactivation process is complete
                                        $enumerator.current = null;
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    try {
                                            this.transform.SetParent(parent);
                                        } catch (ex) {
                                            ex = System.Exception.create(ex);
                                            UnityEngine.Debug.LogWarning$1(System.String.format("Failed to set parent even after deferring: {0}", [ex.Message]));
                                            // Fallback: set to root if we still can't set the parent
                                            this.transform.SetParent(null);
                                        }

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*PadController.DeferredSetParent end.*/

            /*PadController.PushForwardPad start.*/
            PushForwardPad: function (targetPos) {
if ( TRACE ) { TRACE( "PadController#PushForwardPad", this ); }

                // CHT CHN: Nu Pad ny ang bn phc v Collector,
                // Tuyt i khng cho php PoolManager di chuyn n na.
                if (this.HasCollectorOnPad) {
                    return;
                }

                // Kill tween c  khng b conflict hng di chuyn
                if (this.padMoveTween != null) {
                    DG.Tweening.TweenExtensions.Kill(this.padMoveTween);
                }

                // Di chuyn mt trong h cha
                this.padMoveTween = DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMove(this.transform, targetPos.$clone(), 0.15), DG.Tweening.Ease.OutCubic);
            },
            /*PadController.PushForwardPad end.*/


        }
    });
    /*PadController end.*/

    /*PaintingAdvancedSetup start.*/
    Bridge.define("PaintingAdvancedSetup", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            LevelManager: null,
            PaintingSetup: null,
            KeySetupModule: null,
            PipeSetupModule: null,
            PaintModule: null,
            WallSetupModule: null,
            CollectorSetupModule: null,
            ToolActive: false,
            BlockObjectLayermask: null,
            SelectedItems: null,
            BGColor: null,
            currentSelectedColorCode: 0,
            heartInput: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "PaintingAdvancedSetup#init", this ); }

                this.BlockObjectLayermask = new UnityEngine.LayerMask();
                this.BGColor = new UnityEngine.Color();
                this.ToolActive = false;
                this.SelectedItems = new (System.Collections.Generic.List$1(PaintingPixelComponent)).ctor();
                this.currentSelectedColorCode = 0;
            }
        }
    });
    /*PaintingAdvancedSetup end.*/

    /*PaintingConfig start.*/
    Bridge.define("PaintingConfig", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            PaintingSize: null,
            Sprite: null,
            Pixels: null,
            PipeSetups: null,
            WallSetups: null,
            KeySetups: null,
            AdditionPixels: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "PaintingConfig#init", this ); }

                this.PaintingSize = new UnityEngine.Vector2();
                this.Pixels = new (System.Collections.Generic.List$1(PaintingPixelConfig)).ctor();
                this.PipeSetups = new (System.Collections.Generic.List$1(PipeObjectSetup)).ctor();
                this.WallSetups = new (System.Collections.Generic.List$1(WallObjectSetup)).ctor();
                this.KeySetups = new (System.Collections.Generic.List$1(KeyObjectSetup)).ctor();
                this.AdditionPixels = new (System.Collections.Generic.List$1(PaintingPixelConfig)).ctor();
            }
        },
        methods: {
            /*PaintingConfig.HidePixelsUnderPipes start.*/
            /**
             * Sets the Hidden property to true for any PaintingPixelConfig in _pixels 
             that appears in any PipeObjectSetup's PixelCovered list based on matching row and column
             *
             * @instance
             * @public
             * @this PaintingConfig
             * @memberof PaintingConfig
             * @return  {void}
             */
            HidePixelsUnderPipes: function () {
if ( TRACE ) { TRACE( "PaintingConfig#HidePixelsUnderPipes", this ); }

                var $t, $t1, $t2;
                $t = Bridge.getEnumerator(this.Pixels);
                try {
                    while ($t.moveNext()) {
                        var pixelConfig = $t.Current;
                        var isPixelUnderPipe = false;

                        // Check if this pixel config appears in any pipe setup
                        $t1 = Bridge.getEnumerator(this.PipeSetups);
                        try {
                            while ($t1.moveNext()) {
                                var pipeSetup = $t1.Current;
                                $t2 = Bridge.getEnumerator(pipeSetup.PixelCovered);
                                try {
                                    while ($t2.moveNext()) {
                                        var coveredPixel = $t2.Current;
                                        if (pixelConfig.row === coveredPixel.row && pixelConfig.column === coveredPixel.column) {
                                            isPixelUnderPipe = true;
                                            break;
                                        }
                                    }
                                } finally {
                                    if (Bridge.is($t2, System.IDisposable)) {
                                        $t2.System$IDisposable$Dispose();
                                    }
                                }

                                if (isPixelUnderPipe) {
                                    break;
                                }
                            }
                        } finally {
                            if (Bridge.is($t1, System.IDisposable)) {
                                $t1.System$IDisposable$Dispose();
                            }
                        }

                        // If the pixel is covered by a pipe, set it as hidden
                        if (isPixelUnderPipe) {
                            pixelConfig.Hidden = true;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*PaintingConfig.HidePixelsUnderPipes end.*/

            /*PaintingConfig.ReShowPixelsUnderPipe start.*/
            ReShowPixelsUnderPipe: function (_pipe) {
if ( TRACE ) { TRACE( "PaintingConfig#ReShowPixelsUnderPipe", this ); }

                var $t, $t1;
                $t = Bridge.getEnumerator(this.Pixels);
                try {
                    while ($t.moveNext()) {
                        var pixelConfig = $t.Current;
                        var isPixelUnderPipe = false;

                        // Check if this pixel config appears in any pipe setup
                        $t1 = Bridge.getEnumerator(_pipe.PaintingPixelsCovered);
                        try {
                            while ($t1.moveNext()) {
                                var coveredPixel = { v : $t1.Current };
                                if (pixelConfig.row === coveredPixel.v.row && pixelConfig.column === coveredPixel.v.column) {
                                    UnityEngine.MonoBehaviour.op_Inequality(coveredPixel.v.PixelComponent, null) ? coveredPixel.v.PixelComponent.gameObject.SetActive(true) : null;
                                    UnityEngine.MonoBehaviour.op_Inequality(coveredPixel.v.PixelComponent, null) ? coveredPixel.v.PixelComponent.ShowVisualOnly() : null;
                                    isPixelUnderPipe = true;
                                    break;
                                }
                            }
                        } finally {
                            if (Bridge.is($t1, System.IDisposable)) {
                                $t1.System$IDisposable$Dispose();
                            }
                        }

                        // If the pixel is covered by a pipe, set it as hidden
                        if (isPixelUnderPipe && !System.String.equals(pixelConfig.colorCode, PaintingSharedAttributes.TransparentColorKey)) {
                            pixelConfig.Hidden = false;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*PaintingConfig.ReShowPixelsUnderPipe end.*/

            /*PaintingConfig.GetAllWorkingPixels start.*/
            GetAllWorkingPixels: function () {
if ( TRACE ) { TRACE( "PaintingConfig#GetAllWorkingPixels", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7;
                var allPixels = new (System.Collections.Generic.List$1(PaintingPixelConfig)).ctor();

                // Add pixels from PaintingConfig.Pixels (convert from PaintingPixelConfig to PaintingPixel)
                $t = Bridge.getEnumerator(this.Pixels);
                try {
                    while ($t.moveNext()) {
                        var pixelConfig = $t.Current;
                        if (pixelConfig.Hidden || pixelConfig.color.strictEquals( PaintingSharedAttributes.TransparentColorKey )) {
                            continue;
                        }
                        allPixels.add(pixelConfig);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                // Add pixels from PipeSetups.PixelCovered
                $t1 = Bridge.getEnumerator(this.PipeSetups);
                try {
                    while ($t1.moveNext()) {
                        var pipeSetup = $t1.Current;
                        $t2 = Bridge.getEnumerator(pipeSetup.PixelCovered);
                        try {
                            while ($t2.moveNext()) {
                                var pixel = { v : $t2.Current };
                                if (System.Linq.Enumerable.from(allPixels, PaintingPixelConfig).any((function ($me, pixel) {
                                        return function (x) {
                                            return (x.column === pixel.v.column && x.row === pixel.v.row);
                                        };
                                    })(this, pixel))) {
                                    allPixels.remove(System.Linq.Enumerable.from(allPixels, PaintingPixelConfig).first((function ($me, pixel) {
                                            return function (x) {
                                                return (x.column === pixel.v.column && x.row === pixel.v.row);
                                            };
                                        })(this, pixel)));
                                }
                            }
                        } finally {
                            if (Bridge.is($t2, System.IDisposable)) {
                                $t2.System$IDisposable$Dispose();
                            }
                        }
                        for (var i = 0; i < pipeSetup.Hearts; i = (i + 1) | 0) {
                            var pixelCoveredCount = pipeSetup.PixelCovered.Count;
                            var _new = new PaintingPixelConfig.$ctor2(pipeSetup.PixelCovered.getItem(i % (((pixelCoveredCount - 1) | 0))));
                            _new.colorCode = pipeSetup.ColorCode;
                            allPixels.add(_new);
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                // Add pixels from PipeSetups.WallSetups
                $t3 = Bridge.getEnumerator(this.WallSetups);
                try {
                    while ($t3.moveNext()) {
                        var wallSetup = $t3.Current;
                        var pixelCoveredCount1 = wallSetup.PixelCovered.Count;

                        $t4 = Bridge.getEnumerator(wallSetup.PixelCovered);
                        try {
                            while ($t4.moveNext()) {
                                var _p = { v : $t4.Current };
                                if (System.Linq.Enumerable.from(allPixels, PaintingPixelConfig).any((function ($me, _p) {
                                        return function (x) {
                                            return (x.column === _p.v.column && x.row === _p.v.row);
                                        };
                                    })(this, _p))) {
                                    allPixels.remove(System.Linq.Enumerable.from(allPixels, PaintingPixelConfig).first((function ($me, _p) {
                                            return function (x) {
                                                return (x.column === _p.v.column && x.row === _p.v.row);
                                            };
                                        })(this, _p)));
                                }
                            }
                        } finally {
                            if (Bridge.is($t4, System.IDisposable)) {
                                $t4.System$IDisposable$Dispose();
                            }
                        }

                        for (var i1 = 0; i1 < wallSetup.Hearts; i1 = (i1 + 1) | 0) {
                            var _new1 = new PaintingPixelConfig.$ctor2(wallSetup.PixelCovered.getItem(i1 % (((pixelCoveredCount1 - 1) | 0))));
                            _new1.colorCode = wallSetup.ColorCode;
                            allPixels.add(_new1);
                        }
                    }
                } finally {
                    if (Bridge.is($t3, System.IDisposable)) {
                        $t3.System$IDisposable$Dispose();
                    }
                }

                // Add pixels from PipeSetups.KeySetups
                $t5 = Bridge.getEnumerator(this.KeySetups);
                try {
                    while ($t5.moveNext()) {
                        var keySetup = $t5.Current;
                        var pixelCoveredCount2 = keySetup.PixelCovered.Count;

                        $t6 = Bridge.getEnumerator(keySetup.PixelCovered);
                        try {
                            while ($t6.moveNext()) {
                                var _p1 = { v : $t6.Current };
                                if (System.Linq.Enumerable.from(allPixels, PaintingPixelConfig).any((function ($me, _p1) {
                                        return function (x) {
                                            return (x.column === _p1.v.column && x.row === _p1.v.row);
                                        };
                                    })(this, _p1))) {
                                    allPixels.remove(System.Linq.Enumerable.from(allPixels, PaintingPixelConfig).first((function ($me, _p1) {
                                            return function (x) {
                                                return (x.column === _p1.v.column && x.row === _p1.v.row);
                                            };
                                        })(this, _p1)));
                                }
                            }
                        } finally {
                            if (Bridge.is($t6, System.IDisposable)) {
                                $t6.System$IDisposable$Dispose();
                            }
                        }
                        //PaintingPixelConfig _key = new PaintingPixelConfig()
                        //{
                        //    column = keySetup.PixelCovered[0].column,
                        //    row = keySetup.PixelCovered[0].row,
                        //    color = keySetup.PixelCovered[0].color,
                        //    colorCode = LockKeyColorDefine,
                        //    Hidden = false
                        //};
                        //allPixels.Add(_key);
                    }
                } finally {
                    if (Bridge.is($t5, System.IDisposable)) {
                        $t5.System$IDisposable$Dispose();
                    }
                }

                // Add pixels from PipeSetups.AdditionPixels
                $t7 = Bridge.getEnumerator(this.AdditionPixels);
                try {
                    while ($t7.moveNext()) {
                        var _p2 = { v : $t7.Current };
                        if (_p2.v.Hidden || _p2.v.color.strictEquals( PaintingSharedAttributes.TransparentColorKey )) {
                            continue;
                        }
                        if (System.Linq.Enumerable.from(allPixels, PaintingPixelConfig).any((function ($me, _p2) {
                                return function (x) {
                                    return (x.column === _p2.v.column && x.row === _p2.v.row);
                                };
                            })(this, _p2))) {
                            allPixels.remove(System.Linq.Enumerable.from(allPixels, PaintingPixelConfig).first((function ($me, _p2) {
                                    return function (x) {
                                        return (x.column === _p2.v.column && x.row === _p2.v.row);
                                    };
                                })(this, _p2)));
                        }
                        allPixels.add(_p2.v);
                    }
                } finally {
                    if (Bridge.is($t7, System.IDisposable)) {
                        $t7.System$IDisposable$Dispose();
                    }
                }

                return allPixels;
            },
            /*PaintingConfig.GetAllWorkingPixels end.*/

            /*PaintingConfig.GetAllWorkingPixelsExceptHearts start.*/
            GetAllWorkingPixelsExceptHearts: function () {
if ( TRACE ) { TRACE( "PaintingConfig#GetAllWorkingPixelsExceptHearts", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7;
                var allPixels = new (System.Collections.Generic.List$1(PaintingPixelConfig)).ctor();

                // Add pixels from PaintingConfig.Pixels (convert from PaintingPixelConfig to PaintingPixel)
                $t = Bridge.getEnumerator(this.Pixels);
                try {
                    while ($t.moveNext()) {
                        var pixelConfig = $t.Current;
                        if (pixelConfig.Hidden || pixelConfig.color.strictEquals( PaintingSharedAttributes.TransparentColorKey )) {
                            continue;
                        }
                        allPixels.add(pixelConfig);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                // Add pixels from PipeSetups.PixelCovered
                $t1 = Bridge.getEnumerator(this.PipeSetups);
                try {
                    while ($t1.moveNext()) {
                        var pipeSetup = $t1.Current;
                        $t2 = Bridge.getEnumerator(pipeSetup.PixelCovered);
                        try {
                            while ($t2.moveNext()) {
                                var pixel = { v : $t2.Current };
                                if (System.Linq.Enumerable.from(allPixels, PaintingPixelConfig).any((function ($me, pixel) {
                                        return function (x) {
                                            return (x.column === pixel.v.column && x.row === pixel.v.row);
                                        };
                                    })(this, pixel))) {
                                    allPixels.remove(System.Linq.Enumerable.from(allPixels, PaintingPixelConfig).first((function ($me, pixel) {
                                            return function (x) {
                                                return (x.column === pixel.v.column && x.row === pixel.v.row);
                                            };
                                        })(this, pixel)));
                                }
                                pixel.v.colorCode = pipeSetup.ColorCode;
                                allPixels.add(pixel.v);
                            }
                        } finally {
                            if (Bridge.is($t2, System.IDisposable)) {
                                $t2.System$IDisposable$Dispose();
                            }
                        }
                        //for (int i = 0; i < pipeSetup.Hearts; i++)
                        //{
                        //    int pixelCoveredCount = pipeSetup.PixelCovered.Count;
                        //    PaintingPixelConfig _new = new PaintingPixelConfig(pipeSetup.PixelCovered[i % (pixelCoveredCount - 1)]);
                        //    _new.colorCode = pipeSetup.ColorCode;
                        //    allPixels.Add(_new);
                        //}
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                // Add pixels from PipeSetups.WallSetups
                $t3 = Bridge.getEnumerator(this.WallSetups);
                try {
                    while ($t3.moveNext()) {
                        var wallSetup = $t3.Current;
                        var pixelCoveredCount = wallSetup.PixelCovered.Count;

                        $t4 = Bridge.getEnumerator(wallSetup.PixelCovered);
                        try {
                            while ($t4.moveNext()) {
                                var _p = { v : $t4.Current };
                                if (System.Linq.Enumerable.from(allPixels, PaintingPixelConfig).any((function ($me, _p) {
                                        return function (x) {
                                            return (x.column === _p.v.column && x.row === _p.v.row);
                                        };
                                    })(this, _p))) {
                                    allPixels.remove(System.Linq.Enumerable.from(allPixels, PaintingPixelConfig).first((function ($me, _p) {
                                            return function (x) {
                                                return (x.column === _p.v.column && x.row === _p.v.row);
                                            };
                                        })(this, _p)));
                                }
                                _p.v.colorCode = wallSetup.ColorCode;
                                allPixels.add(_p.v);
                            }
                        } finally {
                            if (Bridge.is($t4, System.IDisposable)) {
                                $t4.System$IDisposable$Dispose();
                            }
                        }

                        //for (int i = 0; i < wallSetup.Hearts; i++)
                        //{
                        //    PaintingPixelConfig _new = new PaintingPixelConfig(wallSetup.PixelCovered[i % (pixelCoveredCount - 1)]);
                        //    _new.colorCode = wallSetup.ColorCode;
                        //    allPixels.Add(_new);
                        //}
                    }
                } finally {
                    if (Bridge.is($t3, System.IDisposable)) {
                        $t3.System$IDisposable$Dispose();
                    }
                }

                // Add pixels from PipeSetups.KeySetups
                $t5 = Bridge.getEnumerator(this.KeySetups);
                try {
                    while ($t5.moveNext()) {
                        var keySetup = $t5.Current;
                        var pixelCoveredCount1 = keySetup.PixelCovered.Count;

                        $t6 = Bridge.getEnumerator(keySetup.PixelCovered);
                        try {
                            while ($t6.moveNext()) {
                                var _p1 = { v : $t6.Current };
                                if (System.Linq.Enumerable.from(allPixels, PaintingPixelConfig).any((function ($me, _p1) {
                                        return function (x) {
                                            return (x.column === _p1.v.column && x.row === _p1.v.row);
                                        };
                                    })(this, _p1))) {
                                    allPixels.remove(System.Linq.Enumerable.from(allPixels, PaintingPixelConfig).first((function ($me, _p1) {
                                            return function (x) {
                                                return (x.column === _p1.v.column && x.row === _p1.v.row);
                                            };
                                        })(this, _p1)));
                                }
                            }
                        } finally {
                            if (Bridge.is($t6, System.IDisposable)) {
                                $t6.System$IDisposable$Dispose();
                            }
                        }
                        //PaintingPixelConfig _key = new PaintingPixelConfig()
                        //{
                        //    column = keySetup.PixelCovered[0].column,
                        //    row = keySetup.PixelCovered[0].row,
                        //    color = keySetup.PixelCovered[0].color,
                        //    colorCode = LockKeyColorDefine,
                        //    Hidden = false
                        //};
                        //allPixels.Add(_key);
                    }
                } finally {
                    if (Bridge.is($t5, System.IDisposable)) {
                        $t5.System$IDisposable$Dispose();
                    }
                }

                // Add pixels from PipeSetups.AdditionPixels
                $t7 = Bridge.getEnumerator(this.AdditionPixels);
                try {
                    while ($t7.moveNext()) {
                        var _p2 = { v : $t7.Current };
                        if (_p2.v.Hidden || _p2.v.color.strictEquals( PaintingSharedAttributes.TransparentColorKey )) {
                            continue;
                        }
                        if (System.Linq.Enumerable.from(allPixels, PaintingPixelConfig).any((function ($me, _p2) {
                                return function (x) {
                                    return (x.column === _p2.v.column && x.row === _p2.v.row);
                                };
                            })(this, _p2))) {
                            allPixels.remove(System.Linq.Enumerable.from(allPixels, PaintingPixelConfig).first((function ($me, _p2) {
                                    return function (x) {
                                        return (x.column === _p2.v.column && x.row === _p2.v.row);
                                    };
                                })(this, _p2)));
                        }
                        allPixels.add(_p2.v);
                    }
                } finally {
                    if (Bridge.is($t7, System.IDisposable)) {
                        $t7.System$IDisposable$Dispose();
                    }
                }

                return allPixels;
            },
            /*PaintingConfig.GetAllWorkingPixelsExceptHearts end.*/

            /*PaintingConfig.GetPipeSetup start.*/
            GetPipeSetup: function (startPixel, endPixel) {
if ( TRACE ) { TRACE( "PaintingConfig#GetPipeSetup", this ); }

                var $t;
                var pipeSetup = null;
                $t = Bridge.getEnumerator(this.PipeSetups);
                try {
                    while ($t.moveNext()) {
                        var setup = $t.Current;
                        if (setup.PixelCovered.Count < 2) {
                            continue;
                        }

                        var firstPixel = setup.PixelCovered.getItem(0);
                        var lastPixel = setup.PixelCovered.getItem(((setup.PixelCovered.Count - 1) | 0));

                        if ((firstPixel.column === startPixel.column && firstPixel.row === startPixel.row && lastPixel.column === endPixel.column && lastPixel.row === endPixel.row) || (firstPixel.column === endPixel.column && firstPixel.row === endPixel.row && lastPixel.column === startPixel.column && lastPixel.row === startPixel.row)) {
                            pipeSetup = setup;
                            break;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return pipeSetup;
            },
            /*PaintingConfig.GetPipeSetup end.*/

            /*PaintingConfig.GetWallSetup start.*/
            GetWallSetup: function (startPixel, endPixel) {
if ( TRACE ) { TRACE( "PaintingConfig#GetWallSetup", this ); }

                var $t;
                var wallSetup = null;
                $t = Bridge.getEnumerator(this.WallSetups);
                try {
                    while ($t.moveNext()) {
                        var setup = $t.Current;
                        if (setup.PixelCovered.Count < 2) {
                            continue;
                        }

                        var firstPixel = setup.PixelCovered.getItem(0);
                        var lastPixel = setup.PixelCovered.getItem(((setup.PixelCovered.Count - 1) | 0));
                        if ((firstPixel.column === startPixel.column && firstPixel.row === startPixel.row && lastPixel.column === endPixel.column && lastPixel.row === endPixel.row) || (firstPixel.column === endPixel.column && firstPixel.row === endPixel.row && lastPixel.column === startPixel.column && lastPixel.row === startPixel.row)) {
                            wallSetup = setup;
                            break;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return wallSetup;
            },
            /*PaintingConfig.GetWallSetup end.*/

            /*PaintingConfig.GetKeySetup start.*/
            GetKeySetup: function (startPixel, endPixel) {
if ( TRACE ) { TRACE( "PaintingConfig#GetKeySetup", this ); }

                var $t;
                var keySetup = null;
                $t = Bridge.getEnumerator(this.KeySetups);
                try {
                    while ($t.moveNext()) {
                        var setup = $t.Current;
                        var firstPixel = setup.PixelCovered.getItem(0);
                        var lastPixel = setup.PixelCovered.getItem(((setup.PixelCovered.Count - 1) | 0));

                        if ((firstPixel.column === startPixel.column && firstPixel.row === startPixel.row && lastPixel.column === endPixel.column && lastPixel.row === endPixel.row) || (firstPixel.column === endPixel.column && firstPixel.row === endPixel.row && lastPixel.column === startPixel.column && lastPixel.row === startPixel.row)) {
                            keySetup = setup;
                            break;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return keySetup;
            },
            /*PaintingConfig.GetKeySetup end.*/

            /*PaintingConfig.ClearData start.*/
            ClearData: function () {
if ( TRACE ) { TRACE( "PaintingConfig#ClearData", this ); }

                this.Pixels.clear();
                this.PipeSetups.clear();
                this.WallSetups.clear();
                this.KeySetups.clear();
                this.AdditionPixels.clear();
            },
            /*PaintingConfig.ClearData end.*/


        }
    });
    /*PaintingConfig end.*/

    /*PaintingConfigBackUp start.*/
    Bridge.define("PaintingConfigBackUp", {
        fields: {
            DateTime: null,
            _paintingSize: null,
            Pixels: null,
            PipeSetup: null,
            WallSetup: null,
            KeySetup: null,
            AdditionPixels: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "PaintingConfigBackUp#init", this ); }

                this._paintingSize = new UnityEngine.Vector2();
                this.Pixels = new (System.Collections.Generic.List$1(PaintingPixelConfig)).ctor();
                this.PipeSetup = new (System.Collections.Generic.List$1(PipeObjectSetup)).ctor();
                this.WallSetup = new (System.Collections.Generic.List$1(WallObjectSetup)).ctor();
                this.KeySetup = new (System.Collections.Generic.List$1(KeyObjectSetup)).ctor();
                this.AdditionPixels = new (System.Collections.Generic.List$1(PaintingPixelConfig)).ctor();
            },
            ctor: function (_stock) {
if ( TRACE ) { TRACE( "PaintingConfigBackUp#ctor", this ); }

                var $t, $t1, $t2, $t3, $t4;
                this.$initialize();
                this.DateTime = System.DateTime.format(System.DateTime.getNow(), "yyyy-MM-dd HH:mm:ss");
                this.Pixels = new (System.Collections.Generic.List$1(PaintingPixelConfig)).ctor();
                this.WallSetup = new (System.Collections.Generic.List$1(WallObjectSetup)).ctor();
                this.KeySetup = new (System.Collections.Generic.List$1(KeyObjectSetup)).ctor();
                this.AdditionPixels = new (System.Collections.Generic.List$1(PaintingPixelConfig)).ctor();

                $t = Bridge.getEnumerator(_stock.Pixels);
                try {
                    while ($t.moveNext()) {
                        var p = $t.Current;
                        this.Pixels.add(new PaintingPixelConfig.$ctor2(p));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                $t1 = Bridge.getEnumerator(_stock.PipeSetups);
                try {
                    while ($t1.moveNext()) {
                        var p1 = $t1.Current;
                        this.PipeSetup.add(new PipeObjectSetup.$ctor1(p1));
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                $t2 = Bridge.getEnumerator(_stock.WallSetups);
                try {
                    while ($t2.moveNext()) {
                        var w = $t2.Current;
                        this.WallSetup.add(new WallObjectSetup.$ctor2(w));
                    }
                } finally {
                    if (Bridge.is($t2, System.IDisposable)) {
                        $t2.System$IDisposable$Dispose();
                    }
                }

                $t3 = Bridge.getEnumerator(_stock.KeySetups);
                try {
                    while ($t3.moveNext()) {
                        var k = $t3.Current;
                        this.KeySetup.add(new KeyObjectSetup.$ctor1(k));
                    }
                } finally {
                    if (Bridge.is($t3, System.IDisposable)) {
                        $t3.System$IDisposable$Dispose();
                    }
                }

                $t4 = Bridge.getEnumerator(_stock.AdditionPixels);
                try {
                    while ($t4.moveNext()) {
                        var p2 = $t4.Current;
                        this.AdditionPixels.add(new PaintingPixelConfig.$ctor2(p2));
                    }
                } finally {
                    if (Bridge.is($t4, System.IDisposable)) {
                        $t4.System$IDisposable$Dispose();
                    }
                }
            }
        }
    });
    /*PaintingConfigBackUp end.*/

    /*PaintingConfigSetup start.*/
    Bridge.define("PaintingConfigSetup", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            TargetPainting: null,
            CurrentGridObject: null,
            PrefabSource: null,
            useColorFilter: false,
            ColorCodeInUse: null,
            CurrentPaintingConfig: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "PaintingConfigSetup#init", this ); }

                this.useColorFilter = false;
                this.ColorCodeInUse = new (System.Collections.Generic.List$1(System.String)).ctor();
            }
        },
        methods: {
            /*PaintingConfigSetup.SamplePaintingToGrid start.*/
            SamplePaintingToGrid: function (_sprite) {
if ( TRACE ) { TRACE( "PaintingConfigSetup#SamplePaintingToGrid", this ); }

                if (_sprite === void 0) { _sprite = null; }
                if (_sprite == null) {
                    _sprite = this.TargetPainting;
                }
                if (_sprite == null) {
                    UnityEngine.Debug.LogError$2("TargetPainting sprite is not assigned!");
                    return;
                }

                if (UnityEngine.MonoBehaviour.op_Equality(this.CurrentGridObject, null)) {
                    UnityEngine.Debug.LogError$2("TargetGrid is not assigned!");
                    return;
                }

                if (this.PrefabSource.ColorPallete == null) {
                    UnityEngine.Debug.LogError$2("ColorPalette is not assigned!");
                    return;
                }

                // Get grid size from target grid
                var gridSize = this.CurrentGridObject.gridSize.$clone();
                var gridWidth = Bridge.Int.clip32(gridSize.x);
                var gridHeight = Bridge.Int.clip32(gridSize.y);

                if (gridWidth <= 0 || gridHeight <= 0) {
                    UnityEngine.Debug.LogError$2("Invalid grid size!");
                    return;
                }

                // Get the texture from the sprite
                var paintingTexture = this.GetTextureFromSprite(_sprite);
                if (paintingTexture == null) {
                    UnityEngine.Debug.LogError$2("Could not get texture from sprite!");
                    return;
                }

                // Sample colors from painting based on grid dimensions
                var pixels = new (System.Collections.Generic.List$1(PaintingPixelConfig)).ctor();

                // Calculate half dimensions for coordinate transformation
                var halfWidth = ((Bridge.Int.div(gridWidth, 2)) | 0);
                var halfHeight = ((Bridge.Int.div(gridHeight, 2)) | 0);

                for (var row = 0; row < gridHeight; row = (row + 1) | 0) {
                    for (var col = 0; col < gridWidth; col = (col + 1) | 0) {
                        // Calculate the center position of the grid cell in the painting texture
                        var texX = (col + 0.5) * paintingTexture.width / gridWidth;
                        var texY = (row + 0.5) * paintingTexture.height / gridHeight;

                        // Get the color at the center of the grid cell
                        var sampledColor = paintingTexture.GetPixel(Bridge.Int.clip32(texX), Bridge.Int.clip32(texY));
                        var closestColor = { v : new UnityEngine.Color() };
                        var colorCode = { };
                        Bridge.Deconstruct(this.FindClosestColorInPalette(sampledColor, this.PrefabSource.ColorPallete).$clone(), closestColor, colorCode);

                        // Transform coordinates to match GridGenerator system (center at 0,0 with negative indices)
                        // For columns: from right (positive) to left (negative)
                        var gridCol = (((col - halfWidth) | 0) + (gridWidth % 2 === 0 ? 1 : 0)) | 0;
                        if (gridWidth % 2 === 0) {
                            gridCol = (gridCol - 1) | 0; // Adjust for even number of columns
                        }

                        // For rows: from bottom (negative) to top (positive) 
                        var gridRow = (row - halfHeight) | 0;
                        if (gridHeight % 2 === 0) {
                            // No adjustment needed for even number of rows in this implementation
                        }

                        // Create a new pixel config
                        var pixelConfig = new PaintingPixelConfig.ctor();
                        pixelConfig.row = gridRow;
                        pixelConfig.column = gridCol;
                        pixelConfig.color = closestColor.v.$clone();
                        pixelConfig.colorCode = colorCode.v;
                        pixelConfig.Hidden = System.String.equals(colorCode.v, PaintingSharedAttributes.TransparentColorKey);

                        pixels.add(pixelConfig);
                    }
                }

                // Create and configure the PaintingConfig asset
                this.CreatePaintingConfigAsset(pixels, gridSize, _sprite);
                this.CurrentGridObject.ApplyPaintingConfig(this.CurrentPaintingConfig);
            },
            /*PaintingConfigSetup.SamplePaintingToGrid end.*/

            /*PaintingConfigSetup.GetTextureFromSprite start.*/
            GetTextureFromSprite: function (sprite) {
if ( TRACE ) { TRACE( "PaintingConfigSetup#GetTextureFromSprite", this ); }

                if (sprite == null || sprite.texture == null) {
                    return null;
                }

                // If the sprite texture is readable, we can use it directly
                if (sprite.texture.isReadable) {
                    return sprite.texture;
                } else {
                    // If not readable, we need to create a readable copy
                    var readableTexture = new UnityEngine.Texture2D.$ctor11(sprite.texture.width, sprite.texture.height, UnityEngine.TextureFormat.RGBA32, false);
                    var renderTexture = UnityEngine.RenderTexture.GetTemporary$3(sprite.texture.width, sprite.texture.height, 0, UnityEngine.RenderTextureFormat.Default, UnityEngine.RenderTextureReadWrite.Linear);

                    // Set the sprite texture to the render texture
                    UnityEngine.Graphics.Blit(sprite.texture, renderTexture);

                    // Store the previous render texture
                    var previous = UnityEngine.RenderTexture.active;
                    UnityEngine.RenderTexture.active = renderTexture;

                    // Copy the pixels from the render texture to the readable texture
                    readableTexture.ReadPixels(new UnityEngine.Rect.$ctor1(0, 0, renderTexture.width, renderTexture.height), 0, 0);
                    readableTexture.Apply();

                    // Restore the previous render texture
                    UnityEngine.RenderTexture.active = previous;
                    UnityEngine.RenderTexture.ReleaseTemporary(renderTexture);

                    return readableTexture;
                }
            },
            /*PaintingConfigSetup.GetTextureFromSprite end.*/

            /*PaintingConfigSetup.ExtractColorCodesFromPainting start.*/
            ExtractColorCodesFromPainting: function (_sprite) {
if ( TRACE ) { TRACE( "PaintingConfigSetup#ExtractColorCodesFromPainting", this ); }

                if (_sprite === void 0) { _sprite = null; }
                if (_sprite == null) {
                    _sprite = this.TargetPainting;
                }
                if (_sprite == null) {
                    UnityEngine.Debug.LogError$2("TargetPainting sprite is not assigned!");
                    return;
                }

                if (UnityEngine.MonoBehaviour.op_Equality(this.CurrentGridObject, null)) {
                    UnityEngine.Debug.LogError$2("TargetGrid is not assigned!");
                    return;
                }

                if (this.PrefabSource.ColorPallete == null) {
                    UnityEngine.Debug.LogError$2("ColorPalette is not assigned!");
                    return;
                }

                // Get grid size from target grid
                var gridSize = this.CurrentGridObject.gridSize.$clone();
                var gridWidth = Bridge.Int.clip32(gridSize.x);
                var gridHeight = Bridge.Int.clip32(gridSize.y);

                if (gridWidth <= 0 || gridHeight <= 0) {
                    UnityEngine.Debug.LogError$2("Invalid grid size!");
                    return;
                }

                // Get the texture from the sprite
                var paintingTexture = this.GetTextureFromSprite(_sprite);
                if (paintingTexture == null) {
                    UnityEngine.Debug.LogError$2("Could not get texture from sprite!");
                    return;
                }

                // Sample colors from painting based on grid dimensions
                var pixels = new (System.Collections.Generic.List$1(PaintingPixelConfig)).ctor();

                // Calculate half dimensions for coordinate transformation
                var halfWidth = ((Bridge.Int.div(gridWidth, 2)) | 0);
                var halfHeight = ((Bridge.Int.div(gridHeight, 2)) | 0);

                this.ColorCodeInUse.clear();

                for (var row = 0; row < gridHeight; row = (row + 1) | 0) {
                    for (var col = 0; col < gridWidth; col = (col + 1) | 0) {
                        // Calculate the center position of the grid cell in the painting texture
                        var texX = (col + 0.5) * paintingTexture.width / gridWidth;
                        var texY = (row + 0.5) * paintingTexture.height / gridHeight;

                        // Get the color at the center of the grid cell
                        var sampledColor = paintingTexture.GetPixel(Bridge.Int.clip32(texX), Bridge.Int.clip32(texY));
                        var closestColor = { v : new UnityEngine.Color() };
                        var colorCode = { };
                        Bridge.Deconstruct(this.FindClosestColorInPaletteIgnoreRules(sampledColor, this.PrefabSource.ColorPallete).$clone(), closestColor, colorCode);

                        if (!this.ColorCodeInUse.contains(colorCode.v)) {
                            this.ColorCodeInUse.add(colorCode.v);
                        }

                        // Transform coordinates to match GridGenerator system (center at 0,0 with negative indices)
                        // For columns: from right (positive) to left (negative)
                        var gridCol = (halfWidth - col) | 0;
                        if (gridWidth % 2 === 0) {
                            gridCol = (gridCol - 1) | 0; // Adjust for even number of columns
                        }

                        // For rows: from bottom (negative) to top (positive) 
                        var gridRow = (row - halfHeight) | 0;
                        if (gridHeight % 2 === 0) {
                            // No adjustment needed for even number of rows in this implementation
                        }

                        // Create a new pixel config
                        var pixelConfig = new PaintingPixelConfig.ctor();
                        pixelConfig.row = gridRow;
                        pixelConfig.column = gridCol;
                        pixelConfig.color = closestColor.v.$clone();
                        pixelConfig.colorCode = colorCode.v;
                        pixelConfig.Hidden = System.String.equals(colorCode.v, PaintingSharedAttributes.TransparentColorKey);

                        pixels.add(pixelConfig);
                    }
                }
            },
            /*PaintingConfigSetup.ExtractColorCodesFromPainting end.*/

            /*PaintingConfigSetup.FindClosestColorInPaletteIgnoreRules start.*/
            FindClosestColorInPaletteIgnoreRules: function (targetColor, palette) {
if ( TRACE ) { TRACE( "PaintingConfigSetup#FindClosestColorInPaletteIgnoreRules", this ); }

                var $t;
                if (targetColor.a < 1.0) {
                    return new (System.ValueTuple$2(UnityEngine.Color,System.String)).$ctor1(targetColor.$clone(), PaintingSharedAttributes.TransparentColorKey);
                }
                if (palette.colorPallete.Count === 0) {
                    UnityEngine.Debug.LogWarning$1("Color palette is empty!");
                    return new (System.ValueTuple$2(UnityEngine.Color,System.String)).$ctor1(targetColor.$clone(), "");
                }

                var closestColor = new pc.Color( 1, 1, 1, 1 );
                var closestColorCode = "";
                var minDistance = 3.40282347E+38;

                $t = Bridge.getEnumerator(palette.colorPallete);
                try {
                    while ($t.moveNext()) {
                        var kvp = $t.Current;
                        var distance = this.ColorDistanceLAB(targetColor, kvp.value);

                        if (distance < minDistance) {
                            minDistance = distance;
                            closestColor = kvp.value.$clone();
                            closestColorCode = kvp.key; // Store the key (color code)
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                // If no matching color was found in the filtered list, return the original color or a warning
                if (minDistance === 3.40282347E+38) {
                    UnityEngine.Debug.LogWarning$1(System.String.format("No matching color found in the specified color codes for target color {0}. Returning original color.", [targetColor.$clone()]));
                    return new (System.ValueTuple$2(UnityEngine.Color,System.String)).$ctor1(targetColor.$clone(), "");
                } else {
                    return new (System.ValueTuple$2(UnityEngine.Color,System.String)).$ctor1(targetColor.$clone(), closestColorCode);
                }
            },
            /*PaintingConfigSetup.FindClosestColorInPaletteIgnoreRules end.*/

            /*PaintingConfigSetup.FindClosestColorInPalette start.*/
            FindClosestColorInPalette: function (targetColor, palette) {
if ( TRACE ) { TRACE( "PaintingConfigSetup#FindClosestColorInPalette", this ); }

                var $t;
                if (!this.useColorFilter) {
                    return new (System.ValueTuple$2(UnityEngine.Color,System.String)).$ctor1(targetColor.$clone(), PaintingSharedAttributes.DefaultColorKey);
                }
                if (targetColor.a < 1.0) {
                    return new (System.ValueTuple$2(UnityEngine.Color,System.String)).$ctor1(targetColor.$clone(), PaintingSharedAttributes.TransparentColorKey);
                }
                if (palette.colorPallete.Count === 0) {
                    UnityEngine.Debug.LogWarning$1("Color palette is empty!");
                    return new (System.ValueTuple$2(UnityEngine.Color,System.String)).$ctor1(targetColor.$clone(), "");
                }

                var closestColor = new pc.Color( 1, 1, 1, 1 );
                var closestColorCode = "";
                var minDistance = 3.40282347E+38;

                $t = Bridge.getEnumerator(palette.colorPallete);
                try {
                    while ($t.moveNext()) {
                        var kvp = $t.Current;
                        // Only consider colors that are in the colorCodeInUse list if useColorFilter is enabled and the list is not empty
                        if (this.useColorFilter && this.ColorCodeInUse.Count > 0 && !this.ColorCodeInUse.contains(kvp.key)) {
                            continue;
                        }

                        var distance = this.ColorDistanceLAB(targetColor, kvp.value);

                        if (distance < minDistance) {
                            minDistance = distance;
                            closestColor = kvp.value.$clone();
                            closestColorCode = kvp.key; // Store the key (color code)
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                // If no matching color was found in the filtered list, return the original color or a warning
                if (minDistance === 3.40282347E+38) {
                    UnityEngine.Debug.LogWarning$1(System.String.format("No matching color found in the specified color codes for target color {0}. Returning original color.", [targetColor.$clone()]));
                    return new (System.ValueTuple$2(UnityEngine.Color,System.String)).$ctor1(targetColor.$clone(), "");
                }

                if (this.useColorFilter) {
                    return new (System.ValueTuple$2(UnityEngine.Color,System.String)).$ctor1(closestColor.$clone(), closestColorCode);
                } else {
                    return new (System.ValueTuple$2(UnityEngine.Color,System.String)).$ctor1(targetColor.$clone(), closestColorCode);
                }
            },
            /*PaintingConfigSetup.FindClosestColorInPalette end.*/

            /*PaintingConfigSetup.ColorDistanceLAB start.*/
            ColorDistanceLAB: function (color1, color2) {
if ( TRACE ) { TRACE( "PaintingConfigSetup#ColorDistanceLAB", this ); }

                // Convert RGB to LAB for perceptually uniform color space
                var lab1 = this.RGBToLAB(color1);
                var lab2 = this.RGBToLAB(color2);

                var deltaL = lab1.x - lab2.x;
                var deltaA = lab1.y - lab2.y;
                var deltaB = lab1.z - lab2.z;

                return Math.sqrt(deltaL * deltaL + deltaA * deltaA + deltaB * deltaB);
            },
            /*PaintingConfigSetup.ColorDistanceLAB end.*/

            /*PaintingConfigSetup.RGBToLAB start.*/
            RGBToLAB: function (color) {
if ( TRACE ) { TRACE( "PaintingConfigSetup#RGBToLAB", this ); }

                // Convert RGB (0-1) to XYZ
                var r = color.r <= 0.04045 ? color.r / 12.92 : Math.pow((color.r + 0.055) / 1.055, 2.4);
                var g = color.g <= 0.04045 ? color.g / 12.92 : Math.pow((color.g + 0.055) / 1.055, 2.4);
                var b = color.b <= 0.04045 ? color.b / 12.92 : Math.pow((color.b + 0.055) / 1.055, 2.4);

                var x = (r * 0.4124 + g * 0.3576 + b * 0.1805) / 0.95047;
                var y = (r * 0.2126 + g * 0.7152 + b * 0.0722) / 1.0;
                var z = (r * 0.0193 + g * 0.1192 + b * 0.9505) / 1.08883;

                x = x > 0.008856 ? Math.pow(x, 0.333333343) : (7.787 * x) + (0.137931034);
                y = y > 0.008856 ? Math.pow(y, 0.333333343) : (7.787 * y) + (0.137931034);
                z = z > 0.008856 ? Math.pow(z, 0.333333343) : (7.787 * z) + (0.137931034);

                var L = (116.0 * y) - 16.0;
                var A = 500.0 * (x - y);
                var B = 200.0 * (y - z);

                return new pc.Vec3( L, A, B );
            },
            /*PaintingConfigSetup.RGBToLAB end.*/

            /*PaintingConfigSetup.CreatePaintingConfigAsset start.*/
            CreatePaintingConfigAsset: function (pixels, gridSize, originalSprite) {
if ( TRACE ) { TRACE( "PaintingConfigSetup#CreatePaintingConfigAsset", this ); }

                UnityEngine.Debug.LogWarning$1("PaintingConfig asset creation is only supported in the Unity Editor.");
                return null;
            },
            /*PaintingConfigSetup.CreatePaintingConfigAsset end.*/

            /*PaintingConfigSetup.CanSample start.*/
            CanSample: function () {
if ( TRACE ) { TRACE( "PaintingConfigSetup#CanSample", this ); }

                var $t;
                // If color filtering is not enabled, we can use any color from the palette
                if (!this.useColorFilter) {
                    return this.TargetPainting != null && UnityEngine.MonoBehaviour.op_Inequality(this.CurrentGridObject, null) && this.PrefabSource.ColorPallete != null;
                }

                // If color filtering is enabled but colorCodeInUse is empty, we can't filter
                if (this.ColorCodeInUse.Count === 0) {
                    return false;
                }

                // If color filtering is enabled and colorCodeInUse has values, check if they exist in the palette
                $t = Bridge.getEnumerator(this.ColorCodeInUse);
                try {
                    while ($t.moveNext()) {
                        var colorCode = $t.Current;
                        if (System.String.equals(colorCode, PaintingSharedAttributes.TransparentColorKey)) {
                            continue;
                        }
                        if (!this.PrefabSource.ColorPallete.colorPallete.containsKey(colorCode)) {
                            return false; // Invalid color code in the list
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                return this.TargetPainting != null && UnityEngine.MonoBehaviour.op_Inequality(this.CurrentGridObject, null) && this.PrefabSource.ColorPallete != null;
            },
            /*PaintingConfigSetup.CanSample end.*/

            /*PaintingConfigSetup.Save start.*/
            Save: function () {
if ( TRACE ) { TRACE( "PaintingConfigSetup#Save", this ); }
 },
            /*PaintingConfigSetup.Save end.*/


        }
    });
    /*PaintingConfigSetup end.*/

    /*PaintingGridEffects start.*/
    Bridge.define("PaintingGridEffects", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            GridAudioSource: null,
            BlockDestroyedClip: null
        },
        methods: {
            /*PaintingGridEffects.PlayBlockDestroyedAudio start.*/
            PlayBlockDestroyedAudio: function () {
if ( TRACE ) { TRACE( "PaintingGridEffects#PlayBlockDestroyedAudio", this ); }

                this.GridAudioSource.PlayOneShot(this.BlockDestroyedClip);
            },
            /*PaintingGridEffects.PlayBlockDestroyedAudio end.*/


        }
    });
    /*PaintingGridEffects end.*/

    /*PaintingGridObject start.*/
    Bridge.define("PaintingGridObject", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            methods: {
                /*PaintingGridObject.ApproximatelyEqual:static start.*/
                ApproximatelyEqual: function (a, b, eps) {
if ( TRACE ) { TRACE( "PaintingGridObject#ApproximatelyEqual", this ); }

                    if (eps === void 0) { eps = 0.001; }
                    return Math.abs(a.r - b.r) <= eps && Math.abs(a.g - b.g) <= eps && Math.abs(a.b - b.b) <= eps && Math.abs(a.a - b.a) <= eps;
                },
                /*PaintingGridObject.ApproximatelyEqual:static end.*/


            }
        },
        fields: {
            EffectHandler: null,
            EffectOptions: null,
            ColorPalette: null,
            gridSize: null,
            paintingPixels: null,
            GridTransform: null,
            CurrentLevelColor: null,
            colorCodeMaterials: null,
            PipeObjects: null,
            pipeObjectsPixels: null,
            WallObjects: null,
            wallObjectsPixels: null,
            KeyObjects: null,
            keyObjectsPixels: null,
            AdditionPaintingPixels: null,
            pixelArrangeSpace: 0,
            blockScale: null,
            pixelPrefab: null,
            YOffset: 0,
            colorVariationAmount: 0,
            PrefabSource: null,
            basePixelSharedMaterial: null,
            currentOutlinePixels: null,
            PixelCount: 0,
            PixelDestroyed: 0,
            MinRow: 0,
            MaxRow: 0,
            MinColumn: 0,
            MaxColumn: 0,
            pixelsByRow: null,
            pixelsByColumn: null,
            pixelByColors: null
        },
        props: {
            PixelsByRow: {
                get: function () {
if ( TRACE ) { TRACE( "PaintingGridObject#PixelsByRow#get", this ); }

                    return this.pixelsByRow;
                }
            },
            PixelsByColumn: {
                get: function () {
if ( TRACE ) { TRACE( "PaintingGridObject#PixelsByColumn#get", this ); }

                    return this.pixelsByColumn;
                }
            },
            PixelByColor: {
                get: function () {
if ( TRACE ) { TRACE( "PaintingGridObject#PixelByColor#get", this ); }

                    return this.pixelByColors;
                }
            },
            ActivePalette: {
                get: function () {
if ( TRACE ) { TRACE( "PaintingGridObject#ActivePalette#get", this ); }

                    return this.ColorPalette != null ? this.ColorPalette : this.PrefabSource != null ? this.PrefabSource.ColorPallete : null;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "PaintingGridObject#init", this ); }

                this.gridSize = new UnityEngine.Vector2();
                this.blockScale = new UnityEngine.Vector3();
                this.CurrentLevelColor = new (System.Collections.Generic.List$1(System.String)).ctor();
                this.colorCodeMaterials = new (System.Collections.Generic.Dictionary$2(System.String,UnityEngine.Material)).ctor();
                this.PipeObjects = new (System.Collections.Generic.List$1(PipeObject)).ctor();
                this.pipeObjectsPixels = new (System.Collections.Generic.List$1(PaintingPixel)).ctor();
                this.WallObjects = new (System.Collections.Generic.List$1(WallObject)).ctor();
                this.wallObjectsPixels = new (System.Collections.Generic.List$1(PaintingPixel)).ctor();
                this.KeyObjects = new (System.Collections.Generic.List$1(KeyObject)).ctor();
                this.keyObjectsPixels = new (System.Collections.Generic.List$1(PaintingPixel)).ctor();
                this.AdditionPaintingPixels = new (System.Collections.Generic.List$1(PaintingPixel)).ctor();
                this.pixelArrangeSpace = 1.0;
                this.blockScale = new pc.Vec3( 1, 1, 1 );
                this.YOffset = 0;
                this.colorVariationAmount = 0.0;
                this.currentOutlinePixels = new (System.Collections.Generic.List$1(PaintingPixel)).ctor();
                this.PixelCount = 0;
                this.PixelDestroyed = 0;
                this.MinRow = 0;
                this.MaxRow = 0;
                this.MinColumn = 0;
                this.MaxColumn = 0;
                this.pixelsByRow = new (System.Collections.Generic.Dictionary$2(System.Int32,System.Collections.Generic.List$1(PaintingPixel))).ctor();
                this.pixelsByColumn = new (System.Collections.Generic.Dictionary$2(System.Int32,System.Collections.Generic.List$1(PaintingPixel))).ctor();
                this.pixelByColors = new (System.Collections.Generic.Dictionary$2(System.String,System.Collections.Generic.List$1(PaintingPixel))).ctor();
            }
        },
        methods: {
            /*PaintingGridObject.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "PaintingGridObject#Awake", this ); }

                this.ColorPalette.SetupMaterials();
                this.GridTransform = this.transform;
                this.RegisterEvent();
            },
            /*PaintingGridObject.Awake end.*/

            /*PaintingGridObject.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "PaintingGridObject#OnDestroy", this ); }

                this.UnregisterEvent();
                this.ClearColorCodeMaterials(); // Gii phng cc material  to
            },
            /*PaintingGridObject.OnDestroy end.*/

            /*PaintingGridObject.InitializeLevel start.*/
            InitializeLevel: function (paintingConfig) {
if ( TRACE ) { TRACE( "PaintingGridObject#InitializeLevel", this ); }

                this.ApplyPaintingConfig(paintingConfig);

                // Initialize mappings from existing pixels if they exist
                this.InitializePixelMappings();

                // Setup mechanic dependencies
                this.SetUpMechanicDependencies();

                this.PixelCount = paintingConfig.GetAllWorkingPixels().Count;
                this.PixelDestroyed = 0;

                this.currentOutlinePixels = this.SelectOutlinePixels();

                !Bridge.staticEquals(GameplayEventsManager.OnPaintingInitializeDone, null) ? GameplayEventsManager.OnPaintingInitializeDone(this) : null;
            },
            /*PaintingGridObject.InitializeLevel end.*/

            /*PaintingGridObject.ApplyPaintingConfig start.*/
            ApplyPaintingConfig: function (paintingConfig) {
if ( TRACE ) { TRACE( "PaintingGridObject#ApplyPaintingConfig", this ); }

                var $t, $t1;
                this.ClearAllAdditionPixels();

                this.ClearAllKeys();
                this.ClearAllPipes();
                this.ClearAllWalls();
                this.ClearColorCodeMaterials(); // Clear materials for new level

                if (paintingConfig == null) {
                    UnityEngine.Debug.LogWarning$1("No PaintingConfig assigned to apply.");
                    return;
                }

                // Iterate through all pixel configs in the painting config
                $t = Bridge.getEnumerator(paintingConfig.Pixels);
                try {
                    while ($t.moveNext()) {
                        var pixelConfig = $t.Current;
                        //  FIX: Lun lookup mu t ColorPalette bng colorCode
                        var pixelColor = new pc.Color( 1, 1, 1, 1 );

                        if (!System.String.isNullOrEmpty(pixelConfig.colorCode) && System.String.equals(pixelConfig.colorCode, PaintingSharedAttributes.TransparentColorKey)) {
                            pixelColor = new pc.Color( 0, 0, 0, 0 );
                        } else if (this.ActivePalette != null && !System.String.isNullOrEmpty(pixelConfig.colorCode)) {
                            pixelColor = this.ActivePalette.GetColorByCode(pixelConfig.colorCode);
                        } else if (!pc.Color.equals( pixelConfig.color, new pc.Color( 0, 0, 0, 1 ) ) && pixelConfig.color.a > 0) {
                            // Fallback: dng color t config nu c v khng phi black
                            pixelColor = pixelConfig.color.$clone();
                        }

                        var variedColor = this.ApplyColorVariation(pixelColor, this.colorVariationAmount);
                        this.SetupPixelObject(pixelConfig.column, pixelConfig.row, variedColor, pixelConfig.colorCode, pixelConfig.Hidden);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                $t1 = Bridge.getEnumerator(paintingConfig.AdditionPixels);
                try {
                    while ($t1.moveNext()) {
                        var additionPixelConfig = $t1.Current;
                        var additionPixel = this.CreateNewPaintingPixelReal(additionPixelConfig, false);
                        if (additionPixel != null) {
                            this.AdditionPaintingPixels.add(additionPixel);
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                // Apply wall configurations as well
                this.ApplyWallConfigurations(paintingConfig);

                // Apply pipe configurations as well
                this.ApplyPipeConfigurations(paintingConfig);

                // Apply key configurations as well
                this.ApplyKeyConfigurations(paintingConfig);

            },
            /*PaintingGridObject.ApplyPaintingConfig end.*/

            /*PaintingGridObject.SetUpMechanicDependencies start.*/
            SetUpMechanicDependencies: function () {
if ( TRACE ) { TRACE( "PaintingGridObject#SetUpMechanicDependencies", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.KeyObjects);
                try {
                    while ($t.moveNext()) {
                        var key = $t.Current;
                        key.BorderPixels = new (System.Collections.Generic.List$1(UnityEngine.Vector2)).ctor();
                        key.BorderPixels = this.GetLocalBorderPositions(key.PaintingPixelsCovered);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*PaintingGridObject.SetUpMechanicDependencies end.*/

            /*PaintingGridObject.RegisterEvent start.*/
            RegisterEvent: function () {
if ( TRACE ) { TRACE( "PaintingGridObject#RegisterEvent", this ); }

                GameplayEventsManager.OnBlockDissapear = Bridge.fn.combine(GameplayEventsManager.OnBlockDissapear, Bridge.fn.cacheBind(this, this.OnBlockDissapear));
                GameplayEventsManager.OnAPixelDestroyed = Bridge.fn.combine(GameplayEventsManager.OnAPixelDestroyed, Bridge.fn.cacheBind(this, this.OnAPixelDestroyed));
                GameplayEventsManager.OnAPipePixelDestroyed = Bridge.fn.combine(GameplayEventsManager.OnAPipePixelDestroyed, Bridge.fn.cacheBind(this, this.OnAPipePixelDestroyed));
                GameplayEventsManager.OnCollectorsSquadChanged = Bridge.fn.combine(GameplayEventsManager.OnCollectorsSquadChanged, Bridge.fn.cacheBind(this, this.OnCollectorsFormationChanged));
            },
            /*PaintingGridObject.RegisterEvent end.*/

            /*PaintingGridObject.UnregisterEvent start.*/
            UnregisterEvent: function () {
if ( TRACE ) { TRACE( "PaintingGridObject#UnregisterEvent", this ); }

                GameplayEventsManager.OnBlockDissapear = Bridge.fn.remove(GameplayEventsManager.OnBlockDissapear, Bridge.fn.cacheBind(this, this.OnBlockDissapear));
                GameplayEventsManager.OnAPixelDestroyed = Bridge.fn.remove(GameplayEventsManager.OnAPixelDestroyed, Bridge.fn.cacheBind(this, this.OnAPixelDestroyed));
                GameplayEventsManager.OnAPipePixelDestroyed = Bridge.fn.remove(GameplayEventsManager.OnAPipePixelDestroyed, Bridge.fn.cacheBind(this, this.OnAPipePixelDestroyed));
                GameplayEventsManager.OnCollectorsSquadChanged = Bridge.fn.remove(GameplayEventsManager.OnCollectorsSquadChanged, Bridge.fn.cacheBind(this, this.OnCollectorsFormationChanged));
            },
            /*PaintingGridObject.UnregisterEvent end.*/

            /*PaintingGridObject.UpdateOutlinePixels start.*/
            UpdateOutlinePixels: function () {
if ( TRACE ) { TRACE( "PaintingGridObject#UpdateOutlinePixels", this ); }

                this.currentOutlinePixels = this.SelectOutlinePixels();
            },
            /*PaintingGridObject.UpdateOutlinePixels end.*/

            /*PaintingGridObject.OnAPixelDestroyed start.*/
            OnAPixelDestroyed: function (_pixel) {
if ( TRACE ) { TRACE( "PaintingGridObject#OnAPixelDestroyed", this ); }

                var $t, $t1, $t2;
                if (_pixel == null) {
                    return;
                }

                var destroyed = false;
                var isPipePixel = false;
                if (!destroyed) {
                    $t = Bridge.getEnumerator(this.PipeObjects);
                    try {
                        while ($t.moveNext()) {
                            var pipe = $t.Current;
                            if (pipe.Destroyed$1 || !Bridge.referenceEquals(_pixel.colorCode, pipe.ColorCode)) {
                                continue;
                            }
                            if (pipe.PaintingPixelsCovered.contains(_pixel)) {
                                destroyed = true;
                                isPipePixel = true;
                                _pixel.destroyed = false;
                                pipe.OnAPixelDestroyed();
                                break;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                if (!destroyed) {
                    $t1 = Bridge.getEnumerator(this.WallObjects);
                    try {
                        while ($t1.moveNext()) {
                            var wall = $t1.Current;
                            if (wall.Destroyed$1 || !Bridge.referenceEquals(_pixel.colorCode, wall.ColorCode)) {
                                continue;
                            }
                            if (wall.PaintingPixelsCovered.contains(_pixel)) {
                                destroyed = true;
                                _pixel.destroyed = false;
                                wall.OnAPixelDestroyed();
                                break;
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                }

                $t2 = Bridge.getEnumerator(this.KeyObjects);
                try {
                    while ($t2.moveNext()) {
                        var key = $t2.Current;
                        if (key.Collected || key.ReadyToCollected) {
                            continue;
                        }
                        if (key.BorderContains(_pixel)) {
                            destroyed = true;
                            key.OnAPixelBorderDestroyed();
                            break;
                        }
                    }
                } finally {
                    if (Bridge.is($t2, System.IDisposable)) {
                        $t2.System$IDisposable$Dispose();
                    }
                }

                if (!isPipePixel) {
                    this.UpdatePixelDestroyedCount(1);
                }

                this.UpdateOutlinePixels();

                // Trigger event to notify that grid pixels have changed
                !Bridge.staticEquals(GameplayEventsManager.OnGridObjectChanged, null) ? GameplayEventsManager.OnGridObjectChanged(this) : null;
                this.ShakeNeighborPixelsOnDestroyed(_pixel);
            },
            /*PaintingGridObject.OnAPixelDestroyed end.*/

            /*PaintingGridObject.ShakeNeighborPixelsOnDestroyed start.*/
            ShakeNeighborPixelsOnDestroyed: function (_pixel) {
if ( TRACE ) { TRACE( "PaintingGridObject#ShakeNeighborPixelsOnDestroyed", this ); }

                var $t;
                var neighbors = this.GetPixelComponentNeighbor(_pixel);
                if (neighbors.Count <= 0) {
                    return;
                }
                $t = Bridge.getEnumerator(neighbors);
                try {
                    while ($t.moveNext()) {
                        var neighbor = $t.Current;
                        neighbor.PlayShake();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*PaintingGridObject.ShakeNeighborPixelsOnDestroyed end.*/

            /*PaintingGridObject.OnCollectorsFormationChanged start.*/
            OnCollectorsFormationChanged: function (_collectors) {
if ( TRACE ) { TRACE( "PaintingGridObject#OnCollectorsFormationChanged", this ); }

                var $t;
                if (this.KeyObjects.Count > 0) {
                    var lockAvailable = _collectors.GetLockReadyToUnlock();
                    if (UnityEngine.MonoBehaviour.op_Inequality(lockAvailable, null)) {
                        $t = Bridge.getEnumerator(this.KeyObjects);
                        try {
                            while ($t.moveNext()) {
                                var key = $t.Current;
                                if (key.Collected || key.Locked) {
                                    continue;
                                }
                                key.OnCollectedByLock(lockAvailable);
                            }
                        } finally {
                            if (Bridge.is($t, System.IDisposable)) {
                                $t.System$IDisposable$Dispose();
                            }
                        }
                    }
                }
            },
            /*PaintingGridObject.OnCollectorsFormationChanged end.*/

            /*PaintingGridObject.OnAPipePixelDestroyed start.*/
            OnAPipePixelDestroyed: function () {
if ( TRACE ) { TRACE( "PaintingGridObject#OnAPipePixelDestroyed", this ); }

                this.UpdatePixelDestroyedCount(1);
            },
            /*PaintingGridObject.OnAPipePixelDestroyed end.*/

            /*PaintingGridObject.OnBlockDissapear start.*/
            OnBlockDissapear: function () {
if ( TRACE ) { TRACE( "PaintingGridObject#OnBlockDissapear", this ); }

                UnityEngine.MonoBehaviour.op_Inequality(this.EffectHandler, null) ? this.EffectHandler.PlayBlockDestroyedAudio() : null;
            },
            /*PaintingGridObject.OnBlockDissapear end.*/

            /*PaintingGridObject.UpdatePixelDestroyedCount start.*/
            UpdatePixelDestroyedCount: function (_amount) {
if ( TRACE ) { TRACE( "PaintingGridObject#UpdatePixelDestroyedCount", this ); }

                this.PixelDestroyed = (this.PixelDestroyed + _amount) | 0;

                if (this.PixelDestroyed >= this.PixelCount) {
                    // schedule endgame after 0.5s without coroutine GC
                    HelperCoroutine.DelaySeconds(this, 0.5, function () {
                        !Bridge.staticEquals(GameplayEventsManager.OnEndGame, null) ? GameplayEventsManager.OnEndGame(true) : null;
                    });
                }

            },
            /*PaintingGridObject.UpdatePixelDestroyedCount end.*/

            /*PaintingGridObject.ShootPixel start.*/
            ShootPixel: function (pixel) {
if ( TRACE ) { TRACE( "PaintingGridObject#ShootPixel", this ); }

                pixel.DestroyPixel();
            },
            /*PaintingGridObject.ShootPixel end.*/

            /*PaintingGridObject.BatchSetColorByCode start.*/
            BatchSetColorByCode: function (colorCode, newColor, includeHidden) {
if ( TRACE ) { TRACE( "PaintingGridObject#BatchSetColorByCode", this ); }

                var $t;
                if (includeHidden === void 0) { includeHidden = false; }
                if (System.String.isNullOrEmpty(colorCode) || this.pixelByColors == null) {
                    return 0;
                }
                var colorPixels = { };
                if (!this.pixelByColors.tryGetValue(colorCode, colorPixels)) {
                    return 0;
                }
                // Use colorPixels directly since it's already the list we need
                if (colorPixels.v == null || colorPixels.v.Count === 0) {
                    return 0;
                }

                var changed = 0;
                $t = Bridge.getEnumerator(colorPixels.v);
                try {
                    while ($t.moveNext()) {
                        var px = $t.Current;
                        if (px == null || px.destroyed) {
                            continue;
                        }
                        if (!includeHidden && px.Hidden) {
                            continue;
                        }
                        if (PaintingGridObject.ApproximatelyEqual(px.color, newColor)) {
                            continue;
                        }

                        px.color = newColor.$clone();
                        // Apply to visual if component exists and pixel is visible
                        if (UnityEngine.MonoBehaviour.op_Inequality(px.PixelComponent, null) && (!px.Hidden)) {
                            px.PixelComponent.SetColor(newColor);
                        }
                        changed = (changed + 1) | 0;
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return changed;
            },
            /*PaintingGridObject.BatchSetColorByCode end.*/

            /*PaintingGridObject.BatchSetColorsByCodes start.*/
            BatchSetColorsByCodes: function (colorMap, includeHidden) {
if ( TRACE ) { TRACE( "PaintingGridObject#BatchSetColorsByCodes", this ); }

                var $t;
                if (includeHidden === void 0) { includeHidden = false; }
                if (colorMap == null || colorMap.Count === 0) {
                    return 0;
                }
                var totalChanged = 0;
                $t = Bridge.getEnumerator(colorMap);
                try {
                    while ($t.moveNext()) {
                        var kvp = $t.Current;
                        totalChanged = (totalChanged + (this.BatchSetColorByCode(kvp.key, kvp.value, includeHidden))) | 0;
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return totalChanged;
            },
            /*PaintingGridObject.BatchSetColorsByCodes end.*/

            /*PaintingGridObject.DestroyAllPixelsObjects start.*/
            DestroyAllPixelsObjects: function () {
if ( TRACE ) { TRACE( "PaintingGridObject#DestroyAllPixelsObjects", this ); }

                var $t;
                for (var i = 0; i < this.paintingPixels.Count; i = (i + 1) | 0) {
                    if (this.paintingPixels.getItem(i) != null) {
                        this.paintingPixels.getItem(i).DestroyObject();
                    }
                }
                this.paintingPixels.clear();

                // Destroy all pipe objects and clear the list
                for (var i1 = 0; i1 < this.PipeObjects.Count; i1 = (i1 + 1) | 0) {
                    if (UnityEngine.MonoBehaviour.op_Inequality(this.PipeObjects.getItem(i1), null)) {
                        UnityEngine.MonoBehaviour.Destroy(this.PipeObjects.getItem(i1).gameObject);

                    }
                }
                this.PipeObjects.clear();

                // Clear pipe object pixels and destroy their GameObjects as well
                for (var i2 = 0; i2 < this.pipeObjectsPixels.Count; i2 = (i2 + 1) | 0) {
                    if (this.pipeObjectsPixels.getItem(i2) != null && UnityEngine.GameObject.op_Inequality(this.pipeObjectsPixels.getItem(i2).pixelObject, null)) {
                        UnityEngine.MonoBehaviour.Destroy(this.pipeObjectsPixels.getItem(i2).pixelObject);

                    }
                }
                this.pipeObjectsPixels.clear();

                // Destroy all wall objects and clear the list
                for (var i3 = 0; i3 < this.WallObjects.Count; i3 = (i3 + 1) | 0) {
                    if (UnityEngine.MonoBehaviour.op_Inequality(this.WallObjects.getItem(i3), null)) {
                        UnityEngine.MonoBehaviour.Destroy(this.WallObjects.getItem(i3).gameObject);
                    }
                }
                this.WallObjects.clear();

                // Destroy all key objects and clear the list
                $t = Bridge.getEnumerator(this.KeyObjects);
                try {
                    while ($t.moveNext()) {
                        var keyObject = $t.Current;
                        if (UnityEngine.MonoBehaviour.op_Inequality(keyObject, null)) {
                            UnityEngine.MonoBehaviour.Destroy(keyObject.gameObject);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.KeyObjects.clear();

                for (var i4 = 0; i4 < this.AdditionPaintingPixels.Count; i4 = (i4 + 1) | 0) {
                    if (UnityEngine.MonoBehaviour.op_Equality(this.AdditionPaintingPixels.getItem(i4).PixelComponent, null)) {
                        continue;
                    }
                    UnityEngine.MonoBehaviour.Destroy(this.AdditionPaintingPixels.getItem(i4).PixelComponent.gameObject);

                }
                this.AdditionPaintingPixels.clear();

                // Clear the row and column mappings as well
                this.pixelsByRow.clear();
                this.pixelsByColumn.clear();
                this.pixelByColors.clear();

                // Release pooled materials (optional memory reclaim)
                // PaintingPixelComponent.ClearSharedPool(); // Nu bn c pool material
                this.ClearColorCodeMaterials(); // Clear materials khi hy tt c pixel
            },
            /*PaintingGridObject.DestroyAllPixelsObjects end.*/

            /*PaintingGridObject.SelectOutlinePixels start.*/
            SelectOutlinePixels: function () {
if ( TRACE ) { TRACE( "PaintingGridObject#SelectOutlinePixels", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5;
                var outlinePixels = new (System.Collections.Generic.List$1(PaintingPixel)).ctor();
                var addedPixels = new (System.Collections.Generic.HashSet$1(PaintingPixel)).ctor();

                // First, check the pixels in each row to find min/max columns
                if (this.pixelsByRow != null) {
                    $t = Bridge.getEnumerator(this.pixelsByRow);
                    try {
                        while ($t.moveNext()) {
                            var rowPair = $t.Current;
                            var rowPixels = rowPair.value;
                            if (rowPixels != null && rowPixels.Count > 0) {
                                // Find min and max column for this row among non-destroyed pixels
                                var minCol = 2147483647;
                                var maxCol = -2147483648;

                                $t1 = Bridge.getEnumerator(rowPixels);
                                try {
                                    while ($t1.moveNext()) {
                                        var pixel = $t1.Current;
                                        if (pixel != null && !pixel.destroyed && !pixel.Hidden) {
                                            minCol = UnityEngine.Mathf.Min(minCol, pixel.column);
                                            maxCol = UnityEngine.Mathf.Max(maxCol, pixel.column);
                                        }
                                    }
                                } finally {
                                    if (Bridge.is($t1, System.IDisposable)) {
                                        $t1.System$IDisposable$Dispose();
                                    }
                                }

                                // Add the leftmost and rightmost pixels of this row to outline
                                if (minCol !== 2147483647) {
                                    $t2 = Bridge.getEnumerator(rowPixels);
                                    try {
                                        while ($t2.moveNext()) {
                                            var pixel1 = $t2.Current;
                                            if (pixel1 != null && !pixel1.destroyed && !pixel1.Hidden && (pixel1.column === minCol || pixel1.column === maxCol)) {
                                                if (addedPixels.add(pixel1)) {
                                                    outlinePixels.add(pixel1);
                                                }
                                            }
                                        }
                                    } finally {
                                        if (Bridge.is($t2, System.IDisposable)) {
                                            $t2.System$IDisposable$Dispose();
                                        }
                                    }
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                // Next, check the pixels in each column to find min/max rows
                if (this.pixelsByColumn != null) {
                    $t3 = Bridge.getEnumerator(this.pixelsByColumn);
                    try {
                        while ($t3.moveNext()) {
                            var colPair = $t3.Current;
                            var colPixels = colPair.value;
                            if (colPixels != null && colPixels.Count > 0) {
                                // Find min and max row for this column among non-destroyed pixels
                                var minRow = 2147483647;
                                var maxRow = -2147483648;

                                $t4 = Bridge.getEnumerator(colPixels);
                                try {
                                    while ($t4.moveNext()) {
                                        var pixel2 = $t4.Current;
                                        if (pixel2 != null && !pixel2.destroyed && !pixel2.Hidden) {
                                            minRow = UnityEngine.Mathf.Min(minRow, pixel2.row);
                                            maxRow = UnityEngine.Mathf.Max(maxRow, pixel2.row);
                                        }
                                    }
                                } finally {
                                    if (Bridge.is($t4, System.IDisposable)) {
                                        $t4.System$IDisposable$Dispose();
                                    }
                                }

                                // Add the topmost and bottommost pixels of this column to outline
                                if (minRow !== 2147483647) {
                                    $t5 = Bridge.getEnumerator(colPixels);
                                    try {
                                        while ($t5.moveNext()) {
                                            var pixel3 = $t5.Current;
                                            if (pixel3 != null && !pixel3.destroyed && !pixel3.Hidden && (pixel3.row === minRow || pixel3.row === maxRow)) {
                                                if (addedPixels.add(pixel3)) {
                                                    outlinePixels.add(pixel3);
                                                }
                                            }
                                        }
                                    } finally {
                                        if (Bridge.is($t5, System.IDisposable)) {
                                            $t5.System$IDisposable$Dispose();
                                        }
                                    }
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t3, System.IDisposable)) {
                            $t3.System$IDisposable$Dispose();
                        }
                    }
                }

                return outlinePixels;
            },
            /*PaintingGridObject.SelectOutlinePixels end.*/

            /*PaintingGridObject.SelectOutlinePixelsWithColor start.*/
            SelectOutlinePixelsWithColor: function (colorCode) {
if ( TRACE ) { TRACE( "PaintingGridObject#SelectOutlinePixelsWithColor", this ); }

                var $t;
                if (this.currentOutlinePixels.Count <= 0) {
                    return new (System.Collections.Generic.List$1(PaintingPixel)).ctor();
                }
                var rs = ($t = PaintingPixel, System.Linq.Enumerable.from(this.currentOutlinePixels.FindAll(function (x) {
                        return (Bridge.referenceEquals(x.colorCode, colorCode) || System.String.equals(x.colorCode, PaintingSharedAttributes.LockKeyColorDefine));
                    }), $t).toList($t));
                return rs;
            },
            /*PaintingGridObject.SelectOutlinePixelsWithColor end.*/

            /*PaintingGridObject.GenerateGrid start.*/
            GenerateGrid: function (yoffset) {
if ( TRACE ) { TRACE( "PaintingGridObject#GenerateGrid", this ); }

                if (yoffset === void 0) { yoffset = 0.0; }
                this.GridTransform = this.transform;
                var centerPos = this.GridTransform.position.$clone();
                this.YOffset = yoffset;
                this.DestroyAllPixelsObjects();
                this.ClearColorCodeMaterials(); // Clear materials trc khi generate grid mi

                // Generate pixels
                for (var col = 0; col < Bridge.Int.clip32(this.gridSize.x); col = (col + 1) | 0) {
                    for (var row = 0; row < Bridge.Int.clip32(this.gridSize.y); row = (row + 1) | 0) {
                        var halfCols = Bridge.Int.clip32(this.gridSize.x / 2);
                        var halfRows = Bridge.Int.clip32(this.gridSize.y / 2);

                        var gridCol = (halfCols - col) | 0;
                        if (Bridge.Int.clip32(this.gridSize.x) % 2 === 0) {
                            gridCol = (gridCol - 1) | 0;
                        }

                        var gridRow = (row - halfRows) | 0;
                        if (Bridge.Int.clip32(this.gridSize.y) % 2 === 0) {
                            // No adjustment needed for even number of rows in this implementation
                        }

                        var worldPos = this.CalculatePixelPosition(gridCol, gridRow, yoffset);

                        var pixelGO = null;
                        if (UnityEngine.GameObject.op_Inequality(this.pixelPrefab, null)) {
                            pixelGO = UnityEngine.Object.Instantiate$3(UnityEngine.GameObject, this.pixelPrefab, worldPos, pc.Quat.IDENTITY.clone(), this.GridTransform);
                            pixelGO.transform.localScale = this.blockScale.$clone();
                            pixelGO.name = System.String.format("Pixel ({0}, {1})", Bridge.box(gridCol, System.Int32), Bridge.box(gridRow, System.Int32));
                        }

                        // Create PaintingPixel with reference to its GameObject
                        // TRUYN basePixelSharedMaterial VO Y KHI TO PAINTINGPIXEL
                        var pixel = new PaintingPixel.$ctor2(gridCol, gridRow, new pc.Color( 1, 1, 1, 1 ), worldPos.$clone(), 1, false, pixelGO, this.basePixelSharedMaterial);

                        // Add to grid
                        this.paintingPixels.add(pixel);
                        this.AddPixelToMappings(pixel);

                        // Store reference to the pixel in the pixel gameobject if needed
                        if (UnityEngine.GameObject.op_Inequality(pixelGO, null)) {
                            var pixelComponent = pixelGO.GetComponent(PaintingPixelComponent);
                            if (UnityEngine.MonoBehaviour.op_Inequality(pixelComponent, null)) {
                                pixelComponent.SetUp(pixel); // pixelComponent s nhn sharedMaterial t pixel
                            }
                        }
                    }
                }
            },
            /*PaintingGridObject.GenerateGrid end.*/

            /*PaintingGridObject.InitializeGrid start.*/
            InitializeGrid: function (size, arrangeSpace, prefab, blockScale, prefabSrc, pixelSharedMaterial) {
if ( TRACE ) { TRACE( "PaintingGridObject#InitializeGrid", this ); }

                this.gridSize = size.$clone();
                this.pixelPrefab = prefab;
                this.blockScale = blockScale.$clone();
                this.PrefabSource = prefabSrc;
                this.GridTransform = this.transform;
                this.pixelArrangeSpace = arrangeSpace;
                this.basePixelSharedMaterial = pixelSharedMaterial; // Gn shared material gc

                this.KeyObjects = new (System.Collections.Generic.List$1(KeyObject)).ctor();
                this.WallObjects = new (System.Collections.Generic.List$1(WallObject)).ctor();
                this.PipeObjects = new (System.Collections.Generic.List$1(PipeObject)).ctor();
                this.paintingPixels = new (System.Collections.Generic.List$1(PaintingPixel)).ctor();
                this.AdditionPaintingPixels = new (System.Collections.Generic.List$1(PaintingPixel)).ctor();
                if (this.paintingPixels == null) {
                    this.paintingPixels = new (System.Collections.Generic.List$1(PaintingPixel)).ctor();
                } else {
                    this.paintingPixels.clear();
                }

                if (this.PipeObjects == null) {
                    this.PipeObjects = new (System.Collections.Generic.List$1(PipeObject)).ctor();
                } else {
                    this.PipeObjects.clear();
                }

                this.ClearColorCodeMaterials(); // Clear materials khi khi to grid
            },
            /*PaintingGridObject.InitializeGrid end.*/

            /*PaintingGridObject.InitializePixelMappings start.*/
            InitializePixelMappings: function () {
if ( TRACE ) { TRACE( "PaintingGridObject#InitializePixelMappings", this ); }

                var $t, $t1, $t2, $t3;
                this.pixelsByRow.clear();
                this.pixelsByColumn.clear();
                this.pixelByColors.clear();

                // Populate the mappings with current painting pixels
                if (this.paintingPixels != null) {
                    $t = Bridge.getEnumerator(this.paintingPixels);
                    try {
                        while ($t.moveNext()) {
                            var pixel = $t.Current;
                            if (pixel != null) {
                                this.AddPixelToMappings(pixel);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                // Populate the mappings with pipe object pixels
                if (this.pipeObjectsPixels != null) {
                    $t1 = Bridge.getEnumerator(this.pipeObjectsPixels);
                    try {
                        while ($t1.moveNext()) {
                            var pixel1 = $t1.Current;
                            if (pixel1 != null) {
                                this.AddPixelToMappings(pixel1);
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                }

                if (this.wallObjectsPixels != null) {
                    $t2 = Bridge.getEnumerator(this.wallObjectsPixels);
                    try {
                        while ($t2.moveNext()) {
                            var pixel2 = $t2.Current;
                            if (pixel2 != null) {
                                this.AddPixelToMappings(pixel2);
                            }
                        }
                    } finally {
                        if (Bridge.is($t2, System.IDisposable)) {
                            $t2.System$IDisposable$Dispose();
                        }
                    }
                }

                if (this.AdditionPaintingPixels != null) {
                    $t3 = Bridge.getEnumerator(this.AdditionPaintingPixels);
                    try {
                        while ($t3.moveNext()) {
                            var pixel3 = $t3.Current;
                            if (pixel3 != null) {
                                this.AddPixelToMappings(pixel3);
                            }
                        }
                    } finally {
                        if (Bridge.is($t3, System.IDisposable)) {
                            $t3.System$IDisposable$Dispose();
                        }
                    }
                }
            },
            /*PaintingGridObject.InitializePixelMappings end.*/

            /*PaintingGridObject.SetupPixelObject start.*/
            SetupPixelObject: function (column, row, newColor, colorCode, hidden) {
if ( TRACE ) { TRACE( "PaintingGridObject#SetupPixelObject", this ); }

                var pixel = this.GetOriginalPixelAt(column, row);
                if (pixel != null) {
                    // Ly material trc tip t ColorPalette nu c, fallback sang basePixelSharedMaterial
                    var materialToAssign = this.GetMaterialByColorCode(colorCode);
                    pixel.Material = materialToAssign;
                    pixel.UsePaletteMaterialColor = true; // dng ng mu ca material palette
                    pixel.SetUp(newColor, colorCode, hidden);
                }
            },
            /*PaintingGridObject.SetupPixelObject end.*/

            /*PaintingGridObject.AddPixelToMappings start.*/
            AddPixelToMappings: function (pixel) {
if ( TRACE ) { TRACE( "PaintingGridObject#AddPixelToMappings", this ); }

                if (pixel == null) {
                    return;
                }

                // Add to row mapping
                this.AddPixelToRowMapping(pixel.row, pixel);

                // Add to column mapping
                this.AddPixelToColumnMapping(pixel.column, pixel);

                // Add to color mapping
                this.AddPixelToColorsMapping(pixel.colorCode, pixel);
            },
            /*PaintingGridObject.AddPixelToMappings end.*/

            /*PaintingGridObject.AddPixelToRowMapping start.*/
            AddPixelToRowMapping: function (row, pixel) {
if ( TRACE ) { TRACE( "PaintingGridObject#AddPixelToRowMapping", this ); }

                var rowPixels = { };
                if (!this.pixelsByRow.tryGetValue(row, rowPixels)) {
                    rowPixels.v = new (System.Collections.Generic.List$1(PaintingPixel)).ctor();
                    this.pixelsByRow.setItem(row, rowPixels.v);
                }

                if (!rowPixels.v.contains(pixel)) {
                    rowPixels.v.add(pixel);
                }

                if (row < this.MinRow) {
                    this.MinRow = row;
                }
                if (row > this.MaxRow) {
                    this.MaxRow = row;
                }
            },
            /*PaintingGridObject.AddPixelToRowMapping end.*/

            /*PaintingGridObject.AddPixelToColumnMapping start.*/
            AddPixelToColumnMapping: function (column, pixel) {
if ( TRACE ) { TRACE( "PaintingGridObject#AddPixelToColumnMapping", this ); }

                var columnPixels = { };
                if (!this.pixelsByColumn.tryGetValue(column, columnPixels)) {
                    columnPixels.v = new (System.Collections.Generic.List$1(PaintingPixel)).ctor();
                    this.pixelsByColumn.setItem(column, columnPixels.v);
                }

                if (!columnPixels.v.contains(pixel)) {
                    columnPixels.v.add(pixel);
                }

                if (column < this.MinColumn) {
                    this.MinColumn = column;
                }
                if (column > this.MaxColumn) {
                    this.MaxColumn = column;
                }
            },
            /*PaintingGridObject.AddPixelToColumnMapping end.*/

            /*PaintingGridObject.AddPixelToColorsMapping start.*/
            AddPixelToColorsMapping: function (colorCode, pixel) {
if ( TRACE ) { TRACE( "PaintingGridObject#AddPixelToColorsMapping", this ); }

                var colorPixels = { };
                if (!this.pixelByColors.tryGetValue(colorCode, colorPixels)) {
                    colorPixels.v = new (System.Collections.Generic.List$1(PaintingPixel)).ctor();
                    this.pixelByColors.setItem(colorCode, colorPixels.v);
                }

                if (!colorPixels.v.contains(pixel)) {
                    colorPixels.v.add(pixel);
                }
            },
            /*PaintingGridObject.AddPixelToColorsMapping end.*/

            /*PaintingGridObject.GetMaterialByColorCode start.*/
            GetMaterialByColorCode: function (colorCode) {
if ( TRACE ) { TRACE( "PaintingGridObject#GetMaterialByColorCode", this ); }

                if (System.String.isNullOrEmpty(colorCode)) {
                    return this.basePixelSharedMaterial;
                }

                var code = colorCode.trim();
                var cached = { };
                if (this.colorCodeMaterials.tryGetValue(code, cached)) {
                    return cached.v;
                }

                var matFromPalette = this.ActivePalette != null ? this.ActivePalette.GetMaterialByCode(code) : null;

                if (matFromPalette != null) {
                    this.colorCodeMaterials.setItem(code, matFromPalette);
                    return matFromPalette;
                }

                // Fallback
                this.colorCodeMaterials.setItem(code, this.basePixelSharedMaterial);
                return this.basePixelSharedMaterial;
            },
            /*PaintingGridObject.GetMaterialByColorCode end.*/

            /*PaintingGridObject.ClearColorCodeMaterials start.*/
            ClearColorCodeMaterials: function () {
if ( TRACE ) { TRACE( "PaintingGridObject#ClearColorCodeMaterials", this ); }

                this.colorCodeMaterials.clear();
            },
            /*PaintingGridObject.ClearColorCodeMaterials end.*/

            /*PaintingGridObject.ApplyPipeConfigurations start.*/
            ApplyPipeConfigurations: function (paintingConfig) {
if ( TRACE ) { TRACE( "PaintingGridObject#ApplyPipeConfigurations", this ); }

                var $t, $t1;
                if (paintingConfig == null || paintingConfig.PipeSetups == null || paintingConfig.PipeSetups.Count <= 0) {
                    UnityEngine.Debug.LogWarning$1("No PaintingConfig or PipeSetups assigned to apply.");
                    return;
                }

                // Clear existing pipe objects
                this.ClearAllPipes();

                // Create pipe objects based on the configurations in the painting config
                $t = Bridge.getEnumerator(paintingConfig.PipeSetups);
                try {
                    while ($t.moveNext()) {
                        var pipeSetup = $t.Current;
                        if (pipeSetup != null && pipeSetup.PixelCovered != null && pipeSetup.PixelCovered.Count > 0) {
                            // Create a new pipe object based on the setup
                            this.CreatePipeObject(pipeSetup);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                $t1 = Bridge.getEnumerator(this.PipeObjects);
                try {
                    while ($t1.moveNext()) {
                        var _pipe = $t1.Current;
                        _pipe.ApplyPosition();
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }
            },
            /*PaintingGridObject.ApplyPipeConfigurations end.*/

            /*PaintingGridObject.CreatePipeObject start.*/
            CreatePipeObject: function (pipeSetup) {
if ( TRACE ) { TRACE( "PaintingGridObject#CreatePipeObject", this ); }

                var $t;
                if (pipeSetup.PixelCovered == null || pipeSetup.PixelCovered.Count < 2) {
                    UnityEngine.Debug.LogWarning$1("Pipe setup has less than 2 pixels. Cannot create pipe.");
                    return null;
                }

                var respectedPixels = new (System.Collections.Generic.List$1(PaintingPixel)).ctor();
                var pipeColor = this.ActivePalette != null ? this.ActivePalette.GetColorByCode(pipeSetup.ColorCode) : new pc.Color( 1, 1, 1, 1 );

                // Ly shared material trc tip t ColorPalette
                var pipeSharedMaterial = this.GetMaterialByColorCode(pipeSetup.ColorCode);

                for (var i = 0; i < pipeSetup.PixelCovered.Count; i = (i + 1) | 0) {
                    var pixelConfig = pipeSetup.PixelCovered.getItem(i);
                    var respectedPixel = { v : this.GetOriginalPixelAt(pixelConfig.column, pixelConfig.row) };
                    if (respectedPixel.v == null) {
                        // Truyn pipeSharedMaterial vo khi to AdditionPixel
                        var additionPixel = this.CreateNewPaintingPixelAbstract(pixelConfig, true, pipeSharedMaterial);
                        additionPixel.color = pipeColor.$clone();
                        additionPixel.colorCode = pipeSetup.ColorCode;
                        if (additionPixel != null) {
                            respectedPixels.add(additionPixel);
                        }
                    } else {
                        respectedPixel.v.colorCode = pipeSetup.ColorCode;
                        respectedPixel.v.Material = pipeSharedMaterial;
                        UnityEngine.MonoBehaviour.op_Inequality(respectedPixel.v.PixelComponent, null) ? respectedPixel.v.PixelComponent.SetUp(respectedPixel.v) : null;
                        respectedPixels.add(respectedPixel.v);
                    }
                }

                // Determine if the pipe is horizontal or vertical based on the first and last pixels
                // Get the head and tail positions from the first and last pixels
                var headPixel = respectedPixels.getItem(0);
                var tailPixel = respectedPixels.getItem(((respectedPixels.Count - 1) | 0));
                var isHorizontal = headPixel.row === tailPixel.row;
                var worldPos = headPixel.worldPos.$clone();
                if (UnityEngine.MonoBehaviour.op_Inequality(headPixel.PixelComponent, null)) {
                    worldPos = headPixel.PixelComponent.transform.position.$clone();
                }
                var pipeGO = UnityEngine.Object.Instantiate$3(UnityEngine.GameObject, this.PrefabSource.PipeObjectPrefab, worldPos, pc.Quat.IDENTITY.clone(), this.GridTransform);

                pipeGO.name = System.String.format("PIPE_OBJECT_{0}", [pipeSetup.ColorCode]);

                // Apply direct scale to the head
                var pipeTransform = pipeGO.transform;
                pipeTransform.localScale = this.blockScale.$clone();

                // Get the PipeObject component from the head
                var pipeObject = pipeTransform.GetComponent(PipeObject);
                if (UnityEngine.MonoBehaviour.op_Equality(pipeObject, null)) {
                    pipeObject = pipeGO.AddComponent(PipeObject);
                }

                pipeObject.WorldPos = worldPos.$clone();

                // Change the color of the head part using PipePartVisualHandle
                var pipeVisual = pipeGO.GetComponent(PipePartVisualHandle);
                if (UnityEngine.MonoBehaviour.op_Equality(pipeVisual, null)) {
                    pipeVisual = pipeGO.GetComponentInChildren(PipePartVisualHandle);
                }
                if (UnityEngine.MonoBehaviour.op_Inequality(pipeVisual, null)) {
                    pipeVisual.SetColor(pipeColor);
                } // t mu cho pipe object

                // Add the pipe setup pixels to the pipeObjectsPixels list if they're not already there
                if (this.pipeObjectsPixels == null) {
                    this.pipeObjectsPixels = new (System.Collections.Generic.List$1(PaintingPixel)).ctor();
                }
                var newPipePixels = new (System.Collections.Generic.List$1(PaintingPixel)).ctor();

                $t = Bridge.getEnumerator(respectedPixels);
                try {
                    while ($t.moveNext()) {
                        var pixel = $t.Current;
                        var tmp = { v : this.CreatePipePixel(pixel, pipeSharedMaterial) }; // Truyn pipeSharedMaterial vo y
                        if (tmp.v != null) {
                            newPipePixels.add(tmp.v);
                            UnityEngine.MonoBehaviour.op_Inequality(tmp.v.PixelComponent, null) ? tmp.v.PixelComponent.ApplyPosition() : null;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                pipeObject.Initialize(newPipePixels, pipeSetup.ColorCode, pipeSetup.Hearts, isHorizontal);
                pipeObject.ApplyOrientationRotation();
                this.PipeObjects.add(pipeObject);
                return pipeObject;
            },
            /*PaintingGridObject.CreatePipeObject end.*/

            /*PaintingGridObject.CreatePipePixel start.*/
            
            CreatePipePixel: function (stock, sharedMaterial) {
if ( TRACE ) { TRACE( "PaintingGridObject#CreatePipePixel", this ); }

                var pipePixelGO = new UnityEngine.GameObject.$ctor2(System.String.format("PipePixel ({0}, {1})", Bridge.box(stock.column, System.Int32), Bridge.box(stock.row, System.Int32)));

                pipePixelGO.transform.SetParent(this.GridTransform);
                pipePixelGO.transform.position = stock.worldPos.$clone();

                // Add a PaintingPixelComponent to the GameObject
                var pipePixelComponent = pipePixelGO.AddComponent(PaintingPixelComponent);

                // Create the PaintingPixel object
                var pipePixel = new PaintingPixel.$ctor2(stock.column, stock.row, stock.color.$clone(), stock.worldPos.$clone(), 1, false, pipePixelGO, sharedMaterial); // Truyn sharedMaterial
                pipePixel.SetUp(stock.color, stock.colorCode, false); // Set both color and color code

                // Set the pixel data for the component
                pipePixelComponent.SetUp(pipePixel); // Component s nhn material t pixel

                // Add the pipe pixel to the grid object's list of pipe pixels
                if (!this.pipeObjectsPixels.contains(pipePixel)) {
                    this.pipeObjectsPixels.add(pipePixel);
                    return pipePixel;
                }
                return null;
            },
            /*PaintingGridObject.CreatePipePixel end.*/

            /*PaintingGridObject.RemovePipeObject start.*/
            RemovePipeObject: function (_pipe) {
if ( TRACE ) { TRACE( "PaintingGridObject#RemovePipeObject", this ); }

                var $t;
                if (UnityEngine.MonoBehaviour.op_Equality(_pipe, null)) {
                    return;
                }
                if (this.PipeObjects.contains(_pipe)) {
                    $t = Bridge.getEnumerator(_pipe.PaintingPixelsCovered);
                    try {
                        while ($t.moveNext()) {
                            var coverPixel = $t.Current;
                            if (this.pipeObjectsPixels.contains(coverPixel)) {
                                this.pipeObjectsPixels.remove(coverPixel);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    _pipe.SelfDestroyGameobject();
                    this.PipeObjects.remove(_pipe);
                }
            },
            /*PaintingGridObject.RemovePipeObject end.*/

            /*PaintingGridObject.ClearAllPipes start.*/
            ClearAllPipes: function () {
if ( TRACE ) { TRACE( "PaintingGridObject#ClearAllPipes", this ); }

                var $t;
                if (this.PipeObjects == null) {
                    this.PipeObjects = new (System.Collections.Generic.List$1(PipeObject)).ctor();
                } else {
                    var tmp = new (System.Collections.Generic.List$1(PipeObject)).$ctor1(this.PipeObjects);
                    $t = Bridge.getEnumerator(tmp);
                    try {
                        while ($t.moveNext()) {
                            var pipeObj = $t.Current;
                            this.RemovePipeObject(pipeObj);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
                this.PipeObjects.clear();
                this.pipeObjectsPixels.clear();
            },
            /*PaintingGridObject.ClearAllPipes end.*/

            /*PaintingGridObject.ApplyWallConfigurations start.*/
            ApplyWallConfigurations: function (paintingConfig) {
if ( TRACE ) { TRACE( "PaintingGridObject#ApplyWallConfigurations", this ); }

                var $t;
                if (paintingConfig == null || paintingConfig.WallSetups == null || paintingConfig.WallSetups.Count <= 0) {
                    UnityEngine.Debug.LogWarning$1("No PaintingConfig or WallSetups assigned to apply.", this.gameObject);
                    return;
                }

                // Clear existing wall objects
                this.ClearAllWalls();

                // Create wall objects based on the configurations in the painting config
                $t = Bridge.getEnumerator(paintingConfig.WallSetups);
                try {
                    while ($t.moveNext()) {
                        var wallSetup = $t.Current;
                        if (wallSetup != null) {
                            // Create a new wall object based on the setup
                            this.CreateWallObject(wallSetup);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*PaintingGridObject.ApplyWallConfigurations end.*/

            /*PaintingGridObject.CreateWallObject start.*/
            CreateWallObject: function (wallSetup) {
if ( TRACE ) { TRACE( "PaintingGridObject#CreateWallObject", this ); }

                var $t, $t1, $t2;
                if (wallSetup.PixelCovered == null || wallSetup.PixelCovered.Count <= 1) {
                    UnityEngine.Debug.LogWarning$1("Cannot create wall.");
                    return null;
                }

                var wallPixels = new (System.Collections.Generic.List$1(PaintingPixel)).ctor();
                var wallColor = this.ActivePalette != null ? this.ActivePalette.GetColorByCode(wallSetup.ColorCode) : new pc.Color( 1, 1, 1, 1 );
                var wallSharedMaterial = this.GetMaterialByColorCode(wallSetup.ColorCode);

                $t = Bridge.getEnumerator(wallSetup.PixelCovered);
                try {
                    while ($t.moveNext()) {
                        var pixelConfig = $t.Current;
                        var respectedPixel = { v : this.GetOriginalPixelAt(pixelConfig.column, pixelConfig.row) };
                        if (respectedPixel.v != null) {
                            respectedPixel.v.colorCode = wallSetup.ColorCode;
                            respectedPixel.v.Material = wallSharedMaterial; // Cp nht sharedMaterial cho pixel b tng cover
                            UnityEngine.MonoBehaviour.op_Inequality(respectedPixel.v.PixelComponent, null) ? respectedPixel.v.PixelComponent.SetUp(respectedPixel.v) : null;
                            wallPixels.add(respectedPixel.v);
                        } else {
                            // Truyn wallSharedMaterial khi to AdditionPixel
                            var additionPixel = this.CreateNewPaintingPixelAbstract(pixelConfig, true, wallSharedMaterial);
                            try {
                                additionPixel.color = wallColor.$clone();
                            } catch ($e1) {
                                $e1 = System.Exception.create($e1);
                                additionPixel.color = new pc.Color( 1, 1, 1, 1 );
                            }
                            additionPixel.colorCode = wallSetup.ColorCode;
                            if (additionPixel != null) {
                                wallPixels.add(additionPixel);
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                if (wallPixels.Count !== wallSetup.PixelCovered.Count) {
                    return null;
                }

                var wallPosition = pc.Vec3.ZERO.clone();
                if (System.Linq.Enumerable.from(wallPixels, PaintingPixel).any(function (p) {
                        return UnityEngine.MonoBehaviour.op_Equality(p.PixelComponent, null);
                    })) {
                    wallPosition = this.GetCenterByBoundingBox(wallPixels);
                } else {
                    wallPosition = this.GetCenterByBoundingBox$1(System.Linq.Enumerable.from(wallPixels, PaintingPixel).select(function (p) {
                            return p.PixelComponent;
                        }).toList(PaintingPixelComponent));
                }

                // Create the pipe game object with head transform as parent
                var wallGO = UnityEngine.Object.Instantiate$3(UnityEngine.GameObject, this.PrefabSource.BigBlockPrefab, wallPosition, pc.Quat.IDENTITY.clone(), this.GridTransform);

                wallGO.name = System.String.format("WALL_OBJECT_{0}", [wallSetup.ColorCode]);

                // Get the PipeObject component from the head
                var wallObject = wallGO.GetComponent(WallObject);
                if (UnityEngine.MonoBehaviour.op_Equality(wallObject, null)) {
                    wallObject = wallGO.AddComponent(WallObject);
                }
                var height = { };
                var width = { };
                Bridge.Deconstruct(this.GetShapeSize(wallPixels).$clone(), height, width);
                var defaultPixelScale = this.blockScale.$clone();
                var wallScale = new pc.Vec3( defaultPixelScale.x * width.v, defaultPixelScale.y, defaultPixelScale.z * height.v );
                wallObject.WallTransform.localScale = wallScale.$clone();
                wallObject.WorldPos = wallPosition.$clone();
                // Hide all pixel that covered by wall
                for (var i = 0; i < wallPixels.Count; i = (i + 1) | 0) {
                    UnityEngine.MonoBehaviour.op_Inequality(($t1 = wallPixels.getItem(i).PixelComponent), null) ? $t1.HideVisualOnly() : null;
                }

                // Add the pipe setup pixels to the pipeObjectsPixels list if they're not already there
                if (this.wallObjectsPixels == null) {
                    this.wallObjectsPixels = new (System.Collections.Generic.List$1(PaintingPixel)).ctor();
                }
                $t2 = Bridge.getEnumerator(wallPixels);
                try {
                    while ($t2.moveNext()) {
                        var pixel = $t2.Current;
                        if (!this.wallObjectsPixels.contains(pixel)) {
                            this.wallObjectsPixels.add(pixel);
                        }
                    }
                } finally {
                    if (Bridge.is($t2, System.IDisposable)) {
                        $t2.System$IDisposable$Dispose();
                    }
                }

                wallObject.Initialize(wallPixels, wallSetup.Hearts, wallColor, wallSetup.ColorCode);
                this.WallObjects.add(wallObject);
                return wallObject;
            },
            /*PaintingGridObject.CreateWallObject end.*/

            /*PaintingGridObject.ClearAllWalls start.*/
            ClearAllWalls: function () {
if ( TRACE ) { TRACE( "PaintingGridObject#ClearAllWalls", this ); }

                var $t;
                if (this.WallObjects == null) {
                    this.WallObjects = new (System.Collections.Generic.List$1(WallObject)).ctor();
                } else {
                    var tmp = new (System.Collections.Generic.List$1(WallObject)).$ctor1(this.WallObjects);
                    $t = Bridge.getEnumerator(tmp);
                    try {
                        while ($t.moveNext()) {
                            var wallObj = $t.Current;
                            this.RemoveWallObject(wallObj);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
                this.WallObjects.clear();
                this.wallObjectsPixels.clear();
            },
            /*PaintingGridObject.ClearAllWalls end.*/

            /*PaintingGridObject.RemoveWallObject start.*/
            RemoveWallObject: function (_wall) {
if ( TRACE ) { TRACE( "PaintingGridObject#RemoveWallObject", this ); }

                var $t;
                if (UnityEngine.MonoBehaviour.op_Equality(_wall, null)) {
                    return;
                }
                if (this.WallObjects.contains(_wall)) {
                    $t = Bridge.getEnumerator(_wall.PaintingPixelsCovered);
                    try {
                        while ($t.moveNext()) {
                            var coverPixel = { v : $t.Current };
                            if (this.wallObjectsPixels.contains(coverPixel.v)) {
                                UnityEngine.MonoBehaviour.op_Inequality(coverPixel.v.PixelComponent, null) ? coverPixel.v.PixelComponent.ShowVisualOnly() : null;
                                this.wallObjectsPixels.remove(coverPixel.v);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    _wall.SelfDestroyGameObject();
                    this.WallObjects.remove(_wall);
                }
            },
            /*PaintingGridObject.RemoveWallObject end.*/

            /*PaintingGridObject.RemoveWallObject$1 start.*/
            RemoveWallObject$1: function (_wall) {
if ( TRACE ) { TRACE( "PaintingGridObject#RemoveWallObject$1", this ); }

                var $t;
                if (_wall == null) {
                    return;
                }
                var _wallObject = this.WallObjects.Find(function (w) {
                    return (Bridge.referenceEquals(w.ColorCode, _wall.ColorCode) && w.PaintingPixelsCovered.getItem(0).column === _wall.PixelCovered.getItem(0).column) && w.PaintingPixelsCovered.getItem(0).row === _wall.PixelCovered.getItem(0).row && w.PaintingPixelsCovered.getItem(((w.PaintingPixelsCovered.Count - 1) | 0)).column === _wall.PixelCovered.getItem(((_wall.PixelCovered.Count - 1) | 0)).column && w.PaintingPixelsCovered.getItem(((w.PaintingPixelsCovered.Count - 1) | 0)).row === _wall.PixelCovered.getItem(((_wall.PixelCovered.Count - 1) | 0)).row;
                });
                if (UnityEngine.MonoBehaviour.op_Equality(_wallObject, null)) {
                    return;
                }
                if (this.WallObjects.contains(_wallObject)) {
                    $t = Bridge.getEnumerator(_wallObject.PaintingPixelsCovered);
                    try {
                        while ($t.moveNext()) {
                            var coverPixel = { v : $t.Current };
                            if (this.wallObjectsPixels.contains(coverPixel.v)) {
                                UnityEngine.MonoBehaviour.op_Inequality(coverPixel.v.PixelComponent, null) ? coverPixel.v.PixelComponent.ShowVisualOnly() : null;
                                this.wallObjectsPixels.remove(coverPixel.v);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    _wallObject.SelfDestroyGameObject();
                    this.WallObjects.remove(_wallObject);
                }
            },
            /*PaintingGridObject.RemoveWallObject$1 end.*/

            /*PaintingGridObject.ApplyKeyConfigurations start.*/
            ApplyKeyConfigurations: function (paintingConfig) {
if ( TRACE ) { TRACE( "PaintingGridObject#ApplyKeyConfigurations", this ); }

                var $t;
                if (paintingConfig == null || paintingConfig.KeySetups == null || paintingConfig.KeySetups.Count <= 0) {
                    UnityEngine.Debug.LogWarning$1("No PaintingConfig or KeySetups assigned to apply.");
                    return;
                }

                // Clear existing key objects
                this.ClearAllKeys();

                // Create key objects based on the configurations in the painting config
                $t = Bridge.getEnumerator(paintingConfig.KeySetups);
                try {
                    while ($t.moveNext()) {
                        var KeySetup = $t.Current;
                        if (KeySetup != null) {
                            // Create a new key object based on the setup
                            this.CreateKeyObject(KeySetup);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*PaintingGridObject.ApplyKeyConfigurations end.*/

            /*PaintingGridObject.CreateKeyObject start.*/
            CreateKeyObject: function (keySetup) {
if ( TRACE ) { TRACE( "PaintingGridObject#CreateKeyObject", this ); }

                var $t, $t1, $t2;
                if (keySetup.PixelCovered == null || keySetup.PixelCovered.Count <= 0) {
                    UnityEngine.Debug.LogWarning$1("Cannot create key.");
                    return null;
                }

                var keyPixels = new (System.Collections.Generic.List$1(PaintingPixel)).ctor();
                var keyColor = this.ActivePalette != null ? this.ActivePalette.GetColorByCode(keySetup.ColorCode) : new pc.Color( 1, 1, 1, 1 );
                var keySharedMaterial = this.GetMaterialByColorCode(keySetup.ColorCode);

                $t = Bridge.getEnumerator(keySetup.PixelCovered);
                try {
                    while ($t.moveNext()) {
                        var pixelConfig = $t.Current;
                        var respectedPixel = { v : this.GetOriginalPixelAt(pixelConfig.column, pixelConfig.row) };
                        if (respectedPixel.v != null) {
                            respectedPixel.v.Hidden = true;
                            respectedPixel.v.colorCode = keySetup.ColorCode;
                            respectedPixel.v.Material = keySharedMaterial; // Cp nht sharedMaterial cho pixel b key cover
                            UnityEngine.MonoBehaviour.op_Inequality(respectedPixel.v.PixelComponent, null) ? respectedPixel.v.PixelComponent.SetUp(respectedPixel.v) : null;
                            keyPixels.add(respectedPixel.v);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                if (keyPixels.Count !== keySetup.PixelCovered.Count) {
                    return null;
                }

                var keyPosition = this.GetCenterByBoundingBox$1(System.Linq.Enumerable.from(keyPixels, PaintingPixel).select(function (p) {
                        return p.PixelComponent;
                    }).toList(PaintingPixelComponent));

                // Create the pipe game object with head transform as parent
                var keyGO = UnityEngine.Object.Instantiate$3(UnityEngine.GameObject, this.PrefabSource.KeyObjectPrefab, keyPosition, pc.Quat.IDENTITY.clone(), this.GridTransform);

                keyGO.name = "KEY_OBJECT";

                // Get the PipeObject component from the head
                var keyObject = keyGO.GetComponent(KeyObject);
                if (UnityEngine.MonoBehaviour.op_Equality(keyObject, null)) {
                    keyObject = keyGO.AddComponent(KeyObject);
                }

                // Hide all pixel that covered by key
                for (var i = 0; i < keyPixels.Count; i = (i + 1) | 0) {
                    UnityEngine.MonoBehaviour.op_Inequality(($t1 = keyPixels.getItem(i).PixelComponent), null) ? $t1.HideVisualOnly() : null;
                }

                // Add the pipe setup pixels to the pipeObjectsPixels list if they're not already there
                if (this.keyObjectsPixels == null) {
                    this.keyObjectsPixels = new (System.Collections.Generic.List$1(PaintingPixel)).ctor();
                }
                $t2 = Bridge.getEnumerator(keyPixels);
                try {
                    while ($t2.moveNext()) {
                        var pixel = $t2.Current;
                        if (!this.keyObjectsPixels.contains(pixel)) {
                            this.keyObjectsPixels.add(pixel);
                        }
                    }
                } finally {
                    if (Bridge.is($t2, System.IDisposable)) {
                        $t2.System$IDisposable$Dispose();
                    }
                }

                keyObject.KeyTransform.localScale = this.blockScale.$clone();
                keyObject.Initialize(keyPixels);
                this.KeyObjects.add(keyObject);
                return keyObject;
            },
            /*PaintingGridObject.CreateKeyObject end.*/

            /*PaintingGridObject.ClearAllKeys start.*/
            ClearAllKeys: function () {
if ( TRACE ) { TRACE( "PaintingGridObject#ClearAllKeys", this ); }

                var $t;
                if (this.KeyObjects == null) {
                    this.KeyObjects = new (System.Collections.Generic.List$1(KeyObject)).ctor();
                } else {
                    var tmp = new (System.Collections.Generic.List$1(KeyObject)).$ctor1(this.KeyObjects);
                    $t = Bridge.getEnumerator(tmp);
                    try {
                        while ($t.moveNext()) {
                            var keyObj = $t.Current;
                            this.RemoveKeyObject(keyObj);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
                this.KeyObjects.clear();
                this.keyObjectsPixels.clear();
            },
            /*PaintingGridObject.ClearAllKeys end.*/

            /*PaintingGridObject.RemoveKeyObject start.*/
            RemoveKeyObject: function (_key) {
if ( TRACE ) { TRACE( "PaintingGridObject#RemoveKeyObject", this ); }

                var $t;
                if (UnityEngine.MonoBehaviour.op_Equality(_key, null)) {
                    return;
                }
                if (this.KeyObjects.contains(_key)) {
                    $t = Bridge.getEnumerator(_key.PaintingPixelsCovered);
                    try {
                        while ($t.moveNext()) {
                            var coverPixel = { v : $t.Current };
                            if (this.keyObjectsPixels.contains(coverPixel.v)) {
                                UnityEngine.MonoBehaviour.op_Inequality(coverPixel.v.PixelComponent, null) ? coverPixel.v.PixelComponent.ShowVisualOnly() : null;
                                this.keyObjectsPixels.remove(coverPixel.v);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    _key.SelfDestroy();
                    this.KeyObjects.remove(_key);
                }
            },
            /*PaintingGridObject.RemoveKeyObject end.*/

            /*PaintingGridObject.RemoveKeyObject$1 start.*/
            RemoveKeyObject$1: function (_key) {
if ( TRACE ) { TRACE( "PaintingGridObject#RemoveKeyObject$1", this ); }

                var $t;
                if (_key == null) {
                    return;
                }
                var _keyObject = this.KeyObjects.Find(function (w) {
                    return (w.PaintingPixelsCovered.getItem(0).column === _key.PixelCovered.getItem(0).column) && w.PaintingPixelsCovered.getItem(0).row === _key.PixelCovered.getItem(0).row && w.PaintingPixelsCovered.getItem(((w.PaintingPixelsCovered.Count - 1) | 0)).column === _key.PixelCovered.getItem(((_key.PixelCovered.Count - 1) | 0)).column && w.PaintingPixelsCovered.getItem(((w.PaintingPixelsCovered.Count - 1) | 0)).row === _key.PixelCovered.getItem(((_key.PixelCovered.Count - 1) | 0)).row;
                });
                if (UnityEngine.MonoBehaviour.op_Equality(_keyObject, null)) {
                    return;
                }
                if (this.KeyObjects.contains(_keyObject)) {
                    $t = Bridge.getEnumerator(_keyObject.PaintingPixelsCovered);
                    try {
                        while ($t.moveNext()) {
                            var coverPixel = { v : $t.Current };
                            if (this.keyObjectsPixels.contains(coverPixel.v)) {
                                UnityEngine.MonoBehaviour.op_Inequality(coverPixel.v.PixelComponent, null) ? coverPixel.v.PixelComponent.ShowVisualOnly() : null;
                                this.keyObjectsPixels.remove(coverPixel.v);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    _keyObject.SelfDestroy();
                    this.KeyObjects.remove(_keyObject);
                }
            },
            /*PaintingGridObject.RemoveKeyObject$1 end.*/

            /*PaintingGridObject.GetCenterByBoundingBox$1 start.*/
            GetCenterByBoundingBox$1: function (points) {
if ( TRACE ) { TRACE( "PaintingGridObject#GetCenterByBoundingBox$1", this ); }

                if (points == null || points.Count === 0) {
                    return pc.Vec3.ZERO.clone();
                }

                if (points.Count === 1) {
                    return points.getItem(0).PixelData.worldPos.$clone();
                }

                var minX = System.Linq.Enumerable.from(points, PaintingPixelComponent).min(function (p) {
                        return p.transform.position.x;
                    });
                var maxX = System.Linq.Enumerable.from(points, PaintingPixelComponent).max(function (p) {
                        return p.transform.position.x;
                    });
                var minY = System.Linq.Enumerable.from(points, PaintingPixelComponent).min(function (p) {
                        return p.transform.position.y;
                    });
                var maxY = System.Linq.Enumerable.from(points, PaintingPixelComponent).max(function (p) {
                        return p.transform.position.y;
                    });
                var minZ = System.Linq.Enumerable.from(points, PaintingPixelComponent).min(function (p) {
                        return p.transform.position.z;
                    });
                var maxZ = System.Linq.Enumerable.from(points, PaintingPixelComponent).max(function (p) {
                        return p.transform.position.z;
                    });

                return new pc.Vec3( (minX + maxX) * 0.5, (minY + maxY) * 0.5, (minZ + maxZ) * 0.5 );
            },
            /*PaintingGridObject.GetCenterByBoundingBox$1 end.*/

            /*PaintingGridObject.GetCenterByBoundingBox start.*/
            GetCenterByBoundingBox: function (points) {
if ( TRACE ) { TRACE( "PaintingGridObject#GetCenterByBoundingBox", this ); }

                if (points == null || points.Count === 0) {
                    return pc.Vec3.ZERO.clone();
                }

                if (points.Count === 1) {
                    return this.CalculatePixelPosition(points.getItem(0).column, points.getItem(0).row, this.YOffset);
                }

                var minX = System.Linq.Enumerable.from(points, PaintingPixel).min(Bridge.fn.bind(this, function (p) {
                        return this.CalculatePixelPosition(p.column, p.row, this.YOffset).x;
                    }));
                var maxX = System.Linq.Enumerable.from(points, PaintingPixel).max(Bridge.fn.bind(this, function (p) {
                        return this.CalculatePixelPosition(p.column, p.row, this.YOffset).x;
                    }));
                var minY = System.Linq.Enumerable.from(points, PaintingPixel).min(Bridge.fn.bind(this, function (p) {
                        return this.CalculatePixelPosition(p.column, p.row, this.YOffset).y;
                    }));
                var maxY = System.Linq.Enumerable.from(points, PaintingPixel).max(Bridge.fn.bind(this, function (p) {
                        return this.CalculatePixelPosition(p.column, p.row, this.YOffset).y;
                    }));
                var minZ = System.Linq.Enumerable.from(points, PaintingPixel).min(Bridge.fn.bind(this, function (p) {
                        return this.CalculatePixelPosition(p.column, p.row, this.YOffset).z;
                    }));
                var maxZ = System.Linq.Enumerable.from(points, PaintingPixel).max(Bridge.fn.bind(this, function (p) {
                        return this.CalculatePixelPosition(p.column, p.row, this.YOffset).z;
                    }));

                return new pc.Vec3( (minX + maxX) * 0.5, (minY + maxY) * 0.5, (minZ + maxZ) * 0.5 );
            },
            /*PaintingGridObject.GetCenterByBoundingBox end.*/

            /*PaintingGridObject.GetPixelComponentNeighbor start.*/
            GetPixelComponentNeighbor: function (_origin) {
if ( TRACE ) { TRACE( "PaintingGridObject#GetPixelComponentNeighbor", this ); }

                var $t, $t1;
                var _rs = new (System.Collections.Generic.List$1(PaintingPixelComponent)).ctor();
                var count = 0;
                var columnPixels = { };
                if (this.pixelsByColumn.tryGetValue(_origin.column, columnPixels)) {
                    $t = Bridge.getEnumerator(columnPixels.v);
                    try {
                        while ($t.moveNext()) {
                            var pixel = $t.Current;
                            if ((pixel.row === ((_origin.row + 1) | 0) || pixel.row === ((_origin.row - 1) | 0)) && UnityEngine.MonoBehaviour.op_Inequality(pixel.PixelComponent, null)) {
                                _rs.add(pixel.PixelComponent);
                                count = (count + 1) | 0;
                                if (count >= 2) {
                                    break;
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
                var rowPixels = { };

                if (this.pixelsByRow.tryGetValue(_origin.row, rowPixels)) {
                    $t1 = Bridge.getEnumerator(rowPixels.v);
                    try {
                        while ($t1.moveNext()) {
                            var pixel1 = $t1.Current;
                            if ((pixel1.column === ((_origin.column + 1) | 0) || pixel1.column === ((_origin.column - 1) | 0)) && UnityEngine.MonoBehaviour.op_Inequality(pixel1.PixelComponent, null)) {
                                _rs.add(pixel1.PixelComponent);
                                count = (count + 1) | 0;
                                if (count >= 4) {
                                    break;
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                }

                return _rs;
            },
            /*PaintingGridObject.GetPixelComponentNeighbor end.*/

            /*PaintingGridObject.GetShapeSize start.*/
            GetShapeSize: function (pixels) {
if ( TRACE ) { TRACE( "PaintingGridObject#GetShapeSize", this ); }

                if (pixels == null || pixels.Count === 0) {
                    return new (System.ValueTuple$2(System.Int32,System.Int32)).$ctor1(0, 0);
                }

                if (pixels.Count === 1) {
                    return new (System.ValueTuple$2(System.Int32,System.Int32)).$ctor1(1, 1);
                }

                var minRow = System.Linq.Enumerable.from(pixels, PaintingPixel).min(function (p) {
                        return p.row;
                    });
                var maxRow = System.Linq.Enumerable.from(pixels, PaintingPixel).max(function (p) {
                        return p.row;
                    });
                var minCol = System.Linq.Enumerable.from(pixels, PaintingPixel).min(function (p) {
                        return p.column;
                    });
                var maxCol = System.Linq.Enumerable.from(pixels, PaintingPixel).max(function (p) {
                        return p.column;
                    });

                var rowCount = (((maxRow - minRow) | 0) + 1) | 0;
                var columnCount = (((maxCol - minCol) | 0) + 1) | 0;

                return new (System.ValueTuple$2(System.Int32,System.Int32)).$ctor1(rowCount, columnCount);
            },
            /*PaintingGridObject.GetShapeSize end.*/

            /*PaintingGridObject.GetPixelAtGridPosition start.*/
            GetPixelAtGridPosition: function (column, row) {
if ( TRACE ) { TRACE( "PaintingGridObject#GetPixelAtGridPosition", this ); }

                var $t;
                var colPixels = { };
                if (this.pixelsByColumn.tryGetValue(column, colPixels)) {
                    $t = Bridge.getEnumerator(colPixels.v);
                    try {
                        while ($t.moveNext()) {
                            var pixel = $t.Current;
                            if (pixel.row === row) {
                                return pixel;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
                return null;
            },
            /*PaintingGridObject.GetPixelAtGridPosition end.*/

            /*PaintingGridObject.GetOriginalPixelAt start.*/
            GetOriginalPixelAt: function (column, row) {
if ( TRACE ) { TRACE( "PaintingGridObject#GetOriginalPixelAt", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.paintingPixels);
                try {
                    while ($t.moveNext()) {
                        var pixel = $t.Current;
                        if (pixel.column === column && pixel.row === row) {
                            return pixel;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return null;
            },
            /*PaintingGridObject.GetOriginalPixelAt end.*/

            /*PaintingGridObject.GetPixelsInRow start.*/
            /**
             * Gets all pixels in a specific row
             *
             * @instance
             * @public
             * @this PaintingGridObject
             * @memberof PaintingGridObject
             * @param   {number}                               row    The row index to get pixels from
             * @return  {System.Collections.Generic.List$1}           List of pixels in the specified row, or empty list if row doesn't exist
             */
            GetPixelsInRow: function (row) {
if ( TRACE ) { TRACE( "PaintingGridObject#GetPixelsInRow", this ); }

                if (this.pixelsByRow == null) {
                    return new (System.Collections.Generic.List$1(PaintingPixel)).ctor(); // Return empty list if mappings not initialized
                }
                var rowPixels = { };

                if (!this.pixelsByRow.tryGetValue(row, rowPixels)) {
                    return new (System.Collections.Generic.List$1(PaintingPixel)).ctor();
                }
                return new (System.Collections.Generic.List$1(PaintingPixel)).$ctor1(rowPixels.v);
            },
            /*PaintingGridObject.GetPixelsInRow end.*/

            /*PaintingGridObject.GetPixelsInColumn start.*/
            /**
             * Gets all pixels in a specific column
             *
             * @instance
             * @public
             * @this PaintingGridObject
             * @memberof PaintingGridObject
             * @param   {number}                               column    The column index to get pixels from
             * @return  {System.Collections.Generic.List$1}              List of pixels in the specified column, or empty list if column doesn't exist
             */
            GetPixelsInColumn: function (column) {
if ( TRACE ) { TRACE( "PaintingGridObject#GetPixelsInColumn", this ); }

                if (this.pixelsByColumn == null) {
                    return new (System.Collections.Generic.List$1(PaintingPixel)).ctor(); // Return empty list if mappings not initialized
                }
                var colPixels = { };

                if (!this.pixelsByColumn.tryGetValue(column, colPixels)) {
                    return new (System.Collections.Generic.List$1(PaintingPixel)).ctor();
                }
                return new (System.Collections.Generic.List$1(PaintingPixel)).$ctor1(colPixels.v);
            },
            /*PaintingGridObject.GetPixelsInColumn end.*/

            /*PaintingGridObject.ApplyColorVariation start.*/
            ApplyColorVariation: function (originalColor, variationAmount) {
if ( TRACE ) { TRACE( "PaintingGridObject#ApplyColorVariation", this ); }

                if (variationAmount <= 0.0) {
                    return originalColor.$clone();
                }

                // Generate random variations within the specified range for each color component
                var rVariation = UnityEngine.Random.Range$1(-variationAmount, variationAmount);
                var gVariation = UnityEngine.Random.Range$1(-variationAmount, variationAmount);
                var bVariation = UnityEngine.Random.Range$1(-variationAmount, variationAmount);

                // Apply the variations to each color component, ensuring values stay within [0, 1] range
                var newR = Math.max(0, Math.min(1, originalColor.r + rVariation));
                var newG = Math.max(0, Math.min(1, originalColor.g + gVariation));
                var newB = Math.max(0, Math.min(1, originalColor.b + bVariation));

                // Return the new color with applied variation (keeping the original alpha)
                return new pc.Color( newR, newG, newB, originalColor.a );
            },
            /*PaintingGridObject.ApplyColorVariation end.*/

            /*PaintingGridObject.GetTotalPixels start.*/
            GetTotalPixels: function () {
if ( TRACE ) { TRACE( "PaintingGridObject#GetTotalPixels", this ); }

                return this.paintingPixels.Count;
            },
            /*PaintingGridObject.GetTotalPixels end.*/

            /*PaintingGridObject.ClearToWhite start.*/
            ClearToWhite: function () {
if ( TRACE ) { TRACE( "PaintingGridObject#ClearToWhite", this ); }

                var $t;
                // Ly material trng t palette nu c, fallback base
                var whiteMaterial = this.GetMaterialByColorCode("white");

                $t = Bridge.getEnumerator(this.paintingPixels);
                try {
                    while ($t.moveNext()) {
                        var pixel = $t.Current;
                        if (pixel != null && UnityEngine.MonoBehaviour.op_Inequality(pixel.PixelComponent, null)) {
                            pixel.color = new pc.Color( 1, 1, 1, 1 );
                            pixel.colorCode = "white";
                            pixel.Material = whiteMaterial;
                            pixel.UsePaletteMaterialColor = true; // bo m khng override

                            pixel.PixelComponent.CubeRenderer.sharedMaterial = whiteMaterial;
                            pixel.PixelComponent.ClearColorOverride(); // xo MPB nu cn
                            pixel.ShowPixelObject();
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.ClearAllAdditionPixels();
            },
            /*PaintingGridObject.ClearToWhite end.*/

            /*PaintingGridObject.CalculatePixelPosition start.*/
            CalculatePixelPosition: function (col, row, yOffset) {
if ( TRACE ) { TRACE( "PaintingGridObject#CalculatePixelPosition", this ); }

                if (yOffset === void 0) { yOffset = 0.0; }
                var xPos = this.GridTransform.position.x + col * this.pixelArrangeSpace;
                var zPos = this.GridTransform.position.z + row * this.pixelArrangeSpace; // Positive rows go "up" in z-axis
                return new pc.Vec3( xPos, this.GridTransform.position.y + yOffset, zPos );
            },
            /*PaintingGridObject.CalculatePixelPosition end.*/

            /*PaintingGridObject.CalculatePixelPositionAbstract start.*/
            CalculatePixelPositionAbstract: function (col, row, yOffset) {
if ( TRACE ) { TRACE( "PaintingGridObject#CalculatePixelPositionAbstract", this ); }

                if (yOffset === void 0) { yOffset = 0.0; }
                var xPos = this.GridTransform.position.x + col * this.pixelArrangeSpace;
                var zPos = this.GridTransform.position.z + row * this.pixelArrangeSpace; // Positive rows go "up" in z-axis
                var rs = new pc.Vec3( xPos, this.GridTransform.position.y + yOffset, zPos );
                return rs.$clone();
            },
            /*PaintingGridObject.CalculatePixelPositionAbstract end.*/

            /*PaintingGridObject.CreateNewPaintingPixelAbstract start.*/
            CreateNewPaintingPixelAbstract: function (pixelConfig, calculatePositon, sharedMaterial) {
if ( TRACE ) { TRACE( "PaintingGridObject#CreateNewPaintingPixelAbstract", this ); }

                var $t;
                if (calculatePositon === void 0) { calculatePositon = false; }
                if (sharedMaterial === void 0) { sharedMaterial = null; }
                if (sharedMaterial == null) {
                    sharedMaterial = this.basePixelSharedMaterial;
                } // Fallback
                var pixel = ($t = new PaintingPixel.ctor(), $t.column = pixelConfig.column, $t.row = pixelConfig.row, $t.color = pixelConfig.color.$clone(), $t.colorCode = pixelConfig.colorCode, $t.Hidden = pixelConfig.Hidden, $t.Material = sharedMaterial, $t);
                if (calculatePositon) {
                    pixel.worldPos = this.CalculatePixelPositionAbstract(pixel.column, pixel.row, this.YOffset);
                }

                return pixel;
            },
            /*PaintingGridObject.CreateNewPaintingPixelAbstract end.*/

            /*PaintingGridObject.CreateNewPaintingPixelReal start.*/
            CreateNewPaintingPixelReal: function (pixelConfig, calculatePositon) {
if ( TRACE ) { TRACE( "PaintingGridObject#CreateNewPaintingPixelReal", this ); }

                if (calculatePositon === void 0) { calculatePositon = false; }
                var worldPos = this.CalculatePixelPosition(pixelConfig.column, pixelConfig.row, this.YOffset);

                var pixelGO = null;
                pixelGO = UnityEngine.Object.Instantiate$3(UnityEngine.GameObject, this.pixelPrefab, worldPos, pc.Quat.IDENTITY.clone(), this.GridTransform);
                pixelGO.transform.localScale = this.blockScale.$clone();
                pixelGO.name = System.String.format("Addition_Pixel ({0}, {1})", Bridge.box(pixelConfig.column, System.Int32), Bridge.box(pixelConfig.row, System.Int32));

                var _c = new pc.Color( 1, 1, 1, 1 );
                var effectiveColorCode = pixelConfig.colorCode;

                if (effectiveColorCode != null) {
                    _c = System.String.equals(effectiveColorCode, PaintingSharedAttributes.TransparentColorKey) ? new pc.Color( 1, 1, 1, 1 ) : (this.ActivePalette != null ? this.ActivePalette.GetColorByCode(effectiveColorCode) : new pc.Color( 1, 1, 1, 1 ));
                }

                // Ly material trc tip t ColorPalette (hoc fallback)
                var pixelSharedMaterial = this.GetMaterialByColorCode(effectiveColorCode);

                // Create PaintingPixel with reference to its GameObject
                var newPixel = new PaintingPixel.$ctor2(pixelConfig.column, pixelConfig.row, _c.$clone(), worldPos.$clone(), 1, pixelConfig.Hidden, pixelGO, pixelSharedMaterial);
                newPixel.colorCode = effectiveColorCode;
                newPixel.UsePaletteMaterialColor = true; // tn trng mu t material palette

                // Store reference to the pixel in the pixel gameobject if needed
                if (UnityEngine.GameObject.op_Inequality(pixelGO, null)) {
                    var pixelComponent = pixelGO.GetComponent(PaintingPixelComponent);
                    if (UnityEngine.MonoBehaviour.op_Inequality(pixelComponent, null)) {
                        pixelComponent.SetUp(newPixel);
                    }
                }
                newPixel.SetUp(_c, effectiveColorCode, pixelConfig.Hidden);

                return newPixel;
            },
            /*PaintingGridObject.CreateNewPaintingPixelReal end.*/

            /*PaintingGridObject.ClearAllAdditionPixels start.*/
            ClearAllAdditionPixels: function () {
if ( TRACE ) { TRACE( "PaintingGridObject#ClearAllAdditionPixels", this ); }

                var $t;
                if (this.AdditionPaintingPixels.Count <= 0) {
                    return;
                }
                $t = Bridge.getEnumerator(this.AdditionPaintingPixels);
                try {
                    while ($t.moveNext()) {
                        var pixel = { v : $t.Current };
                        UnityEngine.MonoBehaviour.op_Inequality(pixel.v.PixelComponent, null) ? pixel.v.PixelComponent.SelfDestroy() : null;
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.AdditionPaintingPixels.clear();
            },
            /*PaintingGridObject.ClearAllAdditionPixels end.*/

            /*PaintingGridObject.GetLocalBorderPositions start.*/
            GetLocalBorderPositions: function (regionPixels) {
if ( TRACE ) { TRACE( "PaintingGridObject#GetLocalBorderPositions", this ); }

                var result = new (System.Collections.Generic.List$1(UnityEngine.Vector2)).ctor();
                if (regionPixels == null || regionPixels.Count === 0) {
                    return result;
                }

                var minCol = System.Linq.Enumerable.from(regionPixels, PaintingPixel).min(function (p) {
                        return p.column;
                    });
                var maxCol = System.Linq.Enumerable.from(regionPixels, PaintingPixel).max(function (p) {
                        return p.column;
                    });
                var minRow = System.Linq.Enumerable.from(regionPixels, PaintingPixel).min(function (p) {
                        return p.row;
                    });
                var maxRow = System.Linq.Enumerable.from(regionPixels, PaintingPixel).max(function (p) {
                        return p.row;
                    });

                // --- TOP & BOTTOM ---
                for (var col = minCol; col <= maxCol; col = (col + 1) | 0) {
                    var topRow = (maxRow + 1) | 0;
                    var bottomRow = (minRow - 1) | 0;

                    if (this.PixelExists(col, topRow)) {
                        result.add(new pc.Vec2( col, topRow ));
                    }

                    if (this.PixelExists(col, bottomRow)) {
                        result.add(new pc.Vec2( col, bottomRow ));
                    }
                }

                // --- LEFT & RIGHT ---
                for (var row = minRow; row <= maxRow; row = (row + 1) | 0) {
                    var leftCol = (minCol - 1) | 0;
                    var rightCol = (maxCol + 1) | 0;

                    if (this.PixelExists(leftCol, row)) {
                        result.add(new pc.Vec2( leftCol, row ));
                    }

                    if (this.PixelExists(rightCol, row)) {
                        result.add(new pc.Vec2( rightCol, row ));
                    }
                }

                return result;
            },
            /*PaintingGridObject.GetLocalBorderPositions end.*/

            /*PaintingGridObject.PixelExists start.*/
            PixelExists: function (col, row) {
if ( TRACE ) { TRACE( "PaintingGridObject#PixelExists", this ); }

                var $t, $t1;
                var rowPixels = { };
                if (this.pixelsByRow.tryGetValue(row, rowPixels)) {
                    $t = Bridge.getEnumerator(rowPixels.v);
                    try {
                        while ($t.moveNext()) {
                            var pixel = $t.Current;
                            if (pixel.column === col && !pixel.Hidden) {
                                return true;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
                var colPixels = { };

                if (this.pixelsByColumn.tryGetValue(col, colPixels)) {
                    $t1 = Bridge.getEnumerator(colPixels.v);
                    try {
                        while ($t1.moveNext()) {
                            var pixel1 = $t1.Current;
                            if (pixel1.row === row && !pixel1.Hidden) {
                                return true;
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                }

                return false;
            },
            /*PaintingGridObject.PixelExists end.*/

            /*PaintingGridObject.IsPixelDestroyed start.*/
            IsPixelDestroyed: function (col, row) {
if ( TRACE ) { TRACE( "PaintingGridObject#IsPixelDestroyed", this ); }

                var rs = this.GetPixelAtGridPosition(col, row);
                return rs != null && rs.destroyed;
            },
            /*PaintingGridObject.IsPixelDestroyed end.*/

            /*PaintingGridObject.GetPixelBasedOnPosition start.*/
            GetPixelBasedOnPosition: function (_pos, presicion) {
if ( TRACE ) { TRACE( "PaintingGridObject#GetPixelBasedOnPosition", this ); }

                var $t, $t1;
                if (presicion === void 0) { presicion = 0.5; }
                var rs = null;
                var minDist = 3.40282347E+38;
                $t = Bridge.getEnumerator(this.paintingPixels);
                try {
                    while ($t.moveNext()) {
                        var pixel = $t.Current;
                        if (pixel != null && UnityEngine.MonoBehaviour.op_Inequality(pixel.PixelComponent, null)) {
                            var dis = pc.Vec3.distance( pixel.PixelComponent.transform.position, _pos );
                            if (dis < minDist) {
                                minDist = dis;
                                rs = pixel.PixelComponent;
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                $t1 = Bridge.getEnumerator(this.AdditionPaintingPixels);
                try {
                    while ($t1.moveNext()) {
                        var pixel1 = $t1.Current;
                        if (pixel1 != null && UnityEngine.MonoBehaviour.op_Inequality(pixel1.PixelComponent, null)) {
                            var dis1 = pc.Vec3.distance( pixel1.PixelComponent.transform.position, _pos );
                            if (dis1 < minDist) {
                                minDist = dis1;
                                rs = pixel1.PixelComponent;
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                return rs;
            },
            /*PaintingGridObject.GetPixelBasedOnPosition end.*/

            /*PaintingGridObject.GetPixelBasedOnPositionNewNeeded start.*/
            GetPixelBasedOnPositionNewNeeded: function (_pos, paintingConfig, presicion, addToAdditional) {
if ( TRACE ) { TRACE( "PaintingGridObject#GetPixelBasedOnPositionNewNeeded", this ); }

                var $t, $t1;
                if (presicion === void 0) { presicion = 0.25; }
                if (addToAdditional === void 0) { addToAdditional = false; }
                var _temprs = null;
                var _rs = null;
                var minDist = 3.40282347E+38;
                $t = Bridge.getEnumerator(this.paintingPixels);
                try {
                    while ($t.moveNext()) {
                        var pixel = $t.Current;
                        if (pixel != null && UnityEngine.MonoBehaviour.op_Inequality(pixel.PixelComponent, null)) {
                            var dis = pc.Vec3.distance( pixel.PixelComponent.transform.position, _pos );
                            if (dis < minDist) {
                                minDist = dis;
                                _temprs = pixel.PixelComponent;
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                $t1 = Bridge.getEnumerator(this.AdditionPaintingPixels);
                try {
                    while ($t1.moveNext()) {
                        var pixel1 = $t1.Current;
                        if (pixel1 != null && UnityEngine.MonoBehaviour.op_Inequality(pixel1.PixelComponent, null)) {
                            var dis1 = pc.Vec3.distance( pixel1.PixelComponent.transform.position, _pos );
                            if (dis1 < minDist) {
                                minDist = dis1;
                                _temprs = pixel1.PixelComponent;
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                if (minDist > presicion) {
                    _rs = null;
                    _pos.y = this.YOffset;
                    var col = { };
                    var row = { };
                    var cellPos = { v : new UnityEngine.Vector3() };
                    Bridge.Deconstruct(this.GetPredictedPixel(_pos).$clone(), col, row, cellPos);

                    var _new = new PaintingPixelConfig.ctor();
                    _new.row = row.v;
                    _new.column = col.v;

                    if (row.v === _temprs.PixelData.row && col.v === _temprs.PixelData.column) {
                        return _temprs;
                    } else if (addToAdditional) {
                        var alreadyInOfficalPixels = System.Linq.Enumerable.from(this.paintingPixels, PaintingPixel).any(function (x) {
                                return (x.column === _new.column && x.row === _new.row);
                            });
                        var alreadyInAdditionPixels = System.Linq.Enumerable.from(this.AdditionPaintingPixels, PaintingPixel).any(function (x) {
                                return (x.column === _new.column && x.row === _new.row);
                            });

                        if (alreadyInOfficalPixels || alreadyInAdditionPixels) {
                            return _temprs;
                        }

                        var _newPixel = this.CreateNewPaintingPixelReal(_new, false); // CreateNewPaintingPixelReal s t ng qun l sharedMaterial
                        _rs = _newPixel.PixelComponent;
                        if (!this.AdditionPaintingPixels.contains(_newPixel)) {
                            this.AdditionPaintingPixels.add(_newPixel);
                        }
                        if (!paintingConfig.AdditionPixels.contains(_new)) {
                            paintingConfig.AdditionPixels.add(_new);
                        }
                        return _rs;
                    }
                }

                return _temprs;
            },
            /*PaintingGridObject.GetPixelBasedOnPositionNewNeeded end.*/

            /*PaintingGridObject.GetPredictedPixel start.*/
            GetPredictedPixel: function (pos) {
if ( TRACE ) { TRACE( "PaintingGridObject#GetPredictedPixel", this ); }

                var localX = pos.x + this.GridTransform.position.x - this.GridTransform.position.x;
                var localZ = pos.z - this.GridTransform.position.z;

                var col = Math.round(localX / this.pixelArrangeSpace);
                var row = Math.round(localZ / this.pixelArrangeSpace);
                var pixelPos = this.CalculatePixelPosition(col, row, this.YOffset);

                return new (System.ValueTuple$3(System.Int32,System.Int32,UnityEngine.Vector3)).$ctor1(col, row, pixelPos.$clone());
            },
            /*PaintingGridObject.GetPredictedPixel end.*/

            /*PaintingGridObject.UpdatePixelWorldPos start.*/
            UpdatePixelWorldPos: function () {
if ( TRACE ) { TRACE( "PaintingGridObject#UpdatePixelWorldPos", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.paintingPixels);
                try {
                    while ($t.moveNext()) {
                        var pixel = $t.Current;
                        pixel.worldPos = pixel.PixelComponent.transform.localPosition.$clone();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*PaintingGridObject.UpdatePixelWorldPos end.*/


        },
        overloads: {
            "RemoveWallObject(WallObjectSetup)": "RemoveWallObject$1",
            "RemoveKeyObject(KeyObjectSetup)": "RemoveKeyObject$1",
            "GetCenterByBoundingBox(List<PaintingPixelComponent>)": "GetCenterByBoundingBox$1"
        }
    });
    /*PaintingGridObject end.*/

    /*PaintingLayoutAdjustModule start.*/
    Bridge.define("PaintingLayoutAdjustModule", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            PaintingSetup: null,
            ColorCode: null,
            SelectedPixels: null,
            GridLayerMask: null,
            IsPaintingToolActive: false,
            IsDeleteToolActive: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "PaintingLayoutAdjustModule#init", this ); }

                this.GridLayerMask = new UnityEngine.LayerMask();
                this.IsPaintingToolActive = false;
                this.IsDeleteToolActive = false;
            }
        },
        methods: {
            /*PaintingLayoutAdjustModule.SetColor start.*/
            SetColor: function () {
if ( TRACE ) { TRACE( "PaintingLayoutAdjustModule#SetColor", this ); }

                var $t, $t1;
                if (UnityEngine.MonoBehaviour.op_Equality(this.PaintingSetup, null) || this.PaintingSetup.CurrentPaintingConfig == null || this.PaintingSetup.PrefabSource.ColorPallete == null) {
                    return;
                }
                if (this.SelectedPixels.Count > 0) {
                    $t = Bridge.getEnumerator(this.SelectedPixels);
                    try {
                        while ($t.moveNext()) {
                            var _pixel = { v : $t.Current };
                            var respectedPixel = this.PaintingSetup.CurrentPaintingConfig.AdditionPixels.Find((function ($me, _pixel) {
                                return function (p) {
                                    return p.row === _pixel.v.PixelData.row && p.column === _pixel.v.PixelData.column;
                                };
                            })(this, _pixel));
                            if (respectedPixel != null) {
                                respectedPixel.Hidden = false;
                                respectedPixel.color = this.PaintingSetup.PrefabSource.ColorPallete.GetColorByCode(this.ColorCode);
                                respectedPixel.colorCode = this.ColorCode;
                            }
                            _pixel.v.PixelData.colorCode = this.ColorCode;
                            _pixel.v.SetColor(this.PaintingSetup.PrefabSource.ColorPallete.GetColorByCode(this.ColorCode));
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    $t1 = Bridge.getEnumerator(this.SelectedPixels);
                    try {
                        while ($t1.moveNext()) {
                            var _pixel1 = { v : $t1.Current };
                            var respectedPixel1 = this.PaintingSetup.CurrentPaintingConfig.Pixels.Find((function ($me, _pixel1) {
                                return function (p) {
                                    return p.row === _pixel1.v.PixelData.row && p.column === _pixel1.v.PixelData.column;
                                };
                            })(this, _pixel1));
                            if (respectedPixel1 != null) {
                                respectedPixel1.Hidden = false;
                                respectedPixel1.color = this.PaintingSetup.PrefabSource.ColorPallete.GetColorByCode(this.ColorCode);
                                respectedPixel1.colorCode = this.ColorCode;
                            }
                            _pixel1.v.PixelData.colorCode = this.ColorCode;
                            _pixel1.v.SetColor(this.PaintingSetup.PrefabSource.ColorPallete.GetColorByCode(this.ColorCode));
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                }
            },
            /*PaintingLayoutAdjustModule.SetColor end.*/

            /*PaintingLayoutAdjustModule.SetHideSelected start.*/
            SetHideSelected: function () {
if ( TRACE ) { TRACE( "PaintingLayoutAdjustModule#SetHideSelected", this ); }

                var $t, $t1;
                if (UnityEngine.MonoBehaviour.op_Equality(this.PaintingSetup, null) || this.PaintingSetup.CurrentPaintingConfig == null || this.PaintingSetup.PrefabSource.ColorPallete == null) {
                    return;
                }
                if (this.SelectedPixels.Count > 0) {
                    var _t = new pc.Color( 1, 1, 1, 1 );
                    _t.a = 0;
                    $t = Bridge.getEnumerator(this.SelectedPixels);
                    try {
                        while ($t.moveNext()) {
                            var _pixel = { v : $t.Current };
                            var respectedPixel = this.PaintingSetup.CurrentPaintingConfig.AdditionPixels.Find((function ($me, _pixel) {
                                return function (p) {
                                    return p.row === _pixel.v.PixelData.row && p.column === _pixel.v.PixelData.column;
                                };
                            })(this, _pixel));
                            if (respectedPixel != null) {
                                respectedPixel.color = _t.$clone();
                                respectedPixel.Hidden = true;
                                respectedPixel.colorCode = PaintingSharedAttributes.TransparentColorKey;
                            }
                            _pixel.v.PixelData.colorCode = PaintingSharedAttributes.TransparentColorKey;
                            _pixel.v.SetColor(_t);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    $t1 = Bridge.getEnumerator(this.SelectedPixels);
                    try {
                        while ($t1.moveNext()) {
                            var _pixel1 = { v : $t1.Current };
                            var respectedPixel1 = this.PaintingSetup.CurrentPaintingConfig.Pixels.Find((function ($me, _pixel1) {
                                return function (p) {
                                    return p.row === _pixel1.v.PixelData.row && p.column === _pixel1.v.PixelData.column;
                                };
                            })(this, _pixel1));
                            if (respectedPixel1 != null) {
                                respectedPixel1.color = _t.$clone();
                                respectedPixel1.Hidden = true;
                                respectedPixel1.colorCode = PaintingSharedAttributes.TransparentColorKey;
                            }
                            _pixel1.v.PixelData.colorCode = PaintingSharedAttributes.TransparentColorKey;
                            _pixel1.v.SetColor(_t);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                }
            },
            /*PaintingLayoutAdjustModule.SetHideSelected end.*/

            /*PaintingLayoutAdjustModule.AddLineAbove start.*/
            AddLineAbove: function () {
if ( TRACE ) { TRACE( "PaintingLayoutAdjustModule#AddLineAbove", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.PaintingSetup, null) || this.PaintingSetup.CurrentPaintingConfig == null) {
                    return;
                }
                var lowestRow = { };
                var highestRow = { };
                var leftColumn = { };
                var rightColumn = { };
                Bridge.Deconstruct(this.GetBounds().$clone(), lowestRow, highestRow, leftColumn, rightColumn);

                var newLineAbove = new (System.Collections.Generic.List$1(PaintingPixelConfig)).ctor();
                var smallestColumn = 0;
                var biggestColumn = 0;
                var colCount = Bridge.Int.clip32(this.PaintingSetup.CurrentPaintingConfig.PaintingSize.y);

                if (colCount % 2 === 0) {
                    smallestColumn = (Bridge.Int.div(((-colCount) | 0), 2)) | 0;
                    biggestColumn = (((Bridge.Int.div(colCount, 2)) | 0) - 1) | 0;
                } else {
                    smallestColumn = (Bridge.Int.div(((-(((colCount - 1) | 0))) | 0), 2)) | 0;
                    biggestColumn = (Bridge.Int.div((((colCount - 1) | 0)), 2)) | 0;
                }

                for (var i = smallestColumn; i <= biggestColumn; i = (i + 1) | 0) {
                    var newPixel = new PaintingPixelConfig.ctor();
                    newPixel.row = (highestRow.v + 1) | 0;
                    newPixel.column = i;
                    newPixel.color = new pc.Color( 1, 1, 1, 1 );
                    newPixel.colorCode = PaintingSharedAttributes.DefaultColorKey;
                    newLineAbove.add(newPixel);
                }

                this.PaintingSetup.CurrentPaintingConfig.AdditionPixels.AddRange(newLineAbove);
                this.PaintingSetup.CurrentGridObject.ApplyPaintingConfig(this.PaintingSetup.CurrentPaintingConfig);
            },
            /*PaintingLayoutAdjustModule.AddLineAbove end.*/

            /*PaintingLayoutAdjustModule.AddLineBelow start.*/
            AddLineBelow: function () {
if ( TRACE ) { TRACE( "PaintingLayoutAdjustModule#AddLineBelow", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.PaintingSetup, null) || this.PaintingSetup.CurrentPaintingConfig == null) {
                    return;
                }
                var lowestRow = { };
                var highestrow = { };
                var leftColumn = { };
                var rightColumn = { };
                Bridge.Deconstruct(this.GetBounds().$clone(), lowestRow, highestrow, leftColumn, rightColumn);

                var newLineBelow = new (System.Collections.Generic.List$1(PaintingPixelConfig)).ctor();
                var smalestColumn = 0;
                var biggestColumn = 0;
                var colCount = Bridge.Int.clip32(this.PaintingSetup.CurrentPaintingConfig.PaintingSize.y);
                if (colCount % 2 === 0) {
                    smalestColumn = (Bridge.Int.div(((-colCount) | 0), 2)) | 0;
                    biggestColumn = (((Bridge.Int.div(colCount, 2)) | 0) - 1) | 0;
                } else {
                    smalestColumn = (Bridge.Int.div(((-(((colCount - 1) | 0))) | 0), 2)) | 0;
                    biggestColumn = (Bridge.Int.div((((colCount - 1) | 0)), 2)) | 0;
                }
                for (var i = smalestColumn; i <= biggestColumn; i = (i + 1) | 0) {
                    var newPixel = new PaintingPixelConfig.ctor();
                    newPixel.row = (lowestRow.v - 1) | 0;
                    newPixel.column = i;
                    newPixel.color = new pc.Color( 1, 1, 1, 1 );
                    newPixel.colorCode = PaintingSharedAttributes.DefaultColorKey;
                    newLineBelow.add(newPixel);
                }

                this.PaintingSetup.CurrentPaintingConfig.AdditionPixels.AddRange(newLineBelow);
                this.PaintingSetup.CurrentGridObject.ApplyPaintingConfig(this.PaintingSetup.CurrentPaintingConfig);
            },
            /*PaintingLayoutAdjustModule.AddLineBelow end.*/

            /*PaintingLayoutAdjustModule.AddLineLeft start.*/
            AddLineLeft: function () {
if ( TRACE ) { TRACE( "PaintingLayoutAdjustModule#AddLineLeft", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.PaintingSetup, null) || this.PaintingSetup.CurrentPaintingConfig == null) {
                    return;
                }
                var lowestRow = { };
                var highestRow = { };
                var leftColumn = { };
                var rightColumn = { };
                Bridge.Deconstruct(this.GetBounds().$clone(), lowestRow, highestRow, leftColumn, rightColumn);

                var newLineLeft = new (System.Collections.Generic.List$1(PaintingPixelConfig)).ctor();
                var smallestRow = 0;
                var biggestRow = 0;
                var rowCount = Bridge.Int.clip32(this.PaintingSetup.CurrentPaintingConfig.PaintingSize.x);

                if (rowCount % 2 === 0) {
                    smallestRow = (Bridge.Int.div(((-rowCount) | 0), 2)) | 0;
                    biggestRow = (((Bridge.Int.div(rowCount, 2)) | 0) - 1) | 0;
                } else {
                    smallestRow = (Bridge.Int.div(((-(((rowCount - 1) | 0))) | 0), 2)) | 0;
                    biggestRow = (Bridge.Int.div((((rowCount - 1) | 0)), 2)) | 0;
                }

                for (var i = smallestRow; i <= biggestRow; i = (i + 1) | 0) {
                    var newPixel = new PaintingPixelConfig.ctor();
                    newPixel.row = i;
                    newPixel.column = (leftColumn.v - 1) | 0;
                    newPixel.color = new pc.Color( 1, 1, 1, 1 );
                    newPixel.colorCode = PaintingSharedAttributes.DefaultColorKey;
                    newLineLeft.add(newPixel);
                }

                this.PaintingSetup.CurrentPaintingConfig.AdditionPixels.AddRange(newLineLeft);
                this.PaintingSetup.CurrentGridObject.ApplyPaintingConfig(this.PaintingSetup.CurrentPaintingConfig);
            },
            /*PaintingLayoutAdjustModule.AddLineLeft end.*/

            /*PaintingLayoutAdjustModule.AddLineRight start.*/
            AddLineRight: function () {
if ( TRACE ) { TRACE( "PaintingLayoutAdjustModule#AddLineRight", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.PaintingSetup, null) || this.PaintingSetup.CurrentPaintingConfig == null) {
                    return;
                }
                var lowestRow = { };
                var highestRow = { };
                var leftColumn = { };
                var rightColumn = { };
                Bridge.Deconstruct(this.GetBounds().$clone(), lowestRow, highestRow, leftColumn, rightColumn);

                var newLineRight = new (System.Collections.Generic.List$1(PaintingPixelConfig)).ctor();
                var smallestRow = 0;
                var biggestRow = 0;
                var rowCount = Bridge.Int.clip32(this.PaintingSetup.CurrentPaintingConfig.PaintingSize.x);

                if (rowCount % 2 === 0) {
                    smallestRow = (Bridge.Int.div(((-rowCount) | 0), 2)) | 0;
                    biggestRow = (((Bridge.Int.div(rowCount, 2)) | 0) - 1) | 0;
                } else {
                    smallestRow = (Bridge.Int.div(((-(((rowCount - 1) | 0))) | 0), 2)) | 0;
                    biggestRow = (Bridge.Int.div((((rowCount - 1) | 0)), 2)) | 0;
                }

                for (var i = smallestRow; i <= biggestRow; i = (i + 1) | 0) {
                    var newPixel = new PaintingPixelConfig.ctor();
                    newPixel.row = i;
                    newPixel.column = (rightColumn.v + 1) | 0;
                    newPixel.color = new pc.Color( 1, 1, 1, 1 );
                    newPixel.colorCode = PaintingSharedAttributes.DefaultColorKey;
                    newLineRight.add(newPixel);
                }

                this.PaintingSetup.CurrentPaintingConfig.AdditionPixels.AddRange(newLineRight);
                this.PaintingSetup.CurrentGridObject.ApplyPaintingConfig(this.PaintingSetup.CurrentPaintingConfig);
            },
            /*PaintingLayoutAdjustModule.AddLineRight end.*/

            /*PaintingLayoutAdjustModule.AddPixel start.*/
            AddPixel: function (_pos, save) {
if ( TRACE ) { TRACE( "PaintingLayoutAdjustModule#AddPixel", this ); }

                if (save === void 0) { save = true; }
                var respectedPixel = this.PaintingSetup.CurrentGridObject.GetPixelBasedOnPosition(_pos);
                if (UnityEngine.MonoBehaviour.op_Inequality(respectedPixel, null)) {
                    var newPixel = new PaintingPixelConfig.$ctor1(respectedPixel.PixelData);
                    newPixel.Hidden = false;
                    var _c = new pc.Color( 1, 1, 1, 1 );
                    try {
                        _c = this.PaintingSetup.PrefabSource.ColorPallete.GetColorByCode(this.ColorCode);
                    } catch ($e1) {
                        $e1 = System.Exception.create($e1);
                    }

                    newPixel.color = _c.$clone();
                    newPixel.Hidden = false;
                    newPixel.colorCode = this.ColorCode;

                    respectedPixel.gameObject.SetActive(true);
                    respectedPixel.SetColor(_c);
                    respectedPixel.ShowVisualOnly();

                    var pixelConfig = this.PaintingSetup.CurrentPaintingConfig.Pixels.Find(function (p) {
                        return p.row === newPixel.row && p.column === newPixel.column;
                    });
                    if (pixelConfig != null) {
                        this.PaintingSetup.CurrentPaintingConfig.Pixels.remove(pixelConfig);
                    }
                    this.PaintingSetup.CurrentPaintingConfig.Pixels.add(newPixel);

                    this.PaintingSetup.CurrentGridObject.ApplyPaintingConfig(this.PaintingSetup.CurrentPaintingConfig);
                }
            },
            /*PaintingLayoutAdjustModule.AddPixel end.*/

            /*PaintingLayoutAdjustModule.AddPixel$1 start.*/
            AddPixel$1: function (_pos, _colorCode, save) {
if ( TRACE ) { TRACE( "PaintingLayoutAdjustModule#AddPixel$1", this ); }

                if (save === void 0) { save = true; }
                var respectedPixel = this.PaintingSetup.CurrentGridObject.GetPixelBasedOnPositionNewNeeded(_pos.$clone(), this.PaintingSetup.CurrentPaintingConfig, 0.25, true);
                if (UnityEngine.MonoBehaviour.op_Inequality(respectedPixel, null)) {
                    var newPixel = new PaintingPixelConfig.$ctor1(respectedPixel.PixelData);
                    newPixel.Hidden = false;
                    var _c = new pc.Color( 1, 1, 1, 1 );
                    try {
                        _c = this.PaintingSetup.PrefabSource.ColorPallete.GetColorByCode(_colorCode);
                    } catch ($e1) {
                        $e1 = System.Exception.create($e1);
                    }

                    newPixel.color = _c.$clone();
                    newPixel.Hidden = false;
                    newPixel.colorCode = _colorCode;

                    respectedPixel.gameObject.SetActive(true);
                    respectedPixel.SetColor(_c);
                    respectedPixel.ShowVisualOnly();

                    var pixelConfig = this.PaintingSetup.CurrentPaintingConfig.Pixels.Find(function (p) {
                        return p.row === newPixel.row && p.column === newPixel.column;
                    });
                    if (pixelConfig != null) {
                        this.PaintingSetup.CurrentPaintingConfig.Pixels.remove(pixelConfig);
                        this.PaintingSetup.CurrentPaintingConfig.Pixels.add(newPixel);
                    } else {
                        var additionPixelConfig = this.PaintingSetup.CurrentPaintingConfig.AdditionPixels.Find(function (p) {
                            return p.row === newPixel.row && p.column === newPixel.column;
                        });
                        if (additionPixelConfig != null) {
                            this.PaintingSetup.CurrentPaintingConfig.AdditionPixels.remove(additionPixelConfig);
                        }
                        this.PaintingSetup.CurrentPaintingConfig.AdditionPixels.add(newPixel);
                    }

                    this.PaintingSetup.CurrentGridObject.ApplyPaintingConfig(this.PaintingSetup.CurrentPaintingConfig);

                    if (save) {
                        this.Save();
                    }
                }
            },
            /*PaintingLayoutAdjustModule.AddPixel$1 end.*/

            /*PaintingLayoutAdjustModule.HidePixel start.*/
            HidePixel: function (_pos) {
if ( TRACE ) { TRACE( "PaintingLayoutAdjustModule#HidePixel", this ); }

                var respectedPixel = this.PaintingSetup.CurrentGridObject.GetPixelBasedOnPosition(_pos);
                if (UnityEngine.MonoBehaviour.op_Inequality(respectedPixel, null)) {
                    var newPixel = new PaintingPixelConfig.$ctor1(respectedPixel.PixelData);
                    var _c = new pc.Color( 1, 1, 1, 1 );

                    var respectedPixelConfig = this.PaintingSetup.CurrentPaintingConfig.AdditionPixels.Find(function (p) {
                        return p.row === respectedPixel.PixelData.row && p.column === respectedPixel.PixelData.column;
                    });
                    if (respectedPixelConfig == null) {
                        respectedPixelConfig = this.PaintingSetup.CurrentPaintingConfig.Pixels.Find(function (p) {
                            return p.row === respectedPixel.PixelData.row && p.column === respectedPixel.PixelData.column;
                        });
                    }
                    if (respectedPixelConfig != null) {
                        respectedPixelConfig.color = _c.$clone();
                        respectedPixelConfig.Hidden = true;
                        respectedPixelConfig.colorCode = PaintingSharedAttributes.TransparentColorKey;
                    }
                    respectedPixel.HideVisualOnly();
                    respectedPixel.PixelData.colorCode = PaintingSharedAttributes.TransparentColorKey;
                    respectedPixel.SetColor(_c);

                    this.Save();
                }
            },
            /*PaintingLayoutAdjustModule.HidePixel end.*/

            /*PaintingLayoutAdjustModule.SetActivePaintingTool start.*/
            SetActivePaintingTool: function () {
if ( TRACE ) { TRACE( "PaintingLayoutAdjustModule#SetActivePaintingTool", this ); }

                this.IsPaintingToolActive = !this.IsPaintingToolActive;
                if (this.IsPaintingToolActive) {
                    this.IsDeleteToolActive = false;
                }
            },
            /*PaintingLayoutAdjustModule.SetActivePaintingTool end.*/

            /*PaintingLayoutAdjustModule.SetActiveDeleteTool start.*/
            SetActiveDeleteTool: function () {
if ( TRACE ) { TRACE( "PaintingLayoutAdjustModule#SetActiveDeleteTool", this ); }

                this.IsDeleteToolActive = !this.IsDeleteToolActive;
                if (this.IsDeleteToolActive) {
                    this.IsPaintingToolActive = false;
                }
            },
            /*PaintingLayoutAdjustModule.SetActiveDeleteTool end.*/

            /*PaintingLayoutAdjustModule.GetBounds start.*/
            GetBounds: function () {
if ( TRACE ) { TRACE( "PaintingLayoutAdjustModule#GetBounds", this ); }

                var $t;
                if (this.PaintingSetup.CurrentPaintingConfig == null) {
                    return new (System.ValueTuple$4(System.Int32,System.Int32,System.Int32,System.Int32)).$ctor1(0, 0, 0, 0);
                }
                var lowestRow = 2147483647;
                var highestRow = -2147483648;
                var leftColumn = 2147483647;
                var rightColumn = -2147483648;
                $t = Bridge.getEnumerator(this.PaintingSetup.CurrentPaintingConfig.Pixels);
                try {
                    while ($t.moveNext()) {
                        var pixel = $t.Current;
                        if (pixel.row < lowestRow) {
                            lowestRow = pixel.row;
                        }
                        if (pixel.row > highestRow) {
                            highestRow = pixel.row;
                        }
                        if (pixel.column < leftColumn) {
                            leftColumn = pixel.column;
                        }
                        if (pixel.column > rightColumn) {
                            rightColumn = pixel.column;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return new (System.ValueTuple$4(System.Int32,System.Int32,System.Int32,System.Int32)).$ctor1(lowestRow, highestRow, leftColumn, rightColumn);
            },
            /*PaintingLayoutAdjustModule.GetBounds end.*/

            /*PaintingLayoutAdjustModule.GetCurrentColor start.*/
            GetCurrentColor: function () {
if ( TRACE ) { TRACE( "PaintingLayoutAdjustModule#GetCurrentColor", this ); }

                var _c = new pc.Color( 1, 1, 1, 1 );
                try {
                    _c = this.PaintingSetup.PrefabSource.ColorPallete.GetColorByCode(this.ColorCode);
                } catch ($e1) {
                    $e1 = System.Exception.create($e1);
                }
                return _c.$clone();
            },
            /*PaintingLayoutAdjustModule.GetCurrentColor end.*/

            /*PaintingLayoutAdjustModule.Save start.*/
            Save: function () {
if ( TRACE ) { TRACE( "PaintingLayoutAdjustModule#Save", this ); }

                this.PaintingSetup.Save();
            },
            /*PaintingLayoutAdjustModule.Save end.*/


        },
        overloads: {
            "AddPixel(Vector3, string, bool)": "AddPixel$1"
        }
    });
    /*PaintingLayoutAdjustModule end.*/

    /*PaintingPixel start.*/
    Bridge.define("PaintingPixel", {
        fields: {
            name: null,
            column: 0,
            row: 0,
            color: null,
            colorCode: null,
            worldPos: null,
            Hearts: 0,
            destroyed: false,
            pixelObject: null,
            PixelComponent: null,
            Hidden: false,
            VunableToAll: false,
            Indestructible: false,
            IsPipePixel: false,
            IsWallPixel: false,
            UsePaletteMaterialColor: false,
            Material: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "PaintingPixel#init", this ); }

                this.color = new UnityEngine.Color();
                this.worldPos = new UnityEngine.Vector3();
                this.UsePaletteMaterialColor = true;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "PaintingPixel#ctor", this ); }

                this.$initialize();
                this.name = "PaintingPixel";
                this.column = 0;
                this.row = 0;
                this.color = new pc.Color( 1, 1, 1, 1 );
                this.colorCode = "WhiteDefault";
                this.worldPos = pc.Vec3.ZERO.clone();
                this.Hearts = 1;
                this.destroyed = false;
                this.pixelObject = null;
                this.Hidden = false;
                this.VunableToAll = false;
                this.IsPipePixel = false;
                this.IsWallPixel = false;
                this.Indestructible = false;
                this.Material = null;
                this.UsePaletteMaterialColor = true;
            },
            $ctor2: function (column, row, color, worldPos, heart, hidden, pixelObject, material) {
if ( TRACE ) { TRACE( "PaintingPixel#$ctor2", this ); }

                if (pixelObject === void 0) { pixelObject = null; }
                if (material === void 0) { material = null; }

                this.$initialize();
                this.name = System.String.format("Pixel ({0}, {1})", Bridge.box(column, System.Int32), Bridge.box(row, System.Int32));
                this.column = column;
                this.row = row;
                this.color = color.$clone();
                this.colorCode = "WhiteDefault";
                this.worldPos = worldPos.$clone();
                this.Hearts = heart;
                this.destroyed = false;
                this.pixelObject = pixelObject;
                this.Hidden = hidden;
                this.VunableToAll = false;
                this.Material = material; // Gn sharedMaterial  y
                this.UsePaletteMaterialColor = true;
            },
            $ctor1: function (config, initialMaterial) {
if ( TRACE ) { TRACE( "PaintingPixel#$ctor1", this ); }

                if (initialMaterial === void 0) { initialMaterial = null; }

                this.$initialize();
                this.name = System.String.format("Pixel ({0}, {1})", Bridge.box(config.column, System.Int32), Bridge.box(config.row, System.Int32));
                this.column = config.column;
                this.row = config.row;
                this.color = config.color.$clone();
                this.colorCode = config.colorCode;
                this.worldPos = pc.Vec3.ZERO.clone();
                this.Hearts = 1;
                this.destroyed = false;
                this.pixelObject = null;
                this.Hidden = config.Hidden;
                this.VunableToAll = false;
                this.Material = initialMaterial; // Gn sharedMaterial khi to pixel
                this.UsePaletteMaterialColor = true;
            }
        },
        methods: {
            /*PaintingPixel.SetUp start.*/
            SetUp: function (color, colorCode, hidden) {
if ( TRACE ) { TRACE( "PaintingPixel#SetUp", this ); }

                this.color = color.$clone();
                this.Hidden = hidden;
                this.destroyed = false;
                this.colorCode = colorCode;
                this.VunableToAll = false;

                // Ensure PixelComponent is set up with the updated data
                UnityEngine.MonoBehaviour.op_Inequality(this.PixelComponent, null) ? this.PixelComponent.SetUp(this) : null;

                if (this.Hidden) {
                    this.destroyed = true;
                    this.pixelObject.SetActive(false);
                } else {
                    UnityEngine.MonoBehaviour.op_Inequality(this.PixelComponent, null) ? this.PixelComponent.ApplyVisual() : null;
                }
            },
            /*PaintingPixel.SetUp end.*/

            /*PaintingPixel.SetPosition start.*/
            SetPosition: function (newPos) {
if ( TRACE ) { TRACE( "PaintingPixel#SetPosition", this ); }

                this.worldPos = newPos.$clone();
            },
            /*PaintingPixel.SetPosition end.*/

            /*PaintingPixel.DestroyPixel start.*/
            DestroyPixel: function (invokeEvent, collectorObject) {
if ( TRACE ) { TRACE( "PaintingPixel#DestroyPixel", this ); }

                if (invokeEvent === void 0) { invokeEvent = true; }
                if (collectorObject === void 0) { collectorObject = null; }
                this.destroyed = true;
                UnityEngine.MonoBehaviour.op_Inequality(this.PixelComponent, null) ? this.PixelComponent.Destroyed$1() : null;
                if (invokeEvent) {
                    if (UnityEngine.MonoBehaviour.op_Inequality(collectorObject, null)) {
                        !Bridge.staticEquals(GameplayEventsManager.OnAPixelDestroyedByCollector, null) ? GameplayEventsManager.OnAPixelDestroyedByCollector(this, collectorObject) : null;
                    } else {
                        !Bridge.staticEquals(GameplayEventsManager.OnAPixelDestroyed, null) ? GameplayEventsManager.OnAPixelDestroyed(this) : null;
                    }
                }
            },
            /*PaintingPixel.DestroyPixel end.*/

            /*PaintingPixel.DestroyObject start.*/
            DestroyObject: function () {
if ( TRACE ) { TRACE( "PaintingPixel#DestroyObject", this ); }

                this.destroyed = true;
                if (UnityEngine.GameObject.op_Inequality(this.pixelObject, null)) {
                    if (UnityEngine.Application.isPlaying) {
                        UnityEngine.Object.Destroy(this.pixelObject);
                    } else {
                        UnityEngine.Object.DestroyImmediate(this.pixelObject);
                    }
                }
            },
            /*PaintingPixel.DestroyObject end.*/

            /*PaintingPixel.ShowPixelObject start.*/
            ShowPixelObject: function () {
if ( TRACE ) { TRACE( "PaintingPixel#ShowPixelObject", this ); }

                UnityEngine.GameObject.op_Inequality(this.pixelObject, null) ? this.pixelObject.SetActive(true) : null;
                this.PixelComponent.ShowVisualOnly();
            },
            /*PaintingPixel.ShowPixelObject end.*/

            /*PaintingPixel.InCount start.*/
            InCount: function () {
if ( TRACE ) { TRACE( "PaintingPixel#InCount", this ); }

                return !this.destroyed && (!this.Hidden || this.IsWallPixel || this.IsPipePixel || this.Indestructible);
            },
            /*PaintingPixel.InCount end.*/

            /*PaintingPixel.IsCompleteHidden start.*/
            IsCompleteHidden: function () {
if ( TRACE ) { TRACE( "PaintingPixel#IsCompleteHidden", this ); }

                return this.destroyed || this.Hidden || this.IsWallPixel || this.IsPipePixel || this.Indestructible;
            },
            /*PaintingPixel.IsCompleteHidden end.*/


        }
    });
    /*PaintingPixel end.*/

    /*PaintingPixelComponent start.*/
    Bridge.define("PaintingPixelComponent", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                _logMissingOnce: false
            }
        },
        fields: {
            CubeTransform: null,
            PixelData: null,
            CubeRenderer: null,
            CurrentHearts: 0,
            EffectOptions: null,
            shakeLoops: 0,
            shakeDuration: 0,
            pumpTween: null,
            shakeTween: null,
            initScale: null,
            UseLazyTweens: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "PaintingPixelComponent#init", this ); }

                this.initScale = new UnityEngine.Vector3();
                this.shakeLoops = 5;
                this.shakeDuration = 0.1;
                this.UseLazyTweens = true;
            }
        },
        methods: {
            /*PaintingPixelComponent.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "PaintingPixelComponent#Awake", this ); }

                this.initScale = this.transform.localScale.$clone();
            },
            /*PaintingPixelComponent.Awake end.*/

            /*PaintingPixelComponent.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "PaintingPixelComponent#OnEnable", this ); }

                this.transform.localScale = this.initScale.$clone();
            },
            /*PaintingPixelComponent.OnEnable end.*/

            /*PaintingPixelComponent.SetRendererMaterial start.*/
            SetRendererMaterial: function () {
if ( TRACE ) { TRACE( "PaintingPixelComponent#SetRendererMaterial", this ); }

                if (UnityEngine.Component.op_Equality(this.CubeRenderer, null)) {
                    return;
                }
                var target = (this.PixelData != null ? this.PixelData.Material : null) || PixelMaterialFallbackProvider.GlobalFallback;
                if (target == null) {
                    this.CubeRenderer.enabled = false;
                    if (!PaintingPixelComponent._logMissingOnce) {
                        UnityEngine.Debug.LogError$2(System.String.format("[PaintingPixelComponent] Missing material for pixel ({0},{1}). Renderer disabled.", Bridge.box(this.PixelData != null ? this.PixelData.column : null, System.Int32, System.Nullable.toString, System.Nullable.getHashCode), Bridge.box(this.PixelData != null ? this.PixelData.row : null, System.Int32, System.Nullable.toString, System.Nullable.getHashCode)), this);
                        PaintingPixelComponent._logMissingOnce = true;
                    }
                    return;
                }
                this.CubeRenderer.sharedMaterial = target; // single assignment (shared asset from SO)
            },
            /*PaintingPixelComponent.SetRendererMaterial end.*/

            /*PaintingPixelComponent.ApplyColorOverride start.*/
            ApplyColorOverride: function () {
if ( TRACE ) { TRACE( "PaintingPixelComponent#ApplyColorOverride", this ); }

                if (UnityEngine.Component.op_Equality(this.CubeRenderer, null) || this.PixelData == null) {
                    return;
                }

                // Kim tra xem c cn override color khng
                if (this.PixelData.UsePaletteMaterialColor && this.PixelData.Material != null) {
                    // So snh color hin ti vi material color
                    var needsOverride = !this.ColorEqual(this.PixelData.Material.color, this.PixelData.color, 0.01);

                    if (needsOverride) {
                        // S dng MaterialPropertyBlock thay v clone material
                        var propertyBlock = new UnityEngine.MaterialPropertyBlock();
                        propertyBlock.SetColor$1("_Color", this.PixelData.color);
                        this.CubeRenderer.SetPropertyBlock(propertyBlock);
                    } else {
                        // Khng cn override, clear property block bng cch set thnh null
                        var propertyBlock1 = new UnityEngine.MaterialPropertyBlock();
                        this.CubeRenderer.SetPropertyBlock(propertyBlock1);
                    }
                }
            },
            /*PaintingPixelComponent.ApplyColorOverride end.*/

            /*PaintingPixelComponent.ColorEqual start.*/
            ColorEqual: function (a, b, tolerance) {
if ( TRACE ) { TRACE( "PaintingPixelComponent#ColorEqual", this ); }

                if (tolerance === void 0) { tolerance = 0.001; }
                return Math.abs(a.r - b.r) <= tolerance && Math.abs(a.g - b.g) <= tolerance && Math.abs(a.b - b.b) <= tolerance && Math.abs(a.a - b.a) <= tolerance;
            },
            /*PaintingPixelComponent.ColorEqual end.*/

            /*PaintingPixelComponent.SetUp start.*/
            SetUp: function (newPixel) {
if ( TRACE ) { TRACE( "PaintingPixelComponent#SetUp", this ); }

                this.CubeTransform = this.transform;
                newPixel.PixelComponent = this;
                this.PixelData = newPixel;
                this.CurrentHearts = this.PixelData.Hearts;
                this.SetRendererMaterial();
                if (!this.UseLazyTweens) {
                    this.CreateShakeTween();
                    this.CreatePumpTween();
                }
                this.ApplyVisual();
            },
            /*PaintingPixelComponent.SetUp end.*/

            /*PaintingPixelComponent.ApplyVisual start.*/
            ApplyVisual: function () {
if ( TRACE ) { TRACE( "PaintingPixelComponent#ApplyVisual", this ); }

                if (this.PixelData == null || UnityEngine.Component.op_Equality(this.CubeRenderer, null)) {
                    return;
                }
                this.CubeRenderer.enabled = !this.PixelData.Hidden;
                if (!this.PixelData.Hidden) {
                    if (this.PixelData.UsePaletteMaterialColor) {
                        this.ApplyColorOverride(); // S dng MaterialPropertyBlock
                    } else {
                        this.SetColor(this.PixelData.color); // Legacy method for non-palette colors
                    }
                }
            },
            /*PaintingPixelComponent.ApplyVisual end.*/

            /*PaintingPixelComponent.SetColor start.*/
            SetColor: function (color) {
if ( TRACE ) { TRACE( "PaintingPixelComponent#SetColor", this ); }

                if (UnityEngine.Component.op_Equality(this.CubeRenderer, null)) {
                    return;
                }
                if (this.PixelData == null) {
                    return;
                }

                this.PixelData.color = color.$clone(); // Always store the logical color

                if (this.PixelData.UsePaletteMaterialColor) {
                    // Use MaterialPropertyBlock for palette materials (no cloning)
                    var propertyBlock = new UnityEngine.MaterialPropertyBlock();
                    propertyBlock.SetColor$1("_Color", color);
                    this.CubeRenderer.SetPropertyBlock(propertyBlock);
                } else {
                    // Legacy method: direct material color assignment
                    if (this.CubeRenderer.sharedMaterial != null) {
                        this.CubeRenderer.sharedMaterial.color = color.$clone();
                    }
                }
            },
            /*PaintingPixelComponent.SetColor end.*/

            /*PaintingPixelComponent.ClearColorOverride start.*/
            ClearColorOverride: function () {
if ( TRACE ) { TRACE( "PaintingPixelComponent#ClearColorOverride", this ); }

                if (UnityEngine.Component.op_Equality(this.CubeRenderer, null)) {
                    return;
                }
                // Clear MaterialPropertyBlock bng cch set property block rng
                var propertyBlock = new UnityEngine.MaterialPropertyBlock();
                this.CubeRenderer.SetPropertyBlock(propertyBlock);
            },
            /*PaintingPixelComponent.ClearColorOverride end.*/

            /*PaintingPixelComponent.IsDestroyed start.*/
            IsDestroyed: function () {
if ( TRACE ) { TRACE( "PaintingPixelComponent#IsDestroyed", this ); }

                return this.PixelData != null && this.PixelData.destroyed;
            },
            /*PaintingPixelComponent.IsDestroyed end.*/

            /*PaintingPixelComponent.Destroyed$1 start.*/
            Destroyed$1: function () {
if ( TRACE ) { TRACE( "PaintingPixelComponent#Destroyed$1", this ); }

                if (this.PixelData != null) {
                    this.PixelData.destroyed = true;
                }
            },
            /*PaintingPixelComponent.Destroyed$1 end.*/

            /*PaintingPixelComponent.ApplyPosition start.*/
            ApplyPosition: function () {
if ( TRACE ) { TRACE( "PaintingPixelComponent#ApplyPosition", this ); }

                if (this.PixelData != null) {
                    this.transform.localPosition = this.PixelData.worldPos.$clone();
                }
            },
            /*PaintingPixelComponent.ApplyPosition end.*/

            /*PaintingPixelComponent.ShowVisualOnly start.*/
            ShowVisualOnly: function () {
if ( TRACE ) { TRACE( "PaintingPixelComponent#ShowVisualOnly", this ); }

                if (UnityEngine.Object.op_Implicit(this.CubeRenderer)) {
                    this.CubeRenderer.enabled = true;
                }
            },
            /*PaintingPixelComponent.ShowVisualOnly end.*/

            /*PaintingPixelComponent.HideVisualOnly start.*/
            HideVisualOnly: function () {
if ( TRACE ) { TRACE( "PaintingPixelComponent#HideVisualOnly", this ); }

                if (UnityEngine.Object.op_Implicit(this.CubeRenderer)) {
                    this.CubeRenderer.enabled = false;
                }
            },
            /*PaintingPixelComponent.HideVisualOnly end.*/

            /*PaintingPixelComponent.GetWorldPosition start.*/
            GetWorldPosition: function () {
if ( TRACE ) { TRACE( "PaintingPixelComponent#GetWorldPosition", this ); }

                return this.PixelData != null ? this.PixelData.worldPos.$clone() : this.transform.position.$clone();
            },
            /*PaintingPixelComponent.GetWorldPosition end.*/

            /*PaintingPixelComponent.DestroyPixelVisually start.*/
            DestroyPixelVisually: function () {
if ( TRACE ) { TRACE( "PaintingPixelComponent#DestroyPixelVisually", this ); }

                this.PlayPumpAndDisable();
            },
            /*PaintingPixelComponent.DestroyPixelVisually end.*/

            /*PaintingPixelComponent.SelfDestroy start.*/
            SelfDestroy: function () {
if ( TRACE ) { TRACE( "PaintingPixelComponent#SelfDestroy", this ); }

                if (UnityEngine.Application.isPlaying) {
                    UnityEngine.MonoBehaviour.Destroy(this.gameObject);
                } else {
                    UnityEngine.Object.DestroyImmediate(this.gameObject);
                }
            },
            /*PaintingPixelComponent.SelfDestroy end.*/

            /*PaintingPixelComponent.CreatePumpTween start.*/
            CreatePumpTween: function () {
if ( TRACE ) { TRACE( "PaintingPixelComponent#CreatePumpTween", this ); }

                if (this.pumpTween != null) {
                    return;
                }
                this.pumpTween = DG.Tweening.TweenSettingsExtensions.SetAutoKill$1(DG.Tweening.Sequence, DG.Tweening.TweenExtensions.Pause(DG.Tweening.Sequence, DG.Tweening.DOTween.Sequence()), false);
                var upScale = this.CubeTransform.localScale.$clone().clone().scale( 1.5 );
                DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Append(DG.Tweening.TweenSettingsExtensions.Append(this.pumpTween, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.CubeTransform, upScale.$clone(), 0.05), DG.Tweening.Ease.InBack)), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.CubeTransform, pc.Vec3.ZERO.clone(), 0.2), DG.Tweening.Ease.InBack)), Bridge.fn.bind(this, function () {
                    this.gameObject.SetActive(false);
                    this.CubeTransform.localScale = new pc.Vec3( 1, 1, 1 );
                }));
            },
            /*PaintingPixelComponent.CreatePumpTween end.*/

            /*PaintingPixelComponent.PlayPumpAndDisable start.*/
            PlayPumpAndDisable: function () {
if ( TRACE ) { TRACE( "PaintingPixelComponent#PlayPumpAndDisable", this ); }

                if (this.UseLazyTweens && this.pumpTween == null) {
                    this.CreatePumpTween();
                }
                !Bridge.staticEquals(GameplayEventsManager.OnBlockDissapear, null) ? GameplayEventsManager.OnBlockDissapear() : null;
                this.gameObject.SetActive(true);
                DG.Tweening.TweenExtensions.Restart(this.pumpTween);
            },
            /*PaintingPixelComponent.PlayPumpAndDisable end.*/

            /*PaintingPixelComponent.CreateShakeTween start.*/
            CreateShakeTween: function () {
if ( TRACE ) { TRACE( "PaintingPixelComponent#CreateShakeTween", this ); }

                if (this.EffectOptions == null || this.shakeTween != null) {
                    return;
                }
                var startRot = this.CubeTransform.localEulerAngles.$clone();
                this.shakeTween = DG.Tweening.TweenExtensions.Pause(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetAutoKill$1(DG.Tweening.Sequence, DG.Tweening.DOTween.Sequence(), false));
                for (var i = 0; i < this.shakeLoops; i = (i + 1) | 0) {
                    var randomRot = startRot.$clone().add( UnityEngine.Random.insideUnitSphere.$clone().clone().scale( this.EffectOptions.ShakeValue ) );
                    DG.Tweening.TweenSettingsExtensions.Append(this.shakeTween, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.ShortcutExtensions.DOLocalRotate(this.CubeTransform, randomRot.$clone(), this.shakeDuration * 0.5), DG.Tweening.Ease.OutQuad));
                    DG.Tweening.TweenSettingsExtensions.Append(this.shakeTween, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.ShortcutExtensions.DOLocalRotate(this.CubeTransform, startRot.$clone(), this.shakeDuration * 0.5), DG.Tweening.Ease.InOutQuad));
                }
                DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Sequence, this.shakeTween, Bridge.fn.bind(this, function () {
                    this.CubeTransform.localRotation = pc.Quat.IDENTITY.clone();
                }));
            },
            /*PaintingPixelComponent.CreateShakeTween end.*/

            /*PaintingPixelComponent.PlayShake start.*/
            PlayShake: function () {
if ( TRACE ) { TRACE( "PaintingPixelComponent#PlayShake", this ); }

                if (this.EffectOptions == null) {
                    return;
                }
                if (this.UseLazyTweens && this.shakeTween == null) {
                    this.CreateShakeTween();
                }
                if (this.EffectOptions.ShakeNeighborBlocks) {
                    DG.Tweening.TweenExtensions.Restart(this.shakeTween);
                }
            },
            /*PaintingPixelComponent.PlayShake end.*/

            /*PaintingPixelComponent.StopShake start.*/
            StopShake: function () {
if ( TRACE ) { TRACE( "PaintingPixelComponent#StopShake", this ); }

                this.shakeTween != null ? DG.Tweening.TweenExtensions.Pause(DG.Tweening.Sequence, this.shakeTween) : null;
                this.CubeTransform.localRotation = pc.Quat.IDENTITY.clone();
            },
            /*PaintingPixelComponent.StopShake end.*/

            /*PaintingPixelComponent.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "PaintingPixelComponent#OnDisable", this ); }

                this.pumpTween != null ? DG.Tweening.TweenExtensions.Kill(this.pumpTween, false) : null;
                this.pumpTween = null;
                this.shakeTween != null ? DG.Tweening.TweenExtensions.Kill(this.shakeTween, false) : null;
                this.shakeTween = null;
            },
            /*PaintingPixelComponent.OnDisable end.*/


        },
        overloads: {
            "Destroyed()": "Destroyed$1"
        }
    });
    /*PaintingPixelComponent end.*/

    /*PaintingPixelConfig start.*/
    Bridge.define("PaintingPixelConfig", {
        fields: {
            column: 0,
            row: 0,
            color: null,
            colorCode: null,
            Hidden: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "PaintingPixelConfig#init", this ); }

                this.color = new UnityEngine.Color();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "PaintingPixelConfig#ctor", this ); }

                this.$initialize();
            },
            $ctor2: function (_stock) {
if ( TRACE ) { TRACE( "PaintingPixelConfig#$ctor2", this ); }

                this.$initialize();
                this.column = _stock.column;
                this.row = _stock.row;
                this.color = _stock.color.$clone();
                this.colorCode = _stock.colorCode;
                this.Hidden = _stock.Hidden;
            },
            $ctor1: function (_pixelObj) {
if ( TRACE ) { TRACE( "PaintingPixelConfig#$ctor1", this ); }

                this.$initialize();
                this.column = _pixelObj.column;
                this.row = _pixelObj.row;
                this.color = _pixelObj.color.$clone();
                this.colorCode = _pixelObj.colorCode;
                this.Hidden = _pixelObj.Hidden;
            }
        }
    });
    /*PaintingPixelConfig end.*/

    /*PaintingSharedAttributes start.*/
    Bridge.define("PaintingSharedAttributes", {
        statics: {
            fields: {
                LockKeyColorDefine: null,
                DefaultColorKey: null,
                TransparentColorKey: null,
                LevelConfigPath: null,
                CollectorsConfigPath: null,
                PaintingConfigPath: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "PaintingSharedAttributes#init", this ); }

                    this.LockKeyColorDefine = "KeyColor";
                    this.DefaultColorKey = "DefaultColor";
                    this.TransparentColorKey = "TransparentColor";
                    this.LevelConfigPath = "Assets/_Game/Data/LevelConfig/";
                    this.CollectorsConfigPath = "Assets/_Game/Data/GunnerConfig/";
                    this.PaintingConfigPath = "Assets/_Game/Data/PaintingConfig/";
                }
            },
            methods: {
                /*PaintingSharedAttributes.MoveRelative:static start.*/
                MoveRelative: function (T, list, itemToMove, targetItem, higher) {
if ( TRACE ) { TRACE( "PaintingSharedAttributes#MoveRelative", this ); }

                    if (list == null || Bridge.rValue(itemToMove) == null || Bridge.rValue(targetItem) == null) {
                        return;
                    }

                    // Nu 2 phn t ging nhau th khng lm g
                    if (System.Collections.Generic.EqualityComparer$1(T).def.equals2(Bridge.rValue(itemToMove), Bridge.rValue(targetItem))) {
                        return;
                    }

                    // Ly index hin ti ca item v target
                    var currentIndex = list.indexOf(Bridge.rValue(itemToMove));
                    var targetIndex = list.indexOf(Bridge.rValue(targetItem));

                    // Nu khng tm thy mt trong hai th b qua
                    if (currentIndex === -1 || targetIndex === -1) {
                        return;
                    }

                    // B item ra khi list
                    list.removeAt(currentIndex);

                    // Nu item nm TRC target ban u, th index ca target  thay i sau khi Remove
                    if (currentIndex < targetIndex) {
                        targetIndex = (targetIndex - 1) | 0;
                    }

                    // Tnh index mi  chn vo
                    var newIndex = higher ? targetIndex : ((targetIndex + 1) | 0);

                    // Gii hn index trong phm vi hp l
                    newIndex = Math.max(0, Math.min(newIndex, list.Count));

                    // Chn li item
                    list.insert(newIndex, Bridge.rValue(itemToMove));
                },
                /*PaintingSharedAttributes.MoveRelative:static end.*/

                /*PaintingSharedAttributes.InsertRelative:static start.*/
                InsertRelative: function (T, list, newItem, targetItem, higher) {
if ( TRACE ) { TRACE( "PaintingSharedAttributes#InsertRelative", this ); }

                    if (list == null || Bridge.rValue(newItem) == null || Bridge.rValue(targetItem) == null) {
                        return;
                    }

                    var targetIndex = list.indexOf(Bridge.rValue(targetItem));
                    if (targetIndex === -1) {
                        // Nu targetItem khng c trong list, thm vo cui danh sch
                        list.add(Bridge.rValue(newItem));
                        return;
                    }

                    var insertIndex = higher ? targetIndex : ((targetIndex + 1) | 0);
                    insertIndex = Math.max(0, Math.min(insertIndex, list.Count));

                    list.insert(insertIndex, Bridge.rValue(newItem));
                },
                /*PaintingSharedAttributes.InsertRelative:static end.*/

                /*PaintingSharedAttributes.GetCollectorConfigByID:static start.*/
                GetCollectorConfigByID: function (_list, ID) {
if ( TRACE ) { TRACE( "PaintingSharedAttributes#GetCollectorConfigByID", this ); }

                    for (var i = 0; i < _list.Count; i = (i + 1) | 0) {
                        if (_list.getItem(i).ID === ID) {
                            return _list.getItem(i);
                        }
                    }
                    return null;
                },
                /*PaintingSharedAttributes.GetCollectorConfigByID:static end.*/

                /*PaintingSharedAttributes.Shuffle:static start.*/
                Shuffle: function (T, list) {
if ( TRACE ) { TRACE( "PaintingSharedAttributes#Shuffle", this ); }

                    for (var i = (System.Array.getCount(list, T) - 1) | 0; i > 0; i = (i - 1) | 0) {
                        var j = UnityEngine.Random.Range(0, ((i + 1) | 0));
                        Bridge.Deconstruct(new (System.ValueTuple$2(T,T)).$ctor1(Bridge.rValue(System.Array.getItem(list, j, T)), Bridge.rValue(System.Array.getItem(list, i, T))).$clone(), Bridge.ref(Bridge.rValue(System.Array.getItem(list, i, T))), Bridge.ref(Bridge.rValue(System.Array.getItem(list, j, T))));
                    }
                },
                /*PaintingSharedAttributes.Shuffle:static end.*/


            }
        }
    });
    /*PaintingSharedAttributes end.*/

    /*PaintingSharedAttributes+ColorPixelListPair start.*/
    Bridge.define("PaintingSharedAttributes.ColorPixelListPair", {
        $kind: 1002,
        fields: {
            ColorCode: null,
            pixels: null
        },
        ctors: {
            ctor: function (colorCode, pixels) {
if ( TRACE ) { TRACE( "PaintingSharedAttributes.ColorPixelListPair#ctor", this ); }

                this.$initialize();
                this.ColorCode = colorCode;
                this.pixels = pixels;
            }
        }
    });
    /*PaintingSharedAttributes+ColorPixelListPair end.*/

    /*PaintingSharedAttributes+IntPixelListPair start.*/
    Bridge.define("PaintingSharedAttributes.IntPixelListPair", {
        $kind: 1002,
        fields: {
            key: 0,
            pixels: null
        },
        ctors: {
            ctor: function (key, pixels) {
if ( TRACE ) { TRACE( "PaintingSharedAttributes.IntPixelListPair#ctor", this ); }

                this.$initialize();
                this.key = key;
                this.pixels = pixels;
            }
        }
    });
    /*PaintingSharedAttributes+IntPixelListPair end.*/

    /*PathTransformBasedCached start.*/
    Bridge.define("PathTransformBasedCached", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                Instance: null
            }
        },
        fields: {
            PathPoints: null,
            cumulativeDistances: null,
            isDistanceCacheDirty: false,
            totalDistance: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "PathTransformBasedCached#init", this ); }

                this.PathPoints = new (System.Collections.Generic.List$1(UnityEngine.Transform)).ctor();
                this.cumulativeDistances = new (System.Collections.Generic.List$1(System.Single)).ctor();
                this.isDistanceCacheDirty = false;
            }
        },
        methods: {
            /*PathTransformBasedCached.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "PathTransformBasedCached#Awake", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(PathTransformBasedCached.Instance, null) && UnityEngine.MonoBehaviour.op_Inequality(PathTransformBasedCached.Instance, this)) {
                    UnityEngine.MonoBehaviour.Destroy(this.gameObject);
                    return;
                }
                PathTransformBasedCached.Instance = this;
            },
            /*PathTransformBasedCached.Awake end.*/

            /*PathTransformBasedCached.IsValid start.*/
            IsValid: function () {
if ( TRACE ) { TRACE( "PathTransformBasedCached#IsValid", this ); }

                // Check if the path transforms count has changed, which means cache should be refreshed
                if (this.PathPoints != null && this.cumulativeDistances != null) {
                    if (this.PathPoints.Count !== this.cumulativeDistances.Count) {
                        this.isDistanceCacheDirty = true;
                    }
                }

                return this.PathPoints != null && this.PathPoints.Count > 0;
            },
            /*PathTransformBasedCached.IsValid end.*/

            /*PathTransformBasedCached.GetPositionAtTF start.*/
            GetPositionAtTF: function (tf) {
if ( TRACE ) { TRACE( "PathTransformBasedCached#GetPositionAtTF", this ); }

                if (!this.IsValid() || this.PathPoints.Count < 2) {
                    return pc.Vec3.ZERO.clone();
                }

                tf = Math.max(0, Math.min(1, tf));

                // Convert TF to true position using arc-length parameterization
                var truePosition = this.GetTrueTfFromNormalizedTf(tf);

                // Find the two closest transforms
                var index1 = Math.floor(truePosition);
                var index2 = UnityEngine.Mathf.Min(((index1 + 1) | 0), ((this.PathPoints.Count - 1) | 0));

                var lerpFactor = (truePosition - index1);

                var pos1 = this.GetTransformPosition(this.PathPoints.getItem(index1));
                var pos2 = this.GetTransformPosition(this.PathPoints.getItem(index2));

                return new pc.Vec3().lerp( pos1, pos2, lerpFactor );
            },
            /*PathTransformBasedCached.GetPositionAtTF end.*/

            /*PathTransformBasedCached.GetTangentAtTF start.*/
            GetTangentAtTF: function (tf) {
if ( TRACE ) { TRACE( "PathTransformBasedCached#GetTangentAtTF", this ); }

                if (!this.IsValid() || this.PathPoints.Count < 2) {
                    return new pc.Vec3( 0, 0, 1 );
                }

                tf = Math.max(0, Math.min(1, tf));

                // Convert TF to true position using arc-length parameterization
                var truePosition = this.GetTrueTfFromNormalizedTf(tf);

                // Find the two closest transforms
                var index1 = Math.floor(truePosition);
                var index2 = UnityEngine.Mathf.Min(((index1 + 1) | 0), ((this.PathPoints.Count - 1) | 0));

                var pos1 = this.GetTransformPosition(this.PathPoints.getItem(index1));
                var pos2 = this.GetTransformPosition(this.PathPoints.getItem(index2));

                var tangent = (pos2.$clone().sub( pos1 )).clone().normalize().$clone();

                return !pc.Vec3.equals( tangent, pc.Vec3.ZERO.clone() ) ? tangent.$clone() : new pc.Vec3( 0, 0, 1 );
            },
            /*PathTransformBasedCached.GetTangentAtTF end.*/

            /*PathTransformBasedCached.GetUpVectorAtTF start.*/
            GetUpVectorAtTF: function (tf) {
if ( TRACE ) { TRACE( "PathTransformBasedCached#GetUpVectorAtTF", this ); }

                if (!this.IsValid() || this.PathPoints.Count < 2) {
                    return pc.Vec3.UP.clone();
                }

                tf = Math.max(0, Math.min(1, tf));

                // Convert TF to true position using arc-length parameterization
                var truePosition = this.GetTrueTfFromNormalizedTf(tf);

                // Find the two closest transforms
                var index1 = Math.floor(truePosition);
                var index2 = UnityEngine.Mathf.Min(((index1 + 1) | 0), ((this.PathPoints.Count - 1) | 0));

                var lerpFactor = (truePosition - index1);

                var up1 = this.GetTransformUpVector(this.PathPoints.getItem(index1));
                var up2 = this.GetTransformUpVector(this.PathPoints.getItem(index2));

                var upVector = new pc.Vec3().lerp( up1, up2, lerpFactor );

                return !pc.Vec3.equals( upVector, pc.Vec3.ZERO.clone() ) ? upVector.clone().normalize().$clone() : pc.Vec3.UP.clone();
            },
            /*PathTransformBasedCached.GetUpVectorAtTF end.*/

            /*PathTransformBasedCached.GetPositionAtDistance start.*/
            GetPositionAtDistance: function (distance) {
if ( TRACE ) { TRACE( "PathTransformBasedCached#GetPositionAtDistance", this ); }

                if (!this.IsValid() || this.totalDistance <= 0) {
                    return pc.Vec3.ZERO.clone();
                }

                var tf = Math.max(0, Math.min(1, distance / this.totalDistance));
                return this.GetPositionAtTF(tf);
            },
            /*PathTransformBasedCached.GetPositionAtDistance end.*/

            /*PathTransformBasedCached.GetTangentAtDistance start.*/
            GetTangentAtDistance: function (distance) {
if ( TRACE ) { TRACE( "PathTransformBasedCached#GetTangentAtDistance", this ); }

                if (!this.IsValid() || this.totalDistance <= 0) {
                    return new pc.Vec3( 0, 0, 1 );
                }

                var tf = Math.max(0, Math.min(1, distance / this.totalDistance));
                return this.GetTangentAtTF(tf);
            },
            /*PathTransformBasedCached.GetTangentAtDistance end.*/

            /*PathTransformBasedCached.GetUpVectorAtDistance start.*/
            GetUpVectorAtDistance: function (distance) {
if ( TRACE ) { TRACE( "PathTransformBasedCached#GetUpVectorAtDistance", this ); }

                if (!this.IsValid() || this.totalDistance <= 0) {
                    return pc.Vec3.UP.clone();
                }

                var tf = Math.max(0, Math.min(1, distance / this.totalDistance));
                return this.GetUpVectorAtTF(tf);
            },
            /*PathTransformBasedCached.GetUpVectorAtDistance end.*/

            /*PathTransformBasedCached.GetTransformPosition start.*/
            GetTransformPosition: function (t) {
if ( TRACE ) { TRACE( "PathTransformBasedCached#GetTransformPosition", this ); }

                if (UnityEngine.Component.op_Equality(t, null)) {
                    return pc.Vec3.ZERO.clone();
                }
                return t.position.$clone();
            },
            /*PathTransformBasedCached.GetTransformPosition end.*/

            /*PathTransformBasedCached.GetTransformUpVector start.*/
            GetTransformUpVector: function (t) {
if ( TRACE ) { TRACE( "PathTransformBasedCached#GetTransformUpVector", this ); }

                if (UnityEngine.Component.op_Equality(t, null)) {
                    return pc.Vec3.UP.clone();
                }
                return t.up.$clone();
            },
            /*PathTransformBasedCached.GetTransformUpVector end.*/

            /*PathTransformBasedCached.GetTransformForwardVector start.*/
            GetTransformForwardVector: function (t) {
if ( TRACE ) { TRACE( "PathTransformBasedCached#GetTransformForwardVector", this ); }

                if (UnityEngine.Component.op_Equality(t, null)) {
                    return new pc.Vec3( 0, 0, 1 );
                }
                return t.forward.$clone();
            },
            /*PathTransformBasedCached.GetTransformForwardVector end.*/

            /*PathTransformBasedCached.MarkDistanceCacheDirty start.*/
            MarkDistanceCacheDirty: function () {
if ( TRACE ) { TRACE( "PathTransformBasedCached#MarkDistanceCacheDirty", this ); }

                this.isDistanceCacheDirty = true;
            },
            /*PathTransformBasedCached.MarkDistanceCacheDirty end.*/

            /*PathTransformBasedCached.CalculateTotalDistance start.*/
            CalculateTotalDistance: function () {
if ( TRACE ) { TRACE( "PathTransformBasedCached#CalculateTotalDistance", this ); }

                if (!this.IsValid() || this.PathPoints.Count < 2) {
                    return 0.0;
                }

                var distance = 0.0;
                for (var i = 1; i < this.PathPoints.Count; i = (i + 1) | 0) {
                    if (UnityEngine.Component.op_Inequality(this.PathPoints.getItem(i), null) && UnityEngine.Component.op_Inequality(this.PathPoints.getItem(((i - 1) | 0)), null)) {
                        distance += pc.Vec3.distance( this.GetTransformPosition(this.PathPoints.getItem(((i - 1) | 0))), this.GetTransformPosition(this.PathPoints.getItem(i)) );
                    }
                }

                return distance;
            },
            /*PathTransformBasedCached.CalculateTotalDistance end.*/

            /*PathTransformBasedCached.CalculateCumulativeDistances start.*/
            CalculateCumulativeDistances: function () {
if ( TRACE ) { TRACE( "PathTransformBasedCached#CalculateCumulativeDistances", this ); }

                if (!this.IsValid() || this.PathPoints.Count < 2) {
                    this.cumulativeDistances = null;
                    return;
                }

                this.cumulativeDistances = new (System.Collections.Generic.List$1(System.Single)).ctor();
                this.cumulativeDistances.add(0.0); // Start at 0

                var cumulativeDistance = 0.0;
                for (var i = 1; i < this.PathPoints.Count; i = (i + 1) | 0) {
                    if (UnityEngine.Component.op_Inequality(this.PathPoints.getItem(i), null) && UnityEngine.Component.op_Inequality(this.PathPoints.getItem(((i - 1) | 0)), null)) {
                        var segmentDistance = pc.Vec3.distance( this.GetTransformPosition(this.PathPoints.getItem(((i - 1) | 0))), this.GetTransformPosition(this.PathPoints.getItem(i)) );
                        cumulativeDistance += segmentDistance;
                        this.cumulativeDistances.add(cumulativeDistance);
                    } else {
                        // If a transform is null, maintain the same distance value
                        this.cumulativeDistances.add(cumulativeDistance);
                    }
                }

                this.totalDistance = cumulativeDistance;
                this.isDistanceCacheDirty = false;
            },
            /*PathTransformBasedCached.CalculateCumulativeDistances end.*/

            /*PathTransformBasedCached.ConvertTfToDistance start.*/
            ConvertTfToDistance: function (tf) {
if ( TRACE ) { TRACE( "PathTransformBasedCached#ConvertTfToDistance", this ); }

                if (!this.IsValid() || this.cumulativeDistances == null || this.cumulativeDistances.Count === 0) {
                    return 0.0;
                }

                tf = Math.max(0, Math.min(1, tf));
                var targetDistance = tf * this.totalDistance;

                // Find the segment that contains the target distance
                for (var i = 0; i < ((this.cumulativeDistances.Count - 1) | 0); i = (i + 1) | 0) {
                    if (targetDistance >= this.cumulativeDistances.getItem(i) && targetDistance <= this.cumulativeDistances.getItem(((i + 1) | 0))) {
                        if (this.cumulativeDistances.getItem(((i + 1) | 0)) === this.cumulativeDistances.getItem(i)) {
                            return i;
                        } // Handle case where distances are the same

                        var segmentT = (targetDistance - this.cumulativeDistances.getItem(i)) / (this.cumulativeDistances.getItem(((i + 1) | 0)) - this.cumulativeDistances.getItem(i));
                        return i + segmentT;
                    }
                }

                // Handle edge cases (end of path)
                return ((this.PathPoints.Count - 1) | 0);
            },
            /*PathTransformBasedCached.ConvertTfToDistance end.*/

            /*PathTransformBasedCached.ConvertDistanceToTf start.*/
            ConvertDistanceToTf: function (distance) {
if ( TRACE ) { TRACE( "PathTransformBasedCached#ConvertDistanceToTf", this ); }

                if (!this.IsValid() || this.cumulativeDistances == null || this.cumulativeDistances.Count === 0) {
                    return 0.0;
                }

                distance = Math.max(0.0, Math.min(distance, this.totalDistance));

                // Find the segment that contains the target distance
                for (var i = 0; i < ((this.cumulativeDistances.Count - 1) | 0); i = (i + 1) | 0) {
                    if (distance >= this.cumulativeDistances.getItem(i) && distance <= this.cumulativeDistances.getItem(((i + 1) | 0))) {
                        if (this.cumulativeDistances.getItem(((i + 1) | 0)) === this.cumulativeDistances.getItem(i)) {
                            return i / (((this.PathPoints.Count - 1) | 0));
                        } // Handle case where distances are the same

                        var segmentT = (distance - this.cumulativeDistances.getItem(i)) / (this.cumulativeDistances.getItem(((i + 1) | 0)) - this.cumulativeDistances.getItem(i));
                        return Math.max(0, Math.min(1, (i + segmentT) / (((this.PathPoints.Count - 1) | 0))));
                    }
                }

                // Handle edge cases (end of path)
                return 1.0;
            },
            /*PathTransformBasedCached.ConvertDistanceToTf end.*/

            /*PathTransformBasedCached.GetTrueTfFromNormalizedTf start.*/
            GetTrueTfFromNormalizedTf: function (normalizedTf) {
if ( TRACE ) { TRACE( "PathTransformBasedCached#GetTrueTfFromNormalizedTf", this ); }

                if (this.isDistanceCacheDirty || this.cumulativeDistances == null) {
                    this.CalculateCumulativeDistances();
                }

                if (this.cumulativeDistances == null || this.cumulativeDistances.Count < 2) {
                    // Fall back to linear parameterization if arc-length is not available
                    return normalizedTf * (((this.PathPoints.Count - 1) | 0));
                }

                // Convert the normalized TF (0-1) to the true position based on arc-length
                var truePosition = this.ConvertTfToDistance(normalizedTf);
                return truePosition;
            },
            /*PathTransformBasedCached.GetTrueTfFromNormalizedTf end.*/


        }
    });
    /*PathTransformBasedCached end.*/

    /*PipeObject start.*/
    Bridge.define("PipeObject", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            VisualHandler: null,
            PaintingPixelsCovered: null,
            PixelDestroyed: 0,
            HeartText: null,
            Hearts: 0,
            ColorCode: null,
            IsHorizontal: false,
            PipeTransform: null,
            PipeBodyTransform: null,
            PipeHeadDefaultScale: null,
            PipeBodyDefaultScale: null,
            Destroyed$1: false,
            RemainingHearts: 0,
            HeartLoss: 0,
            scaleOriginalZ: 0,
            heartLossFromLastPixelDestroyed: 0,
            heartPerPixel: 0,
            ScaleDownValuePerHeart: 0,
            WorldPos: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "PipeObject#init", this ); }

                this.PipeHeadDefaultScale = new UnityEngine.Vector3();
                this.PipeBodyDefaultScale = new UnityEngine.Vector3();
                this.WorldPos = new UnityEngine.Vector3();
                this.PixelDestroyed = 0;
                this.PipeHeadDefaultScale = new pc.Vec3( 1, 1, 1 );
                this.PipeBodyDefaultScale = new pc.Vec3( 1, 1, 1 );
                this.Destroyed$1 = false;
                this.RemainingHearts = 0;
                this.HeartLoss = 0;
                this.scaleOriginalZ = 0.0;
                this.heartLossFromLastPixelDestroyed = 0.0;
                this.heartPerPixel = 0.0;
                this.ScaleDownValuePerHeart = 0.0;
            }
        },
        methods: {
            /*PipeObject.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "PipeObject#Awake", this ); }

                this.PipeTransform = this.PipeTransform || this.transform;
            },
            /*PipeObject.Awake end.*/

            /*PipeObject.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "PipeObject#OnDisable", this ); }

                this.VisualHandler.TextureScaler.DeActiveTextureScaler();
            },
            /*PipeObject.OnDisable end.*/

            /*PipeObject.Initialize start.*/
            /**
             * Initialize the pipe structure with head and body parts
             *
             * @instance
             * @public
             * @this PipeObject
             * @memberof PipeObject
             * @param   {System.Collections.Generic.List$1}    pipePixels      
             * @param   {string}                               colorCode       
             * @param   {number}                               hearts          
             * @param   {boolean}                              isHorizontal    True if the pipe is horizontal (in same row), false if vertical (in same column)
             * @return  {void}
             */
            Initialize: function (pipePixels, colorCode, hearts, isHorizontal) {
if ( TRACE ) { TRACE( "PipeObject#Initialize", this ); }

                if (isHorizontal === void 0) { isHorizontal = false; }
                this.Destroyed$1 = false;
                this.Hearts = hearts;
                this.PaintingPixelsCovered = pipePixels != null ? pipePixels : new (System.Collections.Generic.List$1(PaintingPixel)).ctor();
                this.IsHorizontal = isHorizontal;
                this.ColorCode = colorCode;

                var targetScale = this.PipeBodyDefaultScale.$clone();
                targetScale.z *= pipePixels.Count;
                this.PipeBodyTransform.localScale = targetScale.$clone();
                this.scaleOriginalZ = targetScale.z;

                //Hearts = Mathf.Max(PaintingPixelsCovered.Count, Hearts);
                this.Hearts = UnityEngine.Mathf.Max(1, this.Hearts);
                this.heartPerPixel = this.Hearts / this.PaintingPixelsCovered.Count;

                this.HeartLoss = 0;
                this.RemainingHearts = this.Hearts;
                this.heartLossFromLastPixelDestroyed = 0.0;

                this.ScaleDownValuePerHeart = targetScale.z / this.Hearts;

                this.VisualHandler.TextureScaler.ActiveScaler();
                this.HeartText.enabled = false;
                this.VisualHandler.TextureScaler.DeActiveTextureScaler();
            },
            /*PipeObject.Initialize end.*/

            /*PipeObject.ApplyOrientationRotation start.*/
            /**
             * Rotates all pipe parts based on orientation
             *
             * @instance
             * @public
             * @this PipeObject
             * @memberof PipeObject
             * @return  {void}
             */
            ApplyOrientationRotation: function () {
if ( TRACE ) { TRACE( "PipeObject#ApplyOrientationRotation", this ); }

                var pipeHead = this.PaintingPixelsCovered.getItem(0);
                var pipeTail = this.PaintingPixelsCovered.getItem(((this.PaintingPixelsCovered.Count - 1) | 0));
                if (this.IsHorizontal) {
                    // Rotate 90 degrees on Y axis for horizontal pipes
                    var leftToRight = pipeHead.column < pipeTail.column;
                    var rotateHead = leftToRight ? 90.0 : -90.0;
                    this.PipeTransform.localEulerAngles = new pc.Vec3( 0, rotateHead, 0 );
                } else {
                    var bottomToTop = pipeHead.row < pipeTail.row;
                    var rotateHead1 = bottomToTop ? 0 : 180;
                    this.PipeTransform.Rotate$1(pc.Vec3.UP.clone(), rotateHead1, UnityEngine.Space.Self);
                }
            },
            /*PipeObject.ApplyOrientationRotation end.*/

            /*PipeObject.OnAPixelDestroyed start.*/
            OnAPixelDestroyed: function () {
if ( TRACE ) { TRACE( "PipeObject#OnAPixelDestroyed", this ); }

                if (this.Destroyed$1) {
                    return;
                }
                this.HeartLoss = (this.HeartLoss + 1) | 0;
                this.RemainingHearts = (this.RemainingHearts - 1) | 0;
                !Bridge.staticEquals(GameplayEventsManager.OnAPipePixelDestroyed, null) ? GameplayEventsManager.OnAPipePixelDestroyed() : null;
                this.HeartText.text = Bridge.toString(this.RemainingHearts);
                this.heartLossFromLastPixelDestroyed++;
                if (this.heartLossFromLastPixelDestroyed >= this.heartPerPixel) {
                    this.PixelDestroyed = (this.PixelDestroyed + 1) | 0;

                    this.PaintingPixelsCovered.getItem(((this.PaintingPixelsCovered.Count - this.PixelDestroyed) | 0)).DestroyPixel(false);
                    this.heartLossFromLastPixelDestroyed = this.heartLossFromLastPixelDestroyed - this.heartPerPixel;
                }

                if (this.PixelDestroyed >= this.PaintingPixelsCovered.Count || this.RemainingHearts <= 0) {
                    this.Destroyed$1 = true;
                }

                for (var i = 0; i < (((((this.PaintingPixelsCovered.Count - 1) | 0)) - this.PixelDestroyed) | 0); i = (i + 1) | 0) {
                    this.PaintingPixelsCovered.getItem(i).destroyed = this.Destroyed$1;
                }

                if (this.Destroyed$1) {
                    this.SelfDestroy();
                } else {
                    DG.Tweening.DOTween.Kill(this.PipeBodyTransform);
                    this.VisualHandler.PlayFlash();
                    this.VisualHandler.TextureScaler.ActiveScaler();
                    DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScaleZ(this.PipeBodyTransform, this.scaleOriginalZ - (this.ScaleDownValuePerHeart * this.HeartLoss), 0.25), Bridge.fn.bind(this, function () {
                        this.VisualHandler.StopFlash();
                        this.VisualHandler.TextureScaler.DeActiveTextureScaler();
                    }));
                }
            },
            /*PipeObject.OnAPixelDestroyed end.*/

            /*PipeObject.SelfDestroy start.*/
            SelfDestroy: function () {
if ( TRACE ) { TRACE( "PipeObject#SelfDestroy", this ); }

                var $t;
                this.Destroyed$1 = true;
                $t = Bridge.getEnumerator(this.PaintingPixelsCovered);
                try {
                    while ($t.moveNext()) {
                        var pixel = $t.Current;
                        pixel.DestroyPixel(false, void 0);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                DG.Tweening.ShortcutExtensions.DOScale(this.PipeTransform, 0, 0.5);
                this.VisualHandler.TextureScaler.DeActiveTextureScaler();
            },
            /*PipeObject.SelfDestroy end.*/

            /*PipeObject.SelfDestroyGameobject start.*/
            SelfDestroyGameobject: function () {
if ( TRACE ) { TRACE( "PipeObject#SelfDestroyGameobject", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.PaintingPixelsCovered);
                try {
                    while ($t.moveNext()) {
                        var pixel = $t.Current;
                        if (UnityEngine.Application.isPlaying) {
                            UnityEngine.Object.Destroy(UnityEngine.MonoBehaviour.op_Inequality(pixel.PixelComponent, null) ? pixel.PixelComponent.gameObject : null);
                        } else {
                            UnityEngine.Object.DestroyImmediate(UnityEngine.MonoBehaviour.op_Inequality(pixel.PixelComponent, null) ? pixel.PixelComponent.gameObject : null);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                if (UnityEngine.Application.isPlaying) {
                    UnityEngine.Object.Destroy(this.gameObject);
                } else {
                    UnityEngine.Object.DestroyImmediate(this.gameObject);
                }
            },
            /*PipeObject.SelfDestroyGameobject end.*/

            /*PipeObject.ApplyPosition start.*/
            ApplyPosition: function () {
if ( TRACE ) { TRACE( "PipeObject#ApplyPosition", this ); }

                this.PipeTransform.position = this.WorldPos.$clone();
            },
            /*PipeObject.ApplyPosition end.*/


        }
    });
    /*PipeObject end.*/

    /*PipeObjectConfigSetup start.*/
    Bridge.define("PipeObjectConfigSetup", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            PaintingSetupModule: null,
            CurrentLevelObjectSetups: null,
            pipeObjectSetups: null,
            PipeHeadPrefab: null,
            PipeBodyPrefab: null,
            PipeTailPrefab: null,
            PipeHeart: 0,
            ColorCode: null,
            Scale: null,
            PipeSpaceFromGrid: 0,
            StartPixelComponent: null,
            EndPixelComponent: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "PipeObjectConfigSetup#init", this ); }

                this.Scale = new UnityEngine.Vector3();
                this.PipeHeart = 1;
                this.ColorCode = "Default";
                this.Scale = new pc.Vec3( 1, 1, 1 );
                this.PipeSpaceFromGrid = 1;
            }
        },
        methods: {
            /*PipeObjectConfigSetup.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "PipeObjectConfigSetup#Awake", this ); }

                if (this.pipeObjectSetups == null) {
                    this.pipeObjectSetups = new (System.Collections.Generic.List$1(PipeObjectSetup)).ctor();
                }
            },
            /*PipeObjectConfigSetup.Awake end.*/

            /*PipeObjectConfigSetup.AddPipeSetup start.*/
            /**
             * Add a pipe setup to the list
             *
             * @instance
             * @public
             * @this PipeObjectConfigSetup
             * @memberof PipeObjectConfigSetup
             * @param   {PipeObjectSetup}    pipeSetup    The pipe setup to add
             * @return  {void}
             */
            AddPipeSetup: function (pipeSetup) {
if ( TRACE ) { TRACE( "PipeObjectConfigSetup#AddPipeSetup", this ); }

                if (pipeSetup != null && !this.pipeObjectSetups.contains(pipeSetup)) {
                    this.pipeObjectSetups.add(pipeSetup);
                }
            },
            /*PipeObjectConfigSetup.AddPipeSetup end.*/

            /*PipeObjectConfigSetup.RemovePipeSetup start.*/
            /**
             * Remove a pipe setup from the list
             *
             * @instance
             * @public
             * @this PipeObjectConfigSetup
             * @memberof PipeObjectConfigSetup
             * @param   {PipeObjectSetup}    pipeSetup    The pipe setup to remove
             * @return  {void}
             */
            RemovePipeSetup: function (pipeSetup) {
if ( TRACE ) { TRACE( "PipeObjectConfigSetup#RemovePipeSetup", this ); }

                if (pipeSetup != null) {
                    this.pipeObjectSetups.remove(pipeSetup);
                }
            },
            /*PipeObjectConfigSetup.RemovePipeSetup end.*/

            /*PipeObjectConfigSetup.ClearPipeSetups start.*/
            /**
             * Clear all pipe setups
             *
             * @instance
             * @public
             * @this PipeObjectConfigSetup
             * @memberof PipeObjectConfigSetup
             * @return  {void}
             */
            ClearPipeSetups: function () {
if ( TRACE ) { TRACE( "PipeObjectConfigSetup#ClearPipeSetups", this ); }

                this.pipeObjectSetups.clear();
            },
            /*PipeObjectConfigSetup.ClearPipeSetups end.*/

            /*PipeObjectConfigSetup.ClearAllPipeSetups start.*/
            ClearAllPipeSetups: function () {
if ( TRACE ) { TRACE( "PipeObjectConfigSetup#ClearAllPipeSetups", this ); }

                var $t;
                this.ClearPipeSetups();

                // Also clear pipe objects from the grid if they exist
                if (UnityEngine.MonoBehaviour.op_Inequality(this.PaintingSetupModule.CurrentGridObject, null) && this.PaintingSetupModule.CurrentGridObject.PipeObjects != null) {
                    // Destroy the pipe gameobjects
                    var currentPipes = new (System.Collections.Generic.List$1(PipeObject)).$ctor1(this.PaintingSetupModule.CurrentGridObject.PipeObjects);
                    $t = Bridge.getEnumerator(currentPipes);
                    try {
                        while ($t.moveNext()) {
                            var pipeObj = $t.Current;
                            this.PaintingSetupModule.CurrentGridObject.RemovePipeObject(pipeObj);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    this.PaintingSetupModule.CurrentGridObject.PipeObjects.clear();
                }

            },
            /*PipeObjectConfigSetup.ClearAllPipeSetups end.*/

            /*PipeObjectConfigSetup.CreatePipe$1 start.*/
            /**
             * Create a pipe between StartPixel and EndPixel based on current settings
             *
             * @instance
             * @public
             * @this PipeObjectConfigSetup
             * @memberof PipeObjectConfigSetup
             * @return  {void}
             */
            CreatePipe$1: function () {
if ( TRACE ) { TRACE( "PipeObjectConfigSetup#CreatePipe$1", this ); }

                this.pipeObjectSetups = new (System.Collections.Generic.List$1(PipeObjectSetup)).$ctor1(this.CurrentLevelObjectSetups);
                if (UnityEngine.MonoBehaviour.op_Equality(this.StartPixelComponent, null) || UnityEngine.MonoBehaviour.op_Equality(this.EndPixelComponent, null)) {
                    UnityEngine.Debug.LogWarning$1("StartPixelComponent or EndPixelComponent is null. Cannot create pipe.");
                    return;
                }

                // Get the PaintingPixel from the components
                var startPixel = this.StartPixelComponent.PixelData;
                var endPixel = this.EndPixelComponent.PixelData;

                if (startPixel == null || endPixel == null) {
                    UnityEngine.Debug.LogWarning$1("Could not get PaintingPixel data from components. Cannot create pipe.");
                    return;
                }

                if (UnityEngine.MonoBehaviour.op_Equality(this.PaintingSetupModule.CurrentGridObject, null)) {
                    UnityEngine.Debug.LogWarning$1("GridObject reference is null. Cannot create pipe.");
                    return;
                }

                // Validate that the pipe should be straight (horizontal or vertical)
                if (!this.IsValidPipeOrientation(startPixel, endPixel)) {
                    UnityEngine.Debug.LogWarning$1("Pipe must be either horizontal (same row) or vertical (same column). Cannot create pipe.");
                    return;
                }

                // Create and setup the pipe in the scene - this will also create the pipe pixels
                var pipePixelConfigs = this.GetPaintingPixelsInBetweenithSpace(startPixel, endPixel);
                var wallSetup = new PipeObjectSetup.$ctor2(pipePixelConfigs, this.ColorCode, this.Scale.$clone(), this.PipeHeart);

                var newWallObject = this.SetupNewPipeInScene(wallSetup);

                if (UnityEngine.MonoBehaviour.op_Inequality(newWallObject, null)) {
                    this.AddPipeSetup(wallSetup);
                }
            },
            /*PipeObjectConfigSetup.CreatePipe$1 end.*/

            /*PipeObjectConfigSetup.CreatePipe start.*/
            CreatePipe: function (startPixel, endPixel, colorCode, hearts) {
if ( TRACE ) { TRACE( "PipeObjectConfigSetup#CreatePipe", this ); }

                this.pipeObjectSetups = new (System.Collections.Generic.List$1(PipeObjectSetup)).$ctor1(this.CurrentLevelObjectSetups);
                if (startPixel == null || endPixel == null) {
                    UnityEngine.Debug.LogWarning$1("StartPixelComponent or EndPixelComponent is null. Cannot create pipe.");
                    return null;
                }

                if (startPixel == null || endPixel == null) {
                    UnityEngine.Debug.LogWarning$1("Could not get PaintingPixel data from components. Cannot create pipe.");
                    return null;
                }

                if (UnityEngine.MonoBehaviour.op_Equality(this.PaintingSetupModule.CurrentGridObject, null)) {
                    UnityEngine.Debug.LogWarning$1("GridObject reference is null. Cannot create pipe.");
                    return null;
                }

                // Validate that the pipe should be straight (horizontal or vertical)
                if (!this.IsValidPipeOrientation(startPixel, endPixel)) {
                    UnityEngine.Debug.LogWarning$1("Pipe must be either horizontal (same row) or vertical (same column). Cannot create pipe.");
                    return null;
                }

                // Create and setup the pipe in the scene - this will also create the pipe pixels
                var pipePixelConfigs = this.GetPaintingPixelsInBetween(startPixel, endPixel);
                var pipeSetup = new PipeObjectSetup.$ctor2(pipePixelConfigs, colorCode, this.Scale.$clone(), hearts);

                var newPipeObject = this.SetupNewPipeInScene(pipeSetup);

                if (UnityEngine.MonoBehaviour.op_Inequality(newPipeObject, null)) {
                    this.AddPipeSetup(pipeSetup);
                }
                return pipeSetup;
            },
            /*PipeObjectConfigSetup.CreatePipe end.*/

            /*PipeObjectConfigSetup.GetPaintingPixelsInBetween start.*/
            GetPaintingPixelsInBetween: function (startPixel, endPixel) {
if ( TRACE ) { TRACE( "PipeObjectConfigSetup#GetPaintingPixelsInBetween", this ); }

                var $t;
                var pixelsInBetween = new (System.Collections.Generic.List$1(PaintingPixelConfig)).ctor();

                // Determine if pipe is horizontal or vertical
                var isHorizontal = startPixel.row === endPixel.row;
                var isVertical = startPixel.column === endPixel.column;

                if (isHorizontal) {
                    // Create PaintingPixel objects for all body parts between start and end
                    var direction = startPixel.column <= endPixel.column ? 1 : -1;
                    for (var c = startPixel.column; c !== ((endPixel.column + direction) | 0); c = (c + direction) | 0) {
                        var bodyPipePixel = ($t = new PaintingPixelConfig.ctor(), $t.column = c, $t.row = startPixel.row, $t.color = this.PaintingSetupModule.PrefabSource.ColorPallete.GetColorByCode(this.ColorCode), $t.colorCode = this.ColorCode, $t.Hidden = false, $t);
                        pixelsInBetween.add(bodyPipePixel);
                    }
                } else if (isVertical) {
                    var direction1 = startPixel.row <= endPixel.row ? 1 : -1;
                    for (var r = startPixel.row; r !== ((endPixel.row + direction1) | 0); r = (r + direction1) | 0) {
                        var bodyPipePixel1 = ($t = new PaintingPixelConfig.ctor(), $t.column = startPixel.column, $t.row = r, $t.color = this.PaintingSetupModule.PrefabSource.ColorPallete.GetColorByCode(this.ColorCode), $t.colorCode = this.ColorCode, $t.Hidden = false, $t);
                        pixelsInBetween.add(bodyPipePixel1);
                    }
                }

                // Sort pipe pixels from head to tail based on original grid position
                if (pixelsInBetween.Count > 1) {
                    if (isHorizontal) {
                        if (startPixel.column < endPixel.column) {
                            pixelsInBetween.Sort$2(function (p1, p2) {
                                return Bridge.compare(p1.column, p2.column);
                            });
                        } else {
                            pixelsInBetween.Sort$2(function (p1, p2) {
                                return Bridge.compare(p2.column, p1.column);
                            });
                        }
                    } else if (isVertical) {
                        if (startPixel.row < endPixel.row) {
                            pixelsInBetween.Sort$2(function (p1, p2) {
                                return Bridge.compare(p1.row, p2.row);
                            });
                        } else {
                            pixelsInBetween.Sort$2(function (p1, p2) {
                                return Bridge.compare(p2.row, p1.row);
                            });
                        }
                    }
                }

                return pixelsInBetween;
            },
            /*PipeObjectConfigSetup.GetPaintingPixelsInBetween end.*/

            /*PipeObjectConfigSetup.GetPaintingPixelsInBetweenithSpace start.*/
            GetPaintingPixelsInBetweenithSpace: function (startPixel, endPixel) {
if ( TRACE ) { TRACE( "PipeObjectConfigSetup#GetPaintingPixelsInBetweenithSpace", this ); }

                var $t;
                var pixelsInBetween = new (System.Collections.Generic.List$1(PaintingPixelConfig)).ctor();

                // Determine if pipe is horizontal or vertical
                var isHorizontal = startPixel.row === endPixel.row;
                var isVertical = startPixel.column === endPixel.column;

                // Create new PaintingPixel and PaintingPixelComponent for the head of the pipe (outside the grid)
                // First get the actual grid pixel for head to make sure we have the correct world position
                var actualGridHeadPixel = new PaintingPixelConfig.$ctor1(this.PaintingSetupModule.CurrentGridObject.GetOriginalPixelAt(startPixel.column, startPixel.row));
                var currentPixelColumn = startPixel.column;
                var currentPixelRow = startPixel.row;

                if (isHorizontal) {
                    if (startPixel.row < 0) {
                        currentPixelRow = (currentPixelRow - this.PipeSpaceFromGrid) | 0;
                    } else {
                        currentPixelRow = (currentPixelRow + this.PipeSpaceFromGrid) | 0;
                    }
                } else {
                    if (startPixel.column < 0) {
                        currentPixelColumn = (currentPixelColumn - this.PipeSpaceFromGrid) | 0;
                    } else {
                        currentPixelColumn = (currentPixelColumn + this.PipeSpaceFromGrid) | 0;
                    }
                }

                var headPipePixel = ($t = new PaintingPixelConfig.ctor(), $t.column = currentPixelColumn, $t.row = currentPixelRow, $t.color = this.PaintingSetupModule.PrefabSource.ColorPallete.GetColorByCode(this.ColorCode), $t.colorCode = this.ColorCode, $t.Hidden = false, $t);
                pixelsInBetween.add(headPipePixel); // Add the head pipe pixel first

                if (isHorizontal) {
                    var row = startPixel.row;
                    var startCol = UnityEngine.Mathf.Min(startPixel.column, endPixel.column);
                    var endCol = UnityEngine.Mathf.Max(startPixel.column, endPixel.column);

                    // Create PaintingPixel objects for all body parts between start and end
                    for (var col = (startCol + 1) | 0; col < endCol; col = (col + 1) | 0) {
                        // Get the original grid pixel to use its world position for reference
                        var gridPixel = new PaintingPixelConfig.$ctor1(this.PaintingSetupModule.CurrentGridObject.GetOriginalPixelAt(col, row));
                        if (gridPixel != null) {
                            currentPixelRow = row;
                            currentPixelColumn = col;
                            if (startPixel.row < 0) {
                                currentPixelRow = (currentPixelRow - this.PipeSpaceFromGrid) | 0;
                            } else {
                                currentPixelRow = (currentPixelRow + this.PipeSpaceFromGrid) | 0;
                            }
                            var bodyPipePixel = ($t = new PaintingPixelConfig.ctor(), $t.column = currentPixelColumn, $t.row = currentPixelRow, $t.color = this.PaintingSetupModule.PrefabSource.ColorPallete.GetColorByCode(this.ColorCode), $t.colorCode = this.ColorCode, $t.Hidden = false, $t);
                            pixelsInBetween.add(bodyPipePixel);
                        }
                    }
                } else if (isVertical) {
                    var column = startPixel.column;
                    var startRow = UnityEngine.Mathf.Min(startPixel.row, endPixel.row);
                    var endRow = UnityEngine.Mathf.Max(startPixel.row, endPixel.row);

                    // Create PaintingPixel objects for all body parts between start and end
                    for (var row1 = (startRow + 1) | 0; row1 < endRow; row1 = (row1 + 1) | 0) {
                        // Get the original grid pixel to use its world position for reference
                        var gridPixel1 = new PaintingPixelConfig.$ctor1(this.PaintingSetupModule.CurrentGridObject.GetOriginalPixelAt(column, row1));
                        if (gridPixel1 != null) {
                            currentPixelRow = row1;
                            currentPixelColumn = column;
                            if (startPixel.column < 0) {
                                currentPixelColumn = (currentPixelColumn - this.PipeSpaceFromGrid) | 0;
                            } else {
                                currentPixelColumn = (currentPixelColumn + this.PipeSpaceFromGrid) | 0;
                            }
                            var bodyPipePixel1 = ($t = new PaintingPixelConfig.ctor(), $t.column = currentPixelColumn, $t.row = currentPixelRow, $t.color = this.PaintingSetupModule.PrefabSource.ColorPallete.GetColorByCode(this.ColorCode), $t.colorCode = this.ColorCode, $t.Hidden = false, $t);
                            pixelsInBetween.add(bodyPipePixel1);
                        }
                    }
                }

                // Create new PaintingPixel and PaintingPixelComponent for the tail of the pipe (outside the grid)
                // First get the actual grid pixel for tail to make sure we have the correct world position
                var actualGridTailPixel = new PaintingPixelConfig.$ctor1(this.PaintingSetupModule.CurrentGridObject.GetOriginalPixelAt(endPixel.column, endPixel.row));
                currentPixelRow = endPixel.row;
                currentPixelColumn = endPixel.column;
                if (isHorizontal) {
                    if (startPixel.row < 0) {
                        currentPixelRow = (currentPixelRow - this.PipeSpaceFromGrid) | 0;
                    } else {
                        currentPixelRow = (currentPixelRow + this.PipeSpaceFromGrid) | 0;
                    }
                } else {
                    if (startPixel.column < 0) {
                        currentPixelColumn = (currentPixelColumn - this.PipeSpaceFromGrid) | 0;
                    } else {
                        currentPixelColumn = (currentPixelColumn + this.PipeSpaceFromGrid) | 0;
                    }
                }
                var tailPipePixel = ($t = new PaintingPixelConfig.ctor(), $t.column = currentPixelColumn, $t.row = currentPixelRow, $t.color = this.PaintingSetupModule.PrefabSource.ColorPallete.GetColorByCode(this.ColorCode), $t.colorCode = this.ColorCode, $t.Hidden = false, $t);
                pixelsInBetween.add(tailPipePixel);

                // Sort pipe pixels from head to tail based on original grid position
                if (pixelsInBetween.Count > 1) {
                    if (isHorizontal) {
                        if (startPixel.column < endPixel.column) {
                            pixelsInBetween.Sort$2(function (p1, p2) {
                                return Bridge.compare(p1.column, p2.column);
                            });
                        } else {
                            pixelsInBetween.Sort$2(function (p1, p2) {
                                return Bridge.compare(p2.column, p1.column);
                            });
                        }
                    } else if (isVertical) {
                        if (startPixel.row < endPixel.row) {
                            pixelsInBetween.Sort$2(function (p1, p2) {
                                return Bridge.compare(p1.row, p2.row);
                            });
                        } else {
                            pixelsInBetween.Sort$2(function (p1, p2) {
                                return Bridge.compare(p2.row, p1.row);
                            });
                        }
                    }
                }

                return pixelsInBetween;
            },
            /*PipeObjectConfigSetup.GetPaintingPixelsInBetweenithSpace end.*/

            /*PipeObjectConfigSetup.SetupNewPipeInScene start.*/
            /**
             * Set up the actual pipe object in the scene
             *
             * @instance
             * @private
             * @this PipeObjectConfigSetup
             * @memberof PipeObjectConfigSetup
             * @param   {PipeObjectSetup}    setup
             * @return  {PipeObject}                  Tuple with the created PipeObject component and list of new pipe pixels
             */
            SetupNewPipeInScene: function (setup) {
if ( TRACE ) { TRACE( "PipeObjectConfigSetup#SetupNewPipeInScene", this ); }

                var pipeObject = null;
                pipeObject = this.PaintingSetupModule.CurrentGridObject.CreatePipeObject(setup);
                return pipeObject;
            },
            /*PipeObjectConfigSetup.SetupNewPipeInScene end.*/

            /*PipeObjectConfigSetup.IsValidPipeOrientation start.*/
            /**
             * Validates if the pipe orientation is valid (horizontal or vertical only)
             *
             * @instance
             * @public
             * @this PipeObjectConfigSetup
             * @memberof PipeObjectConfigSetup
             * @param   {PaintingPixel}    startPixel    Start pixel (head)
             * @param   {PaintingPixel}    endPixel      End pixel (tail)
             * @return  {boolean}                        True if pipe orientation is valid, false otherwise
             */
            IsValidPipeOrientation: function (startPixel, endPixel) {
if ( TRACE ) { TRACE( "PipeObjectConfigSetup#IsValidPipeOrientation", this ); }

                return (startPixel.row === endPixel.row) || (startPixel.column === endPixel.column);
            },
            /*PipeObjectConfigSetup.IsValidPipeOrientation end.*/

            /*PipeObjectConfigSetup.IsValidPipeOrientation$1 start.*/
            /**
             * Helper method to validate pipe orientation using PaintingPixelComponents
             *
             * @instance
             * @private
             * @this PipeObjectConfigSetup
             * @memberof PipeObjectConfigSetup
             * @param   {PaintingPixelComponent}    startPixelComponent    Start pixel component
             * @param   {PaintingPixelComponent}    endPixelComponent      End pixel component
             * @return  {boolean}                                          True if pipe orientation is valid, false otherwise
             */
            IsValidPipeOrientation$1: function (startPixelComponent, endPixelComponent) {
if ( TRACE ) { TRACE( "PipeObjectConfigSetup#IsValidPipeOrientation$1", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(startPixelComponent, null) || UnityEngine.MonoBehaviour.op_Equality(endPixelComponent, null)) {
                    return false;
                }

                var startPixel = startPixelComponent.PixelData;
                var endPixel = endPixelComponent.PixelData;

                if (startPixel == null || endPixel == null) {
                    return false;
                }

                return (startPixel.row === endPixel.row) || (startPixel.column === endPixel.column);
            },
            /*PipeObjectConfigSetup.IsValidPipeOrientation$1 end.*/

            /*PipeObjectConfigSetup.ImportPipesToPaintingConfig start.*/
            /**
             * Import all pipe configurations from this setup to a PaintingConfig asset
             *
             * @instance
             * @public
             * @this PipeObjectConfigSetup
             * @memberof PipeObjectConfigSetup
             * @param   {PaintingConfig}    paintingConfig    The PaintingConfig to import to
             * @return  {void}
             */
            ImportPipesToPaintingConfig: function (paintingConfig) {
if ( TRACE ) { TRACE( "PipeObjectConfigSetup#ImportPipesToPaintingConfig", this ); }

                var $t;
                if (paintingConfig == null) {
                    UnityEngine.Debug.LogError$2("PaintingConfig is null. Cannot import pipes.");
                    return;
                }

                // Clear existing pipe setups in the config
                if (paintingConfig.PipeSetups == null) {
                    paintingConfig.PipeSetups = new (System.Collections.Generic.List$1(PipeObjectSetup)).ctor();
                } else {
                    paintingConfig.PipeSetups.clear();
                }

                // Copy all pipe setups from this component to the config
                $t = Bridge.getEnumerator(this.pipeObjectSetups);
                try {
                    while ($t.moveNext()) {
                        var pipeSetup = $t.Current;
                        if (pipeSetup != null) {
                            // Add the pipe setup to the painting config
                            paintingConfig.PipeSetups.add(pipeSetup);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                paintingConfig.HidePixelsUnderPipes();

                UnityEngine.Debug.Log$1(System.String.format("Imported {0} pipe setups to PaintingConfig.", [Bridge.box(this.pipeObjectSetups.Count, System.Int32)]));
            },
            /*PipeObjectConfigSetup.ImportPipesToPaintingConfig end.*/

            /*PipeObjectConfigSetup.Reload start.*/
            Reload: function () {
if ( TRACE ) { TRACE( "PipeObjectConfigSetup#Reload", this ); }

                var $t;
                this.PaintingSetupModule.CurrentGridObject.ClearAllPipes();
                this.pipeObjectSetups = new (System.Collections.Generic.List$1(PipeObjectSetup)).$ctor1(this.CurrentLevelObjectSetups);
                //return;
                $t = Bridge.getEnumerator(this.CurrentLevelObjectSetups);
                try {
                    while ($t.moveNext()) {
                        var pipe = $t.Current;
                        this.PaintingSetupModule.CurrentGridObject.CreatePipeObject(pipe);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*PipeObjectConfigSetup.Reload end.*/

            /*PipeObjectConfigSetup.Save start.*/
            Save: function () {
if ( TRACE ) { TRACE( "PipeObjectConfigSetup#Save", this ); }

                this.ImportPipesToPaintingConfig(this.PaintingSetupModule.CurrentPaintingConfig);
                this.PaintingSetupModule.Save();
            },
            /*PipeObjectConfigSetup.Save end.*/


        },
        overloads: {
            "CreatePipe()": "CreatePipe$1",
            "IsValidPipeOrientation(PaintingPixelComponent, PaintingPixelComponent)": "IsValidPipeOrientation$1"
        }
    });
    /*PipeObjectConfigSetup end.*/

    /*PipeObjectSetup start.*/
    Bridge.define("PipeObjectSetup", {
        fields: {
            Hearts: 0,
            PixelCovered: null,
            ColorCode: null,
            Scale: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "PipeObjectSetup#init", this ); }

                this.Scale = new UnityEngine.Vector3();
                this.Hearts = 0;
                this.Scale = new pc.Vec3( 1, 1, 1 );
            },
            ctor: function () {
if ( TRACE ) { TRACE( "PipeObjectSetup#ctor", this ); }

                this.$initialize();
                this.Hearts = 1;
                this.PixelCovered = new (System.Collections.Generic.List$1(PaintingPixelConfig)).ctor();
                this.ColorCode = "";
                this.Scale = new pc.Vec3( 1, 1, 1 );
            },
            $ctor2: function (pixelCovered, colorCode, scale, heart) {
if ( TRACE ) { TRACE( "PipeObjectSetup#$ctor2", this ); }

                this.$initialize();
                this.Hearts = heart;
                this.PixelCovered = pixelCovered != null ? new (System.Collections.Generic.List$1(PaintingPixelConfig)).$ctor1(pixelCovered) : new (System.Collections.Generic.List$1(PaintingPixelConfig)).ctor();
                this.ColorCode = colorCode;
                this.Scale = scale.$clone();
            },
            $ctor1: function (_stock) {
if ( TRACE ) { TRACE( "PipeObjectSetup#$ctor1", this ); }

                var $t;
                this.$initialize();
                this.Hearts = _stock.Hearts;
                this.PixelCovered = new (System.Collections.Generic.List$1(PaintingPixelConfig)).ctor();
                $t = Bridge.getEnumerator(_stock.PixelCovered);
                try {
                    while ($t.moveNext()) {
                        var pixel = $t.Current;
                        this.PixelCovered.add(new PaintingPixelConfig.$ctor2(pixel));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.ColorCode = _stock.ColorCode;
                this.Scale = _stock.Scale.$clone();
            }
        }
    });
    /*PipeObjectSetup end.*/

    /*PipePartVisualHandle start.*/
    Bridge.define("PipePartVisualHandle", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            TextureScaler: null,
            pipeRenderers: null,
            PipeScaleBody: null,
            BrightnessRange: null,
            FlashDuration: 0,
            currentBrightness: 0,
            cachedFlashTween: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "PipePartVisualHandle#init", this ); }

                this.BrightnessRange = new UnityEngine.Vector2();
                this.pipeRenderers = new (System.Collections.Generic.List$1(UnityEngine.Renderer)).ctor();
                this.BrightnessRange = new pc.Vec2( 0.45, 1.0 );
                this.FlashDuration = 0.2;
                this.currentBrightness = 0.45;
            }
        },
        methods: {
            /*PipePartVisualHandle.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "PipePartVisualHandle#Awake", this ); }

                this.CacheFlashTween();
            },
            /*PipePartVisualHandle.Awake end.*/

            /*PipePartVisualHandle.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "PipePartVisualHandle#OnDisable", this ); }

                this.StopFlash();
            },
            /*PipePartVisualHandle.OnDisable end.*/

            /*PipePartVisualHandle.SetColor start.*/
            /**
             * Change the color of the pipe part using sharedMaterial with unique materials
             *
             * @instance
             * @public
             * @this PipePartVisualHandle
             * @memberof PipePartVisualHandle
             * @param   {UnityEngine.Color}    color    The color to apply
             * @return  {void}
             */
            SetColor: function (color) {
if ( TRACE ) { TRACE( "PipePartVisualHandle#SetColor", this ); }

                var $t;
                if (this.pipeRenderers != null) {
                    // Create unique materials for each renderer to avoid color conflicts
                    $t = Bridge.getEnumerator(this.pipeRenderers);
                    try {
                        while ($t.moveNext()) {
                            var renderer = $t.Current;
                            if (UnityEngine.Component.op_Inequality(renderer, null)) {
                                // Create a new material instance for this renderer
                                var uniqueMaterial = new UnityEngine.Material.$ctor1(renderer.sharedMaterial);
                                uniqueMaterial.SetColor$1("_Color", color);
                                renderer.sharedMaterial = uniqueMaterial;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
            },
            /*PipePartVisualHandle.SetColor end.*/

            /*PipePartVisualHandle.CacheFlashTween start.*/
            CacheFlashTween: function () {
if ( TRACE ) { TRACE( "PipePartVisualHandle#CacheFlashTween", this ); }

                if (this.cachedFlashTween != null) {
                    DG.Tweening.TweenExtensions.Kill(this.cachedFlashTween);
                }

                this.currentBrightness = this.BrightnessRange.x;

                this.cachedFlashTween = DG.Tweening.TweenSettingsExtensions.SetAutoKill$1(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), DG.Tweening.TweenExtensions.Pause(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), DG.Tweening.DOTween.To$4(Bridge.fn.bind(this, function () {
                    return this.currentBrightness;
                }), Bridge.fn.bind(this, function (x) {
                    this.currentBrightness = x;
                    // Ensure PipeScaleBody has its own material instance
                    if (System.String.contains(this.PipeScaleBody.sharedMaterial.name,"Instance") === false) {
                        var uniqueMaterial = new UnityEngine.Material.$ctor1(this.PipeScaleBody.sharedMaterial);
                        this.PipeScaleBody.sharedMaterial = uniqueMaterial;
                    }
                    this.PipeScaleBody.sharedMaterial.SetFloat$1("_Brightness", this.currentBrightness);
                }), this.BrightnessRange.y, this.FlashDuration), DG.Tweening.Ease.OutQuad)), false);
                DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Tween, this.cachedFlashTween, Bridge.fn.bind(this, function () {
                    this.SetBrightness(this.BrightnessRange.x);
                }));
            },
            /*PipePartVisualHandle.CacheFlashTween end.*/

            /*PipePartVisualHandle.PlayFlash start.*/
            PlayFlash: function () {
if ( TRACE ) { TRACE( "PipePartVisualHandle#PlayFlash", this ); }

                DG.Tweening.TweenExtensions.Restart(this.cachedFlashTween);
            },
            /*PipePartVisualHandle.PlayFlash end.*/

            /*PipePartVisualHandle.StopFlash start.*/
            StopFlash: function () {
if ( TRACE ) { TRACE( "PipePartVisualHandle#StopFlash", this ); }

                DG.Tweening.TweenExtensions.Pause(DG.Tweening.Tween, this.cachedFlashTween);
                this.SetBrightness(this.BrightnessRange.x);
            },
            /*PipePartVisualHandle.StopFlash end.*/

            /*PipePartVisualHandle.SetBrightness start.*/
            SetBrightness: function (_brightness) {
if ( TRACE ) { TRACE( "PipePartVisualHandle#SetBrightness", this ); }

                // Ensure PipeScaleBody has its own material instance
                if (System.String.contains(this.PipeScaleBody.sharedMaterial.name,"Instance") === false) {
                    var uniqueMaterial = new UnityEngine.Material.$ctor1(this.PipeScaleBody.sharedMaterial);
                    this.PipeScaleBody.sharedMaterial = uniqueMaterial;
                }
                this.PipeScaleBody.sharedMaterial.SetFloat$1("_Brightness", _brightness);
            },
            /*PipePartVisualHandle.SetBrightness end.*/


        }
    });
    /*PipePartVisualHandle end.*/

    /*PixelMaterialFallbackProvider start.*/
    /**
     * Provides a globally assigned fallback material so Luna/HTML build has a registered asset reference
     instead of ad-hoc instantiated Materials (which are not in the material registry and cause InternalErrorShader fallback).
     Place one instance in the initial scene and assign a safe default pixel material (e.g. white base).
     *
     * @public
     * @class PixelMaterialFallbackProvider
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("PixelMaterialFallbackProvider", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                _instance: null
            },
            props: {
                GlobalFallback: {
                    get: function () {
if ( TRACE ) { TRACE( "PixelMaterialFallbackProvider#GlobalFallback#get", this ); }

                        return UnityEngine.MonoBehaviour.op_Inequality(PixelMaterialFallbackProvider._instance, null) ? PixelMaterialFallbackProvider._instance.FallbackMaterial : null;
                    }
                }
            }
        },
        fields: {
            FallbackMaterial: null
        },
        methods: {
            /*PixelMaterialFallbackProvider.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "PixelMaterialFallbackProvider#Awake", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(PixelMaterialFallbackProvider._instance, null) && UnityEngine.MonoBehaviour.op_Inequality(PixelMaterialFallbackProvider._instance, this)) {
                    // Keep first instance, ignore subsequent
                    return;
                }
                PixelMaterialFallbackProvider._instance = this;
            },
            /*PixelMaterialFallbackProvider.Awake end.*/


        }
    });
    /*PixelMaterialFallbackProvider end.*/

    /*PlayNowButtonAnim start.*/
    Bridge.define("PlayNowButtonAnim", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            playerNowButton: null,
            maxScale: null,
            minScale: null,
            scaleDuration: 0,
            m_autoStart: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "PlayNowButtonAnim#init", this ); }

                this.maxScale = new UnityEngine.Vector3();
                this.minScale = new UnityEngine.Vector3();
                this.maxScale = new pc.Vec3( 1.2, 1.2, 1.2 );
                this.minScale = new pc.Vec3( 1.0, 1.0, 1.0 );
                this.scaleDuration = 0.5;
                this.m_autoStart = true;
            }
        },
        methods: {
            /*PlayNowButtonAnim.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "PlayNowButtonAnim#Start", this ); }

                this.playerNowButton.onClick.AddListener(Bridge.fn.cacheBind(this, this.GotoStore));
                this.StartScalingAnimation();
            },
            /*PlayNowButtonAnim.Start end.*/

            /*PlayNowButtonAnim.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "PlayNowButtonAnim#OnDestroy", this ); }

                this.playerNowButton.onClick.RemoveListener(Bridge.fn.cacheBind(this, this.GotoStore));
            },
            /*PlayNowButtonAnim.OnDestroy end.*/

            /*PlayNowButtonAnim.GotoStore start.*/
            GotoStore: function () {
if ( TRACE ) { TRACE( "PlayNowButtonAnim#GotoStore", this ); }

                Luna.Unity.LifeCycle.GameEnded();
                Luna.Unity.Playable.InstallFullGame();
            },
            /*PlayNowButtonAnim.GotoStore end.*/

            /*PlayNowButtonAnim.StartScalingAnimation start.*/
            StartScalingAnimation: function () {
if ( TRACE ) { TRACE( "PlayNowButtonAnim#StartScalingAnimation", this ); }

                if (!this.m_autoStart) {
                    return;
                }
                DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.playerNowButton.transform, this.maxScale.$clone(), this.scaleDuration), DG.Tweening.Ease.InOutSine), Bridge.fn.bind(this, function () {
                    DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.playerNowButton.transform, this.minScale.$clone(), this.scaleDuration), DG.Tweening.Ease.InOutSine), Bridge.fn.cacheBind(this, this.StartScalingAnimation));
                }));
            },
            /*PlayNowButtonAnim.StartScalingAnimation end.*/


        }
    });
    /*PlayNowButtonAnim end.*/

    /*SingleColorCollectorConfig start.*/
    Bridge.define("SingleColorCollectorConfig", {
        fields: {
            ID: 0,
            ColorCode: null,
            Bullets: 0,
            Locked: false,
            Hidden: false,
            ConnectedCollectorsIDs: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "SingleColorCollectorConfig#init", this ); }

                this.ID = -1;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "SingleColorCollectorConfig#ctor", this ); }

                this.$initialize();
                this.ConnectedCollectorsIDs = new (System.Collections.Generic.List$1(System.Int32)).ctor();
            },
            $ctor2: function (colorCode, bullets, locked, hidden) {
if ( TRACE ) { TRACE( "SingleColorCollectorConfig#$ctor2", this ); }

                if (locked === void 0) { locked = false; }
                if (hidden === void 0) { hidden = false; }

                this.$initialize();
                this.ID = -1;
                this.ColorCode = colorCode;
                this.Bullets = bullets;
                this.Locked = locked;
                this.Hidden = hidden;
                this.ConnectedCollectorsIDs = new (System.Collections.Generic.List$1(System.Int32)).ctor();
            },
            $ctor1: function (_stock) {
if ( TRACE ) { TRACE( "SingleColorCollectorConfig#$ctor1", this ); }

                this.$initialize();
                this.ID = _stock.ID;
                this.ColorCode = _stock.ColorCode;
                this.Bullets = _stock.Bullets;
                this.Locked = _stock.Locked;
                this.Hidden = _stock.Hidden;
                this.ConnectedCollectorsIDs = new (System.Collections.Generic.List$1(System.Int32)).$ctor1(_stock.ConnectedCollectorsIDs);
            }
        }
    });
    /*SingleColorCollectorConfig end.*/

    /*Singleton$1 start.*/
    Bridge.define("Singleton$1", function (T) { return {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                Instance: Bridge.getDefaultValue(T)
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Singleton$1#init", this ); }

                    this.Instance = Bridge.getDefaultValue(T);
                }
            }
        },
        methods: {
            /*Singleton$1.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Singleton$1#Awake", this ); }

                if (Bridge.rValue(Singleton$1(T).Instance) == null) {
                    Singleton$1(T).Instance = Bridge.as(this, T);
                } else {
                    UnityEngine.Object.Destroy(this);
                }
            },
            /*Singleton$1.Awake end.*/


        }
    }; });
    /*Singleton$1 end.*/

    /*SoundDefine start.*/
    Bridge.define("SoundDefine", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "SoundDefine#getDefaultValue", this ); }
 return new SoundDefine(); }
            }
        },
        fields: {
            soundType: 0,
            Loop: false,
            Clip: null,
            ClipList: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "SoundDefine#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*SoundDefine.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "SoundDefine#Dispose", this ); }

                this.Clip = null;
                this.ClipList = null;
            },
            /*SoundDefine.Dispose end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "SoundDefine#getHashCode", this ); }

                var h = Bridge.addHash([3577750048, this.soundType, this.Loop, this.Clip, this.ClipList]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "SoundDefine#equals", this ); }

                if (!Bridge.is(o, SoundDefine)) {
                    return false;
                }
                return Bridge.equals(this.soundType, o.soundType) && Bridge.equals(this.Loop, o.Loop) && Bridge.equals(this.Clip, o.Clip) && Bridge.equals(this.ClipList, o.ClipList);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "SoundDefine#$clone", this ); }

                var s = to || new SoundDefine();
                s.soundType = this.soundType;
                s.Loop = this.Loop;
                s.Clip = this.Clip;
                s.ClipList = this.ClipList;
                return s;
            }
        }
    });
    /*SoundDefine end.*/

    /*SoundMixerGroup start.*/
    Bridge.define("SoundMixerGroup", {
        $kind: 6,
        statics: {
            fields: {
                SoundFx: 0,
                Sound: 1,
                MainSound: 2,
                SoundFxInGame: 3,
                SpecialSound: 4
            }
        }
    });
    /*SoundMixerGroup end.*/

    /*SoundType start.*/
    Bridge.define("SoundType", {
        $kind: 6,
        statics: {
            fields: {
                None: 0,
                Button: 1,
                Toggle: 2,
                MouseSystem: 3,
                BackgroundMusic: 4,
                Effect: 5,
                Slider: 6,
                Hide: 7
            }
        }
    });
    /*SoundType end.*/

    /*SoundUIElement start.*/
    Bridge.define("SoundUIElement", {
        inherits: [UnityEngine.MonoBehaviour,UnityEngine.EventSystems.IPointerClickHandler,UnityEngine.EventSystems.ISubmitHandler],
        fields: {
            Sound: null,
            PlayOnEnable: false,
            StopOnDisable: false,
            playWithInteractable: false,
            isPlayRandomBackGroundMusic: false,
            _button: null
        },
        props: {
            button: {
                get: function () {
if ( TRACE ) { TRACE( "SoundUIElement#button#get", this ); }

                    if (UnityEngine.MonoBehaviour.op_Equality(this._button, null)) {
                        this._button = this.GetComponent(UnityEngine.UI.Selectable);
                    }
                    return this._button;
                }
            }
        },
        alias: [
            "OnPointerClick", "UnityEngine$EventSystems$IPointerClickHandler$OnPointerClick",
            "OnSubmit", "UnityEngine$EventSystems$ISubmitHandler$OnSubmit"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "SoundUIElement#init", this ); }

                this.Sound = new SoundDefine();
                this.PlayOnEnable = true;
                this.StopOnDisable = false;
                this.playWithInteractable = false;
                this.isPlayRandomBackGroundMusic = true;
            }
        },
        methods: {
            /*SoundUIElement.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "SoundUIElement#OnEnable", this ); }

                if (this.PlayOnEnable) {
                    switch (this.Sound.soundType) {
                        case SoundType.Effect: 
                            SoundManager.PlaySound(this.Sound);
                            break;
                        case SoundType.BackgroundMusic: 
                            this.PlayBGM();
                            break;
                    }
                }
            },
            /*SoundUIElement.OnEnable end.*/

            /*SoundUIElement.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "SoundUIElement#OnDisable", this ); }

                switch (this.Sound.soundType) {
                    case SoundType.Hide: 
                        SoundManager.PlaySound(this.Sound);
                        break;
                }

                if (this.StopOnDisable) {
                    SoundManager.StopSound(this.Sound);
                }
            },
            /*SoundUIElement.OnDisable end.*/

            /*SoundUIElement.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "SoundUIElement#OnDestroy", this ); }

                this.Sound.Dispose();
                this._button = null;
            },
            /*SoundUIElement.OnDestroy end.*/

            /*SoundUIElement.PlayBGM start.*/
            PlayBGM: function () {
if ( TRACE ) { TRACE( "SoundUIElement#PlayBGM", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = null;
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    if (this.Sound.soundType === SoundType.BackgroundMusic) {
                                            if (this.isPlayRandomBackGroundMusic) {
                                                SoundManager.PlayRandomBGM(this.Sound);
                                            } else {
                                                SoundManager.PlaySound(this.Sound);
                                            }
                                        }

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*SoundUIElement.PlayBGM end.*/

            /*SoundUIElement.OnPointerClick start.*/
            OnPointerClick: function (eventData) {
if ( TRACE ) { TRACE( "SoundUIElement#OnPointerClick", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.button, null) || this.button.enabled === false || !this.button.interactable && !this.playWithInteractable) {
                    return;
                }
                switch (this.Sound.soundType) {
                    case SoundType.Button: 
                        if (eventData.button === UnityEngine.EventSystems.PointerEventData.InputButton.Left) {
                            if (this.Sound.Clip != null) {
                                SoundManager.PlaySound(this.Sound);
                            }
                        }
                        break;
                    case SoundType.Toggle: 
                        if (eventData.button === UnityEngine.EventSystems.PointerEventData.InputButton.Left) {
                            if (this.Sound.Clip != null) {
                                SoundManager.PlaySound(this.Sound);
                            }
                        }
                        break;
                    case SoundType.MouseSystem: 
                        if (eventData.button === UnityEngine.EventSystems.PointerEventData.InputButton.Left) {
                            SoundManager.PlaySound(this.Sound);
                        }
                        break;
                }

            },
            /*SoundUIElement.OnPointerClick end.*/

            /*SoundUIElement.OnSubmit start.*/
            OnSubmit: function (eventData) {
if ( TRACE ) { TRACE( "SoundUIElement#OnSubmit", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.button, null) || !this.button.interactable && !this.playWithInteractable) {
                    return;
                }
                switch (this.Sound.soundType) {
                    case SoundType.Button: 
                        if (UnityEngine.MonoBehaviour.op_Inequality(this.button, null) && this.button.IsActive() && this.button.IsInteractable()) {
                            SoundManager.PlaySound(this.Sound);
                        }
                        break;
                    case SoundType.Toggle: 
                        SoundManager.PlaySound(this.Sound);
                        break;
                }
            },
            /*SoundUIElement.OnSubmit end.*/


        }
    });
    /*SoundUIElement end.*/

    /*SplineDataContainer start.*/
    Bridge.define("SplineDataContainer", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            positions: null,
            tangents: null,
            upVectors: null,
            distances: null,
            totalDistance: 0,
            sampleCount: 0,
            resolution: 0,
            version: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "SplineDataContainer#init", this ); }

                this.version = "1.0";
            }
        },
        methods: {
            /*SplineDataContainer.InitializeArrays start.*/
            InitializeArrays: function (size) {
if ( TRACE ) { TRACE( "SplineDataContainer#InitializeArrays", this ); }

                this.positions = System.Array.init(size, function (){
                    return new UnityEngine.Vector3();
                }, UnityEngine.Vector3);
                this.tangents = System.Array.init(size, function (){
                    return new UnityEngine.Vector3();
                }, UnityEngine.Vector3);
                this.upVectors = System.Array.init(size, function (){
                    return new UnityEngine.Vector3();
                }, UnityEngine.Vector3);
                this.distances = System.Array.init(size, 0, System.Single);
                this.sampleCount = size;
            },
            /*SplineDataContainer.InitializeArrays end.*/

            /*SplineDataContainer.IsValid start.*/
            IsValid: function () {
if ( TRACE ) { TRACE( "SplineDataContainer#IsValid", this ); }

                return this.positions != null && this.tangents != null && this.upVectors != null && this.distances != null && this.positions.length > 0 && this.positions.length === this.tangents.length && this.positions.length === this.upVectors.length && this.positions.length === this.distances.length;
            },
            /*SplineDataContainer.IsValid end.*/


        }
    });
    /*SplineDataContainer end.*/

    /*SplineDataContainerToTransformConverter start.*/
    Bridge.define("SplineDataContainerToTransformConverter", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            splineDataContainer: null,
            pathParent: null,
            pathPointPrefab: null,
            outputTransformPath: null,
            PathCachedObj: null,
            worldSpace: false,
            pathName: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "SplineDataContainerToTransformConverter#init", this ); }

                this.worldSpace = true;
                this.pathName = "ConvertedSplinePath";
            }
        }
    });
    /*SplineDataContainerToTransformConverter end.*/

    /*SplitCollector start.*/
    Bridge.define("SplitCollector", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            LevelCollectorsSetup: null,
            SplitIndex: 0,
            TargetGunner: null
        },
        methods: {
            /*SplitCollector.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "SplitCollector#OnValidate", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.LevelCollectorsSetup, null)) {
                    return;
                }
                if (this.LevelCollectorsSetup.previewSystem.CurrentCollectors.Count <= 0) {
                    return;
                }
                if (this.SplitIndex < 0 || this.SplitIndex >= this.LevelCollectorsSetup.previewSystem.CurrentCollectors.Count) {
                    return;
                }
                this.TargetGunner = this.LevelCollectorsSetup.previewSystem.CurrentCollectors.getItem(this.SplitIndex);
            },
            /*SplitCollector.OnValidate end.*/

            /*SplitCollector.Split start.*/
            Split: function () {
if ( TRACE ) { TRACE( "SplitCollector#Split", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.TargetGunner, null)) {
                    return;
                }

                this.LevelCollectorsSetup.SplitACollector(this.TargetGunner);

                this.TargetGunner.VisualHandler.RefreshColor();

                this.LevelCollectorsSetup.ImportCollectorsFromScene();
                this.LevelCollectorsSetup.BakeCollectorsPositionInTool();

                this.LevelCollectorsSetup.Save();
            },
            /*SplitCollector.Split end.*/

            /*SplitCollector.Split$1 start.*/
            Split$1: function (target) {
if ( TRACE ) { TRACE( "SplitCollector#Split$1", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(target, null)) {
                    return;
                }

                this.LevelCollectorsSetup.SplitACollector(target);

                target.VisualHandler.RefreshColor();

                this.LevelCollectorsSetup.ImportCollectorsFromScene();
                this.LevelCollectorsSetup.BakeCollectorsPositionInTool();

                this.LevelCollectorsSetup.Save();
            },
            /*SplitCollector.Split$1 end.*/

            /*SplitCollector.IsInFrontOf start.*/
            IsInFrontOf: function (first, second) {
if ( TRACE ) { TRACE( "SplitCollector#IsInFrontOf", this ); }

                var dirToFirst = first.position.$clone().sub( second.position );
                var dot = second.forward.dot( dirToFirst );
                return dot > 0.0;
            },
            /*SplitCollector.IsInFrontOf end.*/


        },
        overloads: {
            "Split(ColorPixelsCollectorObject)": "Split$1"
        }
    });
    /*SplitCollector end.*/

    /*SwapCollectors start.*/
    Bridge.define("SwapCollectors", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            LevelCollectorsSetup: null,
            SwapIndexOne: 0,
            SwapIndexTwo: 0,
            Gunner0ne: null,
            GunnerTwo: null
        },
        methods: {
            /*SwapCollectors.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "SwapCollectors#OnValidate", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.LevelCollectorsSetup, null)) {
                    return;
                }
                if (this.LevelCollectorsSetup.previewSystem.CurrentCollectors.Count <= 0) {
                    return;
                }
                if (this.SwapIndexOne < 0 || this.SwapIndexOne >= this.LevelCollectorsSetup.previewSystem.CurrentCollectors.Count) {
                    return;
                }
                if (this.SwapIndexTwo < 0 || this.SwapIndexTwo >= this.LevelCollectorsSetup.previewSystem.CurrentCollectors.Count) {
                    return;
                }
                this.Gunner0ne = this.LevelCollectorsSetup.previewSystem.CurrentCollectors.getItem(this.SwapIndexOne);
                this.GunnerTwo = this.LevelCollectorsSetup.previewSystem.CurrentCollectors.getItem(this.SwapIndexTwo);
            },
            /*SwapCollectors.OnValidate end.*/

            /*SwapCollectors.Swap start.*/
            Swap: function () {
if ( TRACE ) { TRACE( "SwapCollectors#Swap", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.Gunner0ne, null) || UnityEngine.MonoBehaviour.op_Equality(this.GunnerTwo, null)) {
                    return;
                }

                var gunnerOneLocked = this.Gunner0ne.IsLocked;
                var gunnerOneHidden = this.Gunner0ne.IsHidden;
                var gunnerOneBullets = this.Gunner0ne.BulletCapacity;
                var gunnerOneColor = this.Gunner0ne.CollectorColor;
                var gunnerOnecCurrentColor = this.Gunner0ne.VisualHandler.CurrentColor.$clone();

                var gunnerTwoLocked = this.GunnerTwo.IsLocked;
                var gunnerTwoHidden = this.GunnerTwo.IsHidden;
                var gunnerTwoBullets = this.GunnerTwo.BulletCapacity;
                var gunnerTwoColor = this.GunnerTwo.CollectorColor;
                var gunnerTwocCurrentColor = this.GunnerTwo.VisualHandler.CurrentColor.$clone();

                this.Gunner0ne.IsLocked = gunnerTwoLocked;
                this.Gunner0ne.IsHidden = gunnerTwoHidden;
                this.Gunner0ne.CollectorColor = gunnerTwoColor;
                this.Gunner0ne.BulletCapacity = gunnerTwoBullets;
                this.Gunner0ne.VisualHandler.CurrentColor = gunnerTwocCurrentColor.$clone();

                this.GunnerTwo.IsLocked = gunnerOneLocked;
                this.GunnerTwo.IsHidden = gunnerOneHidden;
                this.GunnerTwo.CollectorColor = gunnerOneColor;
                this.GunnerTwo.BulletCapacity = gunnerOneBullets;
                this.GunnerTwo.VisualHandler.CurrentColor = gunnerOnecCurrentColor.$clone();

                this.Gunner0ne.VisualHandler.RefreshColor();
                this.GunnerTwo.VisualHandler.RefreshColor();

                this.LevelCollectorsSetup.ImportCollectorsFromScene();

                this.LevelCollectorsSetup.Save();
            },
            /*SwapCollectors.Swap end.*/

            /*SwapCollectors.Swap$1 start.*/
            Swap$1: function (first, second) {
if ( TRACE ) { TRACE( "SwapCollectors#Swap$1", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(first, null) || UnityEngine.MonoBehaviour.op_Equality(second, null)) {
                    return;
                }

                this.LevelCollectorsSetup.SwapCollectors(first, second);
                this.LevelCollectorsSetup.ImportCollectorsFromScene();
                this.LevelCollectorsSetup.BakeCollectorsPositionInTool();

                this.LevelCollectorsSetup.Save();
            },
            /*SwapCollectors.Swap$1 end.*/


        },
        overloads: {
            "Swap(CollectorMachanicObjectBase, CollectorMachanicObjectBase)": "Swap$1"
        }
    });
    /*SwapCollectors end.*/

    /*TutorialLayer start.*/
    Bridge.define("TutorialLayer", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            handTrans: null,
            handImage: null,
            handSprites: null,
            tutorialText: null,
            flareImage: null,
            canvas: null,
            playAnim: false,
            tweenScaleText: null,
            swapHandCoroutine: null,
            flareCoroutine: null,
            spriteIndex: 0
        },
        methods: {
            /*TutorialLayer.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "TutorialLayer#OnEnable", this ); }

                GameplayEventsManager.OnCollectorStartMove = Bridge.fn.combine(GameplayEventsManager.OnCollectorStartMove, Bridge.fn.cacheBind(this, this.OnCollectorStartMove));
            },
            /*TutorialLayer.OnEnable end.*/

            /*TutorialLayer.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "TutorialLayer#OnDisable", this ); }

                GameplayEventsManager.OnCollectorStartMove = Bridge.fn.remove(GameplayEventsManager.OnCollectorStartMove, Bridge.fn.cacheBind(this, this.OnCollectorStartMove));
                this.StopAllCoroutinesSafe();
                this.tweenScaleText != null ? DG.Tweening.TweenExtensions.Kill(this.tweenScaleText) : null;
            },
            /*TutorialLayer.OnDisable end.*/

            /*TutorialLayer.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "TutorialLayer#Start", this ); }

                this.InitLayer();
                this.ShowLayer();
            },
            /*TutorialLayer.Start end.*/

            /*TutorialLayer.InitLayer start.*/
            InitLayer: function () {
if ( TRACE ) { TRACE( "TutorialLayer#InitLayer", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.handImage, null) && this.handSprites != null && this.handSprites.length > 0) {
                    this.spriteIndex = 0;
                    this.handImage.sprite = this.handSprites[0];
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.tutorialText, null)) {
                    this.tutorialText.text = "Tap the cat to place into the conveyor";
                }

                this.StartScaleText();

                // try position once (best-effort)
                var first = !Bridge.staticEquals(GameplayEventsManager.GetFirstCollector, null) ? GameplayEventsManager.GetFirstCollector() : null;
                if (UnityEngine.Component.op_Inequality(first, null) && UnityEngine.Component.op_Inequality(this.handTrans, null) && UnityEngine.Component.op_Inequality(this.canvas, null)) {
                    this.handTrans.anchoredPosition = this.WorldToCanvasLocalPosition(this.canvas, UnityEngine.Camera.main, first.position);
                    this.handTrans.gameObject.SetActive(true);
                }
            },
            /*TutorialLayer.InitLayer end.*/

            /*TutorialLayer.ShowLayer start.*/
            ShowLayer: function () {
if ( TRACE ) { TRACE( "TutorialLayer#ShowLayer", this ); }

                this.playAnim = true;
                if (this.swapHandCoroutine != null) {
                    this.StopCoroutine$2(this.swapHandCoroutine);
                }
                this.swapHandCoroutine = this.StartCoroutine$1(this.SwapHandSpriteCoroutine());
            },
            /*TutorialLayer.ShowLayer end.*/

            /*TutorialLayer.HideLayer start.*/
            HideLayer: function () {
if ( TRACE ) { TRACE( "TutorialLayer#HideLayer", this ); }

                this.playAnim = false;
                this.StopAllCoroutinesSafe();
                this.tweenScaleText != null ? DG.Tweening.TweenExtensions.Kill(this.tweenScaleText) : null;
            },
            /*TutorialLayer.HideLayer end.*/

            /*TutorialLayer.SwapHandSpriteCoroutine start.*/
            SwapHandSpriteCoroutine: function () {
if ( TRACE ) { TRACE( "TutorialLayer#SwapHandSpriteCoroutine", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if (UnityEngine.MonoBehaviour.op_Equality(this.handImage, null) || this.handSprites == null || this.handSprites.length === 0) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 2;
                                        continue;
                                }
                                case 1: {
                                    return false;
                                }
                                case 2: {
                                    if ( this.playAnim ) {
                                            $step = 3;
                                            continue;
                                        } 
                                        $step = 5;
                                        continue;
                                }
                                case 3: {
                                    this.handImage.sprite = this.handSprites[this.spriteIndex];
                                        this.spriteIndex = (((this.spriteIndex + 1) | 0)) % this.handSprites.length;

                                        if (this.spriteIndex === 1) {
                                            if (this.flareCoroutine != null) {
                                                this.StopCoroutine$2(this.flareCoroutine);
                                            }
                                            this.flareCoroutine = this.StartCoroutine$1(this.FlareEffectCoroutine());
                                        }

                                        $enumerator.current = new UnityEngine.WaitForSeconds(0.5);
                                        $step = 4;
                                        return true;
                                }
                                case 4: {
                                    
                                        $step = 2;
                                        continue;
                                }
                                case 5: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*TutorialLayer.SwapHandSpriteCoroutine end.*/

            /*TutorialLayer.FlareEffectCoroutine start.*/
            FlareEffectCoroutine: function () {
if ( TRACE ) { TRACE( "TutorialLayer#FlareEffectCoroutine", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    rt,
                    c,
                    d,
                    t,
                    p,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if (UnityEngine.MonoBehaviour.op_Equality(this.flareImage, null)) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 2;
                                        continue;
                                }
                                case 1: {
                                    return false;
                                }
                                case 2: {
                                    this.flareImage.gameObject.SetActive(true);
                                        rt = this.flareImage.rectTransform;
                                        rt.localScale = pc.Vec3.ZERO.clone();
                                        c = this.flareImage.color.$clone();
                                        c.a = 1.0;
                                        this.flareImage.color = c.$clone();

                                        d = 0.3;
                                        t = 0.0;
                                    $step = 3;
                                    continue;
                                }
                                case 3: {
                                    if ( t < d ) {
                                            $step = 4;
                                            continue;
                                        } 
                                        $step = 6;
                                        continue;
                                }
                                case 4: {
                                    t += UnityEngine.Time.deltaTime;
                                        p = Math.max(0, Math.min(1, t / d));
                                        rt.localScale = new pc.Vec3( 1, 1, 1 ).clone().scale( pc.math.lerp(0.0, 1.0, p) );
                                        c.a = pc.math.lerp(1.0, 0.0, p);
                                        this.flareImage.color = c.$clone();
                                        $enumerator.current = null;
                                        $step = 5;
                                        return true;
                                }
                                case 5: {
                                    
                                        $step = 3;
                                        continue;
                                }
                                case 6: {
                                    rt.localScale = new pc.Vec3( 1, 1, 1 );
                                        c.a = 0.0;
                                        this.flareImage.color = c.$clone();
                                        this.flareImage.gameObject.SetActive(false);
                                        this.flareCoroutine = null;

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*TutorialLayer.FlareEffectCoroutine end.*/

            /*TutorialLayer.StartScaleText start.*/
            StartScaleText: function () {
if ( TRACE ) { TRACE( "TutorialLayer#StartScaleText", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.tutorialText, null)) {
                    return;
                }
                this.tweenScaleText = DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.tutorialText.rectTransform$1, new pc.Vec3( 1, 1, 1 ).clone().scale( 1.1 ), 0.7), DG.Tweening.Ease.InOutSine), -1, DG.Tweening.LoopType.Yoyo);
            },
            /*TutorialLayer.StartScaleText end.*/

            /*TutorialLayer.OnCollectorStartMove start.*/
            OnCollectorStartMove: function (obj) {
if ( TRACE ) { TRACE( "TutorialLayer#OnCollectorStartMove", this ); }

                GameplayEventsManager.OnCollectorStartMove = Bridge.fn.remove(GameplayEventsManager.OnCollectorStartMove, Bridge.fn.cacheBind(this, this.OnCollectorStartMove));
                this.gameObject.SetActive(false);
                Luna.Unity.LifeCycle.GameUpdated();
            },
            /*TutorialLayer.OnCollectorStartMove end.*/

            /*TutorialLayer.StopAllCoroutinesSafe start.*/
            StopAllCoroutinesSafe: function () {
if ( TRACE ) { TRACE( "TutorialLayer#StopAllCoroutinesSafe", this ); }

                if (this.swapHandCoroutine != null) {
                    this.StopCoroutine$2(this.swapHandCoroutine);
                    this.swapHandCoroutine = null;
                }
                if (this.flareCoroutine != null) {
                    this.StopCoroutine$2(this.flareCoroutine);
                    this.flareCoroutine = null;
                }
            },
            /*TutorialLayer.StopAllCoroutinesSafe end.*/

            /*TutorialLayer.WorldToCanvasLocalPosition start.*/
            WorldToCanvasLocalPosition: function (targetCanvas, cam, worldPos) {
if ( TRACE ) { TRACE( "TutorialLayer#WorldToCanvasLocalPosition", this ); }

                if (UnityEngine.Component.op_Equality(targetCanvas, null)) {
                    return pc.Vec2.ZERO.clone();
                }
                var canvasRect = targetCanvas.GetComponent(UnityEngine.RectTransform);
                var screenPoint = UnityEngine.RectTransformUtility.WorldToScreenPoint(cam || UnityEngine.Camera.main, worldPos);
                var localPoint = { v : new UnityEngine.Vector2() };
                UnityEngine.RectTransformUtility.ScreenPointToLocalPointInRectangle(canvasRect, screenPoint, targetCanvas.renderMode === UnityEngine.RenderMode.ScreenSpaceOverlay ? null : (cam || UnityEngine.Camera.main), localPoint);
                return localPoint.v.$clone();
            },
            /*TutorialLayer.WorldToCanvasLocalPosition end.*/


        }
    });
    /*TutorialLayer end.*/

    /*WallObject start.*/
    Bridge.define("WallObject", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            WallTransform: null,
            PaintingPixelsCovered: null,
            ColorCode: null,
            Hearts: 0,
            HeartsLoss: 0,
            RemainingHearts: 0,
            WallRenderer: null,
            HeartsText: null,
            Destroyed$1: false,
            WorldPos: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "WallObject#init", this ); }

                this.WorldPos = new UnityEngine.Vector3();
            }
        },
        methods: {
            /*WallObject.Initialize start.*/
            Initialize: function (pipePixels, heart, color, colorCode) {
if ( TRACE ) { TRACE( "WallObject#Initialize", this ); }

                var $t;
                this.Destroyed$1 = false;
                this.PaintingPixelsCovered = pipePixels != null ? pipePixels : new (System.Collections.Generic.List$1(PaintingPixel)).ctor();
                this.Hearts = 0;
                if (heart > 0) {
                    this.Hearts = heart;
                } else {
                    $t = Bridge.getEnumerator(this.PaintingPixelsCovered);
                    try {
                        while ($t.moveNext()) {
                            var pixel = $t.Current;
                            this.Hearts = (this.Hearts + pixel.Hearts) | 0;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
                this.HeartsLoss = 0;
                this.RemainingHearts = this.Hearts;
                this.HeartsText.text = Bridge.toString(this.RemainingHearts);
                this.ColorCode = colorCode;
                this.AssignPaletteSharedMaterial();
            },
            /*WallObject.Initialize end.*/

            /*WallObject.OnAPixelDestroyed start.*/
            OnAPixelDestroyed: function () {
if ( TRACE ) { TRACE( "WallObject#OnAPixelDestroyed", this ); }

                var $t, $t1;
                if (this.Destroyed$1) {
                    return;
                }
                this.HeartsLoss = (this.HeartsLoss + 1) | 0;
                this.RemainingHearts = (this.RemainingHearts - 1) | 0;
                this.RemainingHearts = Math.max(0, Math.min(this.RemainingHearts, 2147483647));
                this.HeartsText.enabled = this.RemainingHearts > 0;
                this.HeartsText.text = Bridge.toString(this.RemainingHearts);
                if (this.RemainingHearts <= 0) {
                    $t = Bridge.getEnumerator(this.PaintingPixelsCovered);
                    try {
                        while ($t.moveNext()) {
                            var pixel = $t.Current;
                            pixel.DestroyPixel(false, void 0);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    this.OnDestroyed();
                    this.Destroyed$1 = true;
                    return;
                }
                $t1 = Bridge.getEnumerator(this.PaintingPixelsCovered);
                try {
                    while ($t1.moveNext()) {
                        var pixel1 = $t1.Current;
                        pixel1.destroyed = false;
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }
            },
            /*WallObject.OnAPixelDestroyed end.*/

            /*WallObject.OnDestroyed start.*/
            OnDestroyed: function () {
if ( TRACE ) { TRACE( "WallObject#OnDestroyed", this ); }

                DG.Tweening.ShortcutExtensions.DOScale(this.WallTransform, 0, 0.25);
            },
            /*WallObject.OnDestroyed end.*/

            /*WallObject.SelfDestroy start.*/
            SelfDestroy: function () {
if ( TRACE ) { TRACE( "WallObject#SelfDestroy", this ); }

                var $t;
                this.HeartsText.enabled = false;
                $t = Bridge.getEnumerator(this.PaintingPixelsCovered);
                try {
                    while ($t.moveNext()) {
                        var pixel = $t.Current;
                        pixel.DestroyPixel(false, void 0);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.Destroyed$1 = true;
                this.OnDestroyed();
            },
            /*WallObject.SelfDestroy end.*/

            /*WallObject.SelfDestroyGameObject start.*/
            SelfDestroyGameObject: function () {
if ( TRACE ) { TRACE( "WallObject#SelfDestroyGameObject", this ); }

                if (UnityEngine.Application.isPlaying) {
                    UnityEngine.Object.Destroy(this.gameObject);
                } else {
                    UnityEngine.Object.DestroyImmediate(this.gameObject);
                }
            },
            /*WallObject.SelfDestroyGameObject end.*/

            /*WallObject.ApplyPosition start.*/
            ApplyPosition: function () {
if ( TRACE ) { TRACE( "WallObject#ApplyPosition", this ); }

                this.WallTransform.position = this.WorldPos.$clone();
            },
            /*WallObject.ApplyPosition end.*/

            /*WallObject.AssignPaletteSharedMaterial start.*/
            AssignPaletteSharedMaterial: function () {
if ( TRACE ) { TRACE( "WallObject#AssignPaletteSharedMaterial", this ); }

                var $t;
                if (UnityEngine.Component.op_Equality(this.WallRenderer, null)) {
                    return;
                }
                if (this.PaintingPixelsCovered == null || this.PaintingPixelsCovered.Count === 0) {
                    return;
                }
                var mat = ($t = this.PaintingPixelsCovered.getItem(0)) != null ? $t.Material : null;
                if (mat != null) {
                    this.WallRenderer.sharedMaterial = mat;
                }
            },
            /*WallObject.AssignPaletteSharedMaterial end.*/

            /*WallObject.RefreshPaletteMaterial start.*/
            RefreshPaletteMaterial: function () {
if ( TRACE ) { TRACE( "WallObject#RefreshPaletteMaterial", this ); }

                this.AssignPaletteSharedMaterial();
            },
            /*WallObject.RefreshPaletteMaterial end.*/


        }
    });
    /*WallObject end.*/

    /*WallObjectSetup start.*/
    Bridge.define("WallObjectSetup", {
        fields: {
            Hearts: 0,
            PixelCovered: null,
            ColorCode: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "WallObjectSetup#ctor", this ); }

                this.$initialize();
                this.PixelCovered = new (System.Collections.Generic.List$1(PaintingPixelConfig)).ctor();
                this.ColorCode = "";
            },
            $ctor1: function (pixelCovered, colorCode, hearts) {
if ( TRACE ) { TRACE( "WallObjectSetup#$ctor1", this ); }

                this.$initialize();
                this.Hearts = hearts;
                this.ColorCode = colorCode;
                this.PixelCovered = pixelCovered != null ? new (System.Collections.Generic.List$1(PaintingPixelConfig)).$ctor1(pixelCovered) : new (System.Collections.Generic.List$1(PaintingPixelConfig)).ctor();
            },
            $ctor2: function (_stock) {
if ( TRACE ) { TRACE( "WallObjectSetup#$ctor2", this ); }

                var $t;
                this.$initialize();
                this.Hearts = _stock.Hearts;
                this.ColorCode = _stock.ColorCode;
                this.PixelCovered = new (System.Collections.Generic.List$1(PaintingPixelConfig)).ctor();
                $t = Bridge.getEnumerator(_stock.PixelCovered);
                try {
                    while ($t.moveNext()) {
                        var pixel = $t.Current;
                        this.PixelCovered.add(new PaintingPixelConfig.$ctor2(pixel));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            }
        }
    });
    /*WallObjectSetup end.*/

    /*ColorPixelsCollectorObject start.*/
    Bridge.define("ColorPixelsCollectorObject", {
        inherits: [CollectorMachanicObjectBase],
        fields: {
            RabbitRootTransform: null,
            RabbitRotateTransform: null,
            VisualHandler: null,
            CollectorAnimator: null,
            CurrentState: 0,
            MovementHandle: null,
            NormalSpeed: 0,
            AbsoluteWinSpeed: 0,
            CurrentGrid: null,
            BulletCapacity: 0,
            BulletLeft: 0,
            CollectorColor: null,
            DetectionRadius: 0,
            IsLocked: false,
            IsHidden: false,
            ConnectedCollectorsIDs: null,
            IsCollectorActive: false,
            CurrentTargetPosition: null,
            currentMovementDirection: 0,
            previousMovementDirection: null,
            CurrentColor: null,
            possibleTargets: null,
            bulletDisplayHandler: null,
            possibleTargetsCount: 0,
            tempOutlinePixelsList: null,
            cachedRotation: null,
            cachedTargets: null,
            maxTargetCapacity: 0,
            AbsoluteCheckRate: 0,
            currentFrameCount: 0,
            dead: false,
            IsHided: false,
            hasRotated: false,
            processedHorizontalPositions: null,
            processedVerticalPositions: null,
            OnCompleteAllColorPixels: null,
            CheckIntervalFrames: 0,
            MinMoveDistance: 0,
            _frameCounter: 0,
            _lastCheckPosition: null,
            _minMoveDistanceSqr: 0
        },
        props: {
            Available: {
                get: function () {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#Available#get", this ); }

                    return this.BulletLeft > 0;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#init", this ); }

                this.CurrentTargetPosition = new UnityEngine.Vector3();
                this.previousMovementDirection = new UnityEngine.Vector3();
                this.CurrentColor = new UnityEngine.Color();
                this.cachedRotation = new UnityEngine.Vector3();
                this._lastCheckPosition = new UnityEngine.Vector3();
                this.CurrentState = ColorPixelsCollectorObject.State.Normal;
                this.NormalSpeed = 10;
                this.AbsoluteWinSpeed = 10;
                this.BulletCapacity = 10;
                this.CollectorColor = "WhiteDefault";
                this.DetectionRadius = 0.5;
                this.IsCollectorActive = true;
                this.currentMovementDirection = MovementDirection.Unknown;
                this.previousMovementDirection = pc.Vec3.ZERO.clone();
                this.tempOutlinePixelsList = new (System.Collections.Generic.List$1(PaintingPixel)).ctor();
                this.cachedRotation = new pc.Vec3( 0, -90, 0 );
                this.maxTargetCapacity = 0;
                this.AbsoluteCheckRate = 5;
                this.currentFrameCount = 0;
                this.dead = false;
                this.IsHided = false;
                this.hasRotated = false;
                this.processedHorizontalPositions = new (System.Collections.Generic.HashSet$1(System.Int32)).ctor();
                this.processedVerticalPositions = new (System.Collections.Generic.HashSet$1(System.Int32)).ctor();
                this.CheckIntervalFrames = 5;
                this.MinMoveDistance = 0.1;
                this._frameCounter = 0;
            }
        },
        methods: {
            /*ColorPixelsCollectorObject.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#Awake", this ); }

                this.RegisterEvents();
            },
            /*ColorPixelsCollectorObject.Awake end.*/

            /*ColorPixelsCollectorObject.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#Start", this ); }

                this.InitializeCollector();
            },
            /*ColorPixelsCollectorObject.Start end.*/

            /*ColorPixelsCollectorObject.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#OnDisable", this ); }

                this.UnregisterEvents();
            },
            /*ColorPixelsCollectorObject.OnDisable end.*/

            /*ColorPixelsCollectorObject.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#OnDestroy", this ); }

                this.UnregisterEvents();
            },
            /*ColorPixelsCollectorObject.OnDestroy end.*/

            /*ColorPixelsCollectorObject.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#Update", this ); }

                if (!this.IsCollectorActive || this.BulletLeft <= 0) {
                    return;
                }

                if (this.CurrentState === ColorPixelsCollectorObject.State.AbsoluteWin) {
                    this.currentFrameCount = (this.currentFrameCount + 1) | 0;
                    if (this.currentFrameCount >= this.AbsoluteCheckRate) {
                        this.CurrentGrid.UpdateOutlinePixels();
                        this.UpdatePossibleTargets();
                        this.currentFrameCount = 0;
                    }
                }

                // Check for movement direction change to reset processed positions
                this.CheckMovementDirectionChange();

                // OPTIMIZED: Throttle checks
                this._frameCounter = (this._frameCounter + 1) | 0;
                if (this._frameCounter >= this.CheckIntervalFrames) {
                    // Check distance moved
                    var distSqr = (this.RabbitRootTransform.position.$clone().sub( this._lastCheckPosition )).lengthSq();
                    if (distSqr >= this._minMoveDistanceSqr) {
                        this.CheckAndDestroyNearbyPixels();
                        this._frameCounter = 0;
                        this._lastCheckPosition = this.RabbitRootTransform.position.$clone();
                    }
                }
            },
            /*ColorPixelsCollectorObject.Update end.*/

            /*ColorPixelsCollectorObject.RegisterEvents start.*/
            RegisterEvents: function () {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#RegisterEvents", this ); }

                GameplayEventsManager.OnGridObjectChanged = Bridge.fn.combine(GameplayEventsManager.OnGridObjectChanged, Bridge.fn.cacheBind(this, this.OnGridPixelsChanged));
                GameplayEventsManager.OnPaintingInitializeDone = Bridge.fn.combine(GameplayEventsManager.OnPaintingInitializeDone, Bridge.fn.cacheBind(this, this.OnGridPaintingObjectInitialized));
            },
            /*ColorPixelsCollectorObject.RegisterEvents end.*/

            /*ColorPixelsCollectorObject.UnregisterEvents start.*/
            UnregisterEvents: function () {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#UnregisterEvents", this ); }

                GameplayEventsManager.OnGridObjectChanged = Bridge.fn.remove(GameplayEventsManager.OnGridObjectChanged, Bridge.fn.cacheBind(this, this.OnGridPixelsChanged));
                GameplayEventsManager.OnPaintingInitializeDone = Bridge.fn.remove(GameplayEventsManager.OnPaintingInitializeDone, Bridge.fn.cacheBind(this, this.OnGridPaintingObjectInitialized));
            },
            /*ColorPixelsCollectorObject.UnregisterEvents end.*/

            /*ColorPixelsCollectorObject.OnGridPixelsChanged start.*/
            OnGridPixelsChanged: function (changedGrid) {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#OnGridPixelsChanged", this ); }

                // Only update if this collector is targeting the changed grid and is active
                if (UnityEngine.MonoBehaviour.op_Equality(changedGrid, this.CurrentGrid) && this.IsCollectorActive) {
                    this.UpdatePossibleTargets();
                }
            },
            /*ColorPixelsCollectorObject.OnGridPixelsChanged end.*/

            /*ColorPixelsCollectorObject.OnGridPaintingObjectInitialized start.*/
            OnGridPaintingObjectInitialized: function (_gridObject) {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#OnGridPaintingObjectInitialized", this ); }

                this.CurrentGrid = _gridObject;
                this.InitializeCollector();
            },
            /*ColorPixelsCollectorObject.OnGridPaintingObjectInitialized end.*/

            /*ColorPixelsCollectorObject.OnAbsoluteWin start.*/
            OnAbsoluteWin: function (isMoving) {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#OnAbsoluteWin", this ); }

                this.CurrentState = ColorPixelsCollectorObject.State.AbsoluteWin;
                if (isMoving) {
                    this.SetStatusAttributes();
                }
            },
            /*ColorPixelsCollectorObject.OnAbsoluteWin end.*/

            /*ColorPixelsCollectorObject.SetCollectorActive start.*/
            SetCollectorActive: function (active) {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#SetCollectorActive", this ); }

                this.SetActiveCollector(active);

                if (UnityEngine.MonoBehaviour.op_Inequality(this.MovementHandle, null)) {
                    if (active) {
                        this.MovementHandle.StartMovement();

                        // Update movement direction after activation
                        if (this.MovementHandle.IsPathValid()) {
                            var initialDirection = this.MovementHandle.GetTangentAtTF(this.MovementHandle.currentTF);
                            this.previousMovementDirection = initialDirection.$clone();
                            this.currentMovementDirection = this.DetermineMovementDirection(initialDirection);
                        }

                        this.SetStatusAttributes();
                    } else {
                        this.MovementHandle.StopMovement();
                        // Clear processed positions when deactivating
                        this.processedHorizontalPositions.clear();
                        this.processedVerticalPositions.clear();
                    }
                }
            },
            /*ColorPixelsCollectorObject.SetCollectorActive end.*/

            /*ColorPixelsCollectorObject.SetStatusAttributes start.*/
            SetStatusAttributes: function () {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#SetStatusAttributes", this ); }

                if (this.CurrentState === ColorPixelsCollectorObject.State.AbsoluteWin) {
                    var connectedOnBelt = !this.IsCollectorActive && !this.IsHided;
                    if (this.IsCollectorActive || connectedOnBelt) {
                        UnityEngine.MonoBehaviour.op_Inequality(this.VisualHandler, null) ? this.VisualHandler.StartTrailHighSpeed() : null;
                        UnityEngine.MonoBehaviour.op_Inequality(this.MovementHandle, null) ? this.MovementHandle.SetSpeed(this.AbsoluteWinSpeed) : null;
                        UnityEngine.MonoBehaviour.op_Inequality(this.MovementHandle, null) ? this.MovementHandle.ChangeMovementType(CachedTransformPathMover.MovementType.Loop) : null;
                    }
                } else {
                    UnityEngine.MonoBehaviour.op_Inequality(this.VisualHandler, null) ? this.VisualHandler.StopTrailHighSpeed() : null;
                    UnityEngine.MonoBehaviour.op_Inequality(this.MovementHandle, null) ? this.MovementHandle.SetSpeed(this.NormalSpeed) : null;
                    UnityEngine.MonoBehaviour.op_Inequality(this.MovementHandle, null) ? this.MovementHandle.ChangeMovementType(CachedTransformPathMover.MovementType.Clamp) : null;
                }
            },
            /*ColorPixelsCollectorObject.SetStatusAttributes end.*/

            /*ColorPixelsCollectorObject.Unlock start.*/
            Unlock: function () {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#Unlock", this ); }

                this.IsLocked = false;
                this.ApplyLockedState();
            },
            /*ColorPixelsCollectorObject.Unlock end.*/

            /*ColorPixelsCollectorObject.OnStartMove start.*/
            OnStartMove: function () {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#OnStartMove", this ); }

                this.hasRotated = false;
            },
            /*ColorPixelsCollectorObject.OnStartMove end.*/

            /*ColorPixelsCollectorObject.Reveal start.*/
            Reveal: function () {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#Reveal", this ); }

                this.IsHidden = false;
                this.VisualHandler.SetHiddenState(false, false);
                !Bridge.staticEquals(GameplayEventsManager.OnCollectorRevealed, null) ? GameplayEventsManager.OnCollectorRevealed(this) : null;
            },
            /*ColorPixelsCollectorObject.Reveal end.*/

            /*ColorPixelsCollectorObject.InitializeCollector start.*/
            InitializeCollector: function () {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#InitializeCollector", this ); }

                this.BulletLeft = this.BulletCapacity;
                UnityEngine.MonoBehaviour.op_Inequality(this.bulletDisplayHandler, null) ? this.bulletDisplayHandler.UpdateBulletDisplay(this.BulletLeft) : null;

                if (UnityEngine.MonoBehaviour.op_Inequality(this.MovementHandle, null)) {
                    //MovementHandle.StartMovement();
                    // Initialize the previous movement direction
                    if (this.MovementHandle.IsPathValid()) {
                        var initialDirection = this.MovementHandle.GetTangentAtTF(this.MovementHandle.currentTF);
                        this.previousMovementDirection = initialDirection.$clone();
                        this.currentMovementDirection = this.DetermineMovementDirection(initialDirection);
                    }
                }
                this.CurrentState = ColorPixelsCollectorObject.State.Normal;
                UnityEngine.MonoBehaviour.op_Inequality(this.VisualHandler, null) ? this.VisualHandler.StopTrailHighSpeed() : null;
                UnityEngine.MonoBehaviour.op_Inequality(this.MovementHandle, null) ? this.MovementHandle.SetSpeed(this.NormalSpeed) : null;
                UnityEngine.MonoBehaviour.op_Inequality(this.MovementHandle, null) ? this.MovementHandle.ChangeMovementType(CachedTransformPathMover.MovementType.Clamp) : null;
                this.UpdatePossibleTargets();

                // Initialize optimization variables
                this._minMoveDistanceSqr = this.MinMoveDistance * this.MinMoveDistance;
                this._lastCheckPosition = this.RabbitRootTransform.position.$clone();
                this._frameCounter = UnityEngine.Random.Range(0, this.CheckIntervalFrames); // Randomize start to distribute load
            },
            /*ColorPixelsCollectorObject.InitializeCollector end.*/

            /*ColorPixelsCollectorObject.SetActiveCollector start.*/
            SetActiveCollector: function (active) {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#SetActiveCollector", this ); }

                this.IsCollectorActive = active;
                if (this.IsCollectorActive) {
                    this.UpdatePossibleTargets();
                }
            },
            /*ColorPixelsCollectorObject.SetActiveCollector end.*/

            /*ColorPixelsCollectorObject.CheckMovementDirectionChange start.*/
            CheckMovementDirectionChange: function () {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#CheckMovementDirectionChange", this ); }

                if (this.MovementHandle.IsPathValid()) {
                    var rawMovementDirection = this.MovementHandle.GetTangentAtTF(this.MovementHandle.currentTF);

                    // Only consider significant direction changes (not minor fluctuations)
                    if (!pc.Vec3.equals( rawMovementDirection, pc.Vec3.ZERO.clone() )) {
                        // Determine the new movement direction based on the tangent vector
                        var newMovementDirection = this.DetermineMovementDirection(rawMovementDirection);

                        // Check if the primary axis of movement has changed
                        var wasHorizontal = this.IsHorizontalDirection(this.currentMovementDirection);
                        var isHorizontal = this.IsHorizontalDirection(newMovementDirection);

                        // If movement direction has changed significantly (from horizontal to vertical or vice versa)
                        if (wasHorizontal !== isHorizontal) {
                            // Reset the appropriate processed positions
                            if (wasHorizontal) {
                                this.processedHorizontalPositions.clear(); // Clear row tracking when switching from horizontal to vertical
                            } else {
                                this.processedVerticalPositions.clear(); // Clear column tracking when switching from vertical to horizontal
                            }
                        }

                        // Update the current movement direction
                        this.currentMovementDirection = newMovementDirection;
                        this.previousMovementDirection = rawMovementDirection.$clone();
                    }
                }
            },
            /*ColorPixelsCollectorObject.CheckMovementDirectionChange end.*/

            /*ColorPixelsCollectorObject.DetermineMovementDirection start.*/
            DetermineMovementDirection: function (tangent) {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#DetermineMovementDirection", this ); }

                // Check if movement is primarily horizontal or vertical
                // Using direct comparison to avoid Mathf.Abs calls which can be slightly slower
                var absX = tangent.x >= 0 ? tangent.x : -tangent.x;
                var absZ = tangent.z >= 0 ? tangent.z : -tangent.z;

                if (absX > absZ) {
                    // Horizontal movement
                    if (tangent.x > 0) {
                        return MovementDirection.HorizontalRightToLeft; // Moving in positive X direction (right to left)
                    } else {
                        return MovementDirection.HorizontalLeftToRight; // Moving in negative X direction (left to right)
                    }
                } else {
                    // Vertical movement
                    if (tangent.z > 0) {
                        return MovementDirection.VerticalTopToBottom; // Moving in positive Z direction (top to bottom)
                    } else {
                        return MovementDirection.VerticalBottomToTop; // Moving in negative Z direction (bottom to top)
                    }
                }
            },
            /*ColorPixelsCollectorObject.DetermineMovementDirection end.*/

            /*ColorPixelsCollectorObject.IsHorizontalDirection start.*/
            IsHorizontalDirection: function (direction) {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#IsHorizontalDirection", this ); }

                return direction === MovementDirection.HorizontalLeftToRight || direction === MovementDirection.HorizontalRightToLeft;
            },
            /*ColorPixelsCollectorObject.IsHorizontalDirection end.*/

            /*ColorPixelsCollectorObject.IsVerticalDirection start.*/
            IsVerticalDirection: function (direction) {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#IsVerticalDirection", this ); }

                return direction === MovementDirection.VerticalBottomToTop || direction === MovementDirection.VerticalTopToBottom;
            },
            /*ColorPixelsCollectorObject.IsVerticalDirection end.*/

            /*ColorPixelsCollectorObject.UpdatePossibleTargets start.*/
            UpdatePossibleTargets: function () {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#UpdatePossibleTargets", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.CurrentGrid, null)) {
                    // Get all outline pixels with the matching color code
                    var outlinePixelsWithColor = this.CurrentGrid.SelectOutlinePixelsWithColor(this.CollectorColor);

                    if (outlinePixelsWithColor != null && outlinePixelsWithColor.Count > 0) {
                        // Ch resize when cn thit  trnh allocation thng xuyn
                        if (this.cachedTargets == null || outlinePixelsWithColor.Count > this.maxTargetCapacity) {
                            this.maxTargetCapacity = UnityEngine.Mathf.NextPowerOfTwo(outlinePixelsWithColor.Count);
                            this.cachedTargets = System.Array.init(this.maxTargetCapacity, null, PaintingPixel);
                        }

                        // Copy elements to the cached array
                        outlinePixelsWithColor.copyTo(this.cachedTargets, 0);
                        this.possibleTargetsCount = outlinePixelsWithColor.Count;

                        // Cp nht reference  tng thch with code hin ti
                        this.possibleTargets = this.cachedTargets;
                    } else {
                        this.possibleTargets = System.Array.init(0, null, PaintingPixel);
                        this.possibleTargetsCount = 0;
                    }
                }
            },
            /*ColorPixelsCollectorObject.UpdatePossibleTargets end.*/

            /*ColorPixelsCollectorObject.OnRunOutOfBulletDestroyed start.*/
            OnRunOutOfBulletDestroyed: function () {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#OnRunOutOfBulletDestroyed", this ); }

                if (!this.dead) {
                    this.dead = true;
                    this.SetActiveCollector(false);
                    !Bridge.staticEquals(this.OnCompleteAllColorPixels, null) ? this.OnCompleteAllColorPixels() : null;
                    UnityEngine.MonoBehaviour.op_Inequality(this.bulletDisplayHandler, null) ? this.bulletDisplayHandler.SetUpdateText(false) : null;
                    return;
                }
            },
            /*ColorPixelsCollectorObject.OnRunOutOfBulletDestroyed end.*/

            /*ColorPixelsCollectorObject.CheckAndDestroyNearbyPixels start.*/
            CheckAndDestroyNearbyPixels: function () {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#CheckAndDestroyNearbyPixels", this ); }

                if (this.dead) {
                    return;
                }
                if (this.BulletLeft <= 0 && !this.dead) {
                    this.dead = true;
                    this.SetActiveCollector(false);
                    !Bridge.staticEquals(this.OnCompleteAllColorPixels, null) ? this.OnCompleteAllColorPixels() : null;
                    UnityEngine.MonoBehaviour.op_Inequality(this.bulletDisplayHandler, null) ? this.bulletDisplayHandler.SetUpdateText(false) : null;
                    return;
                }

                // Determine the current movement direction using the tangent vector
                var hasValidMovementDirection = this.currentMovementDirection !== MovementDirection.Unknown;
                if (!hasValidMovementDirection) {
                    return;
                }

                // Cache hng di chuyn  trnh gi method nhiu ln
                var isHorizontalDirection = this.IsHorizontalDirection(this.currentMovementDirection);
                var isVerticalDirection = !isHorizontalDirection;

                // Cache frequently accessed values to reduce property access
                var collectorPosition = this.RabbitRootTransform.position.$clone();
                var detectionRadiusSqr = this.DetectionRadius * this.DetectionRadius; // Use squared distance to avoid sqrt calculation
                var detectionRadius = this.DetectionRadius; // Cache the radius value

                var tempPixel = null;
                for (var i = 0; i < this.possibleTargetsCount; i = (i + 1) | 0) {
                    tempPixel = this.possibleTargets[i];

                    if (tempPixel != null && tempPixel.InCount()) {
                        var isCloseEnough = false;
                        var hasObstacle = false;
                        var hasBeenProcessed = false;

                        if (hasValidMovementDirection) {
                            // Use coordinate-based detection depending on movement direction
                            // If moving more horizontally (X-axis), check only X positions
                            // If moving more vertically (Z-axis), check only Z positions

                            if (isHorizontalDirection) {
                                // Moving horizontally - only compare X positions
                                var positionDiff = collectorPosition.x - tempPixel.worldPos.x;
                                // Use absolute value calculation directly to avoid Mathf.Abs call
                                var absPositionDiff = positionDiff >= 0 ? positionDiff : -positionDiff;
                                isCloseEnough = absPositionDiff <= detectionRadius;
                                if (!isCloseEnough) {
                                    continue;
                                }

                                // Check if this column (X position) has already been processed in current direction
                                hasBeenProcessed = this.processedHorizontalPositions.contains(tempPixel.column);
                                if (hasBeenProcessed) {
                                    continue;
                                }

                                // Check for obstacles between collector and target pixel
                                hasObstacle = this.CheckForObstaclesInColumn(tempPixel);
                                if (hasObstacle) {
                                    continue;
                                }
                            } else {
                                // Moving vertically - only compare Z positions
                                var positionDiff1 = collectorPosition.z - tempPixel.worldPos.z;
                                // Use absolute value calculation directly to avoid Mathf.Abs call
                                var absPositionDiff1 = positionDiff1 >= 0 ? positionDiff1 : -positionDiff1;
                                isCloseEnough = absPositionDiff1 <= detectionRadius;
                                if (!isCloseEnough) {
                                    continue;
                                }

                                // Check if this row (Z position) has already been processed in current direction
                                hasBeenProcessed = this.processedVerticalPositions.contains(tempPixel.row);
                                if (hasBeenProcessed) {
                                    continue;
                                }

                                // Check for obstacles between collector and target pixel
                                hasObstacle = this.CheckForObstaclesInRow(tempPixel);
                                if (hasObstacle) {
                                    continue;
                                }
                            }
                        } else {
                            // Fallback to distance check if no valid movement direction
                            // Use squared distance to avoid sqrt calculation
                            var distanceSqr = (collectorPosition.$clone().sub( tempPixel.worldPos )).lengthSq();
                            isCloseEnough = distanceSqr <= detectionRadiusSqr;
                            if (!isCloseEnough) {
                                continue;
                            }
                        }

                        if (isCloseEnough && !hasObstacle && !hasBeenProcessed) {
                            // Destroy the pixel
                            this.ShootPixel(tempPixel);
                            if (!this.hasRotated) {
                                this.hasRotated = true;
                                this.RotateMesh();
                            }
                            // Mark position as processed in current direction
                            if (hasValidMovementDirection) {
                                if (isHorizontalDirection) {
                                    // Moving horizontally - mark column as processed
                                    this.processedHorizontalPositions.add(tempPixel.column);
                                } else {
                                    // Moving vertically - mark row as processed
                                    this.processedVerticalPositions.add(tempPixel.row);
                                }
                            }
                        }
                    }
                }
            },
            /*ColorPixelsCollectorObject.CheckAndDestroyNearbyPixels end.*/

            /*ColorPixelsCollectorObject.RotateMesh start.*/
            RotateMesh: function () {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#RotateMesh", this ); }

                if (UnityEngine.Object.op_Implicit(this.RabbitRotateTransform)) {
                    this.RabbitRotateTransform.localEulerAngles = this.cachedRotation.$clone();
                }
            },
            /*ColorPixelsCollectorObject.RotateMesh end.*/

            /*ColorPixelsCollectorObject.ShootPixel start.*/
            ShootPixel: function (pixel) {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#ShootPixel", this ); }

                if (pixel != null && pixel.InCount() && this.BulletLeft > 0) {
                    // Mark bullet as used
                    this.BulletLeft = (this.BulletLeft - 1) | 0;
                    // Destroy the pixel using the grid's method
                    this.CurrentGrid.ShootPixel(pixel);
                    UnityEngine.MonoBehaviour.op_Inequality(this.bulletDisplayHandler, null) ? this.bulletDisplayHandler.UpdateBulletDisplay(this.BulletLeft) : null;

                    // Get projectile from pool and configure it
                    var proj = CollectorProjectilePool.Instance.GetProjectile(false);
                    if (UnityEngine.MonoBehaviour.op_Inequality(proj, null)) {
                        // Cache color and position to reduce property access
                        var currentColor = this.VisualHandler.CurrentColor.$clone();
                        var spawnerPosition = this.VisualHandler.BulletSpawner.position.$clone();

                        proj.SetColor(currentColor);
                        proj.SetPosition(spawnerPosition);

                        if (UnityEngine.MonoBehaviour.op_Inequality(pixel.PixelComponent, null)) {
                            proj.StartProjectile(pixel.PixelComponent);
                        } else {
                            proj.StartProjectile$1(pixel.worldPos);
                        }
                    }

                    this.VisualHandler.PlayMuzzleEffect();
                    this.CollectorAnimator.PlayShootAnimation();

                    if (this.BulletLeft <= 0) {
                        this.OnRunOutOfBulletDestroyed();
                    }
                }
            },
            /*ColorPixelsCollectorObject.ShootPixel end.*/

            /*ColorPixelsCollectorObject.SetBullet start.*/
            SetBullet: function (bulletCount) {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#SetBullet", this ); }

                this.BulletLeft = bulletCount;
                UnityEngine.MonoBehaviour.op_Inequality(this.bulletDisplayHandler, null) ? this.bulletDisplayHandler.UpdateBulletDisplay(this.BulletLeft) : null;
            },
            /*ColorPixelsCollectorObject.SetBullet end.*/

            /*ColorPixelsCollectorObject.CheckForObstaclesInRow start.*/
            CheckForObstaclesInRow: function (targetPixel) {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#CheckForObstaclesInRow", this ); }

                var $t, $t1;
                if (UnityEngine.MonoBehaviour.op_Equality(this.CurrentGrid, null) || this.CurrentGrid.paintingPixels == null) {
                    return false;
                }

                // Check for pixels in the same row (z coordinate similar to target)
                // that are between the collector and target in the x-axis

                var pixelOnSameRow = this.CurrentGrid.GetPixelsInRow(targetPixel.row);

                switch (this.currentMovementDirection) {
                    case MovementDirection.VerticalBottomToTop: 
                        $t = Bridge.getEnumerator(pixelOnSameRow);
                        try {
                            while ($t.moveNext()) {
                                var pixel = $t.Current;
                                if (pixel.InCount() && pixel.column < targetPixel.column) {
                                    return true;
                                }
                            }
                        } finally {
                            if (Bridge.is($t, System.IDisposable)) {
                                $t.System$IDisposable$Dispose();
                            }
                        }
                        return false;
                    case MovementDirection.VerticalTopToBottom: 
                        $t1 = Bridge.getEnumerator(pixelOnSameRow);
                        try {
                            while ($t1.moveNext()) {
                                var pixel1 = $t1.Current;
                                if (pixel1.InCount() && pixel1.column > targetPixel.column) {
                                    return true;
                                }
                            }
                        } finally {
                            if (Bridge.is($t1, System.IDisposable)) {
                                $t1.System$IDisposable$Dispose();
                            }
                        }
                        return false;
                }

                return false; // No obstacles found
            },
            /*ColorPixelsCollectorObject.CheckForObstaclesInRow end.*/

            /*ColorPixelsCollectorObject.CheckForObstaclesInColumn start.*/
            CheckForObstaclesInColumn: function (targetPixel) {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#CheckForObstaclesInColumn", this ); }

                var $t, $t1;
                // Check for pixels in the same column (x coordinate similar to target)
                // that are between the collector and target in the z-axis

                var pixelOnSameColumn = this.CurrentGrid.GetPixelsInColumn(targetPixel.column);

                switch (this.currentMovementDirection) {
                    case MovementDirection.HorizontalLeftToRight: 
                        $t = Bridge.getEnumerator(pixelOnSameColumn);
                        try {
                            while ($t.moveNext()) {
                                var pixel = $t.Current;
                                if (pixel.InCount() && pixel.row > targetPixel.row) {
                                    return true;
                                }
                            }
                        } finally {
                            if (Bridge.is($t, System.IDisposable)) {
                                $t.System$IDisposable$Dispose();
                            }
                        }
                        return false;
                    case MovementDirection.HorizontalRightToLeft: 
                        $t1 = Bridge.getEnumerator(pixelOnSameColumn);
                        try {
                            while ($t1.moveNext()) {
                                var pixel1 = $t1.Current;
                                if (pixel1.InCount() && pixel1.row < targetPixel.row) {
                                    return true;
                                }
                            }
                        } finally {
                            if (Bridge.is($t1, System.IDisposable)) {
                                $t1.System$IDisposable$Dispose();
                            }
                        }
                        return false;
                }

                return false; // No obstacles found
            },
            /*ColorPixelsCollectorObject.CheckForObstaclesInColumn end.*/

            /*ColorPixelsCollectorObject.CheckTargetOnAbsoluteWin start.*/
            CheckTargetOnAbsoluteWin: function () {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#CheckTargetOnAbsoluteWin", this ); }

                if (this.possibleTargetsCount <= 0) {
                    return;
                }

            },
            /*ColorPixelsCollectorObject.CheckTargetOnAbsoluteWin end.*/

            /*ColorPixelsCollectorObject.SelfDestroy start.*/
            SelfDestroy: function () {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#SelfDestroy", this ); }

                this.SetActiveCollector(false);
                !Bridge.staticEquals(this.OnCompleteAllColorPixels, null) ? this.OnCompleteAllColorPixels() : null;
                UnityEngine.MonoBehaviour.op_Inequality(this.bulletDisplayHandler, null) ? this.bulletDisplayHandler.SetUpdateText(false) : null;
            },
            /*ColorPixelsCollectorObject.SelfDestroy end.*/

            /*ColorPixelsCollectorObject.ApplyLockedState start.*/
            ApplyLockedState: function () {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#ApplyLockedState", this ); }

                this.VisualHandler.SetLockedIcon(this.IsLocked);
            },
            /*ColorPixelsCollectorObject.ApplyLockedState end.*/

            /*ColorPixelsCollectorObject.ApplyHiddenState start.*/
            ApplyHiddenState: function () {
if ( TRACE ) { TRACE( "ColorPixelsCollectorObject#ApplyHiddenState", this ); }

                this.VisualHandler.SetHiddenState(this.IsHidden);
            },
            /*ColorPixelsCollectorObject.ApplyHiddenState end.*/


        }
    });
    /*ColorPixelsCollectorObject end.*/

    /*LockObject start.*/
    Bridge.define("LockObject", {
        inherits: [CollectorMachanicObjectBase],
        fields: {
            Row: 0,
            IsUnlocked: false,
            collectorController: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "LockObject#init", this ); }

                this.IsUnlocked = false;
            }
        },
        methods: {
            /*LockObject.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "LockObject#Awake", this ); }

                this.IsUnlocked = false;
            },
            /*LockObject.Awake end.*/

            /*LockObject.Unlock start.*/
            Unlock: function () {
if ( TRACE ) { TRACE( "LockObject#Unlock", this ); }

                this.IsUnlocked = true;
            },
            /*LockObject.Unlock end.*/

            /*LockObject.UnlockWithVisual start.*/
            UnlockWithVisual: function () {
if ( TRACE ) { TRACE( "LockObject#UnlockWithVisual", this ); }

                this.IsUnlocked = true;
                !Bridge.staticEquals(GameplayEventsManager.OnUnlockLockObject, null) ? GameplayEventsManager.OnUnlockLockObject(this.collectorController) : null;
                this.collectorController.UnlockCollector();
            },
            /*LockObject.UnlockWithVisual end.*/


        }
    });
    /*LockObject end.*/

    /*SoundManager start.*/
    Bridge.define("SoundManager", {
        inherits: function () {
if ( TRACE ) { TRACE( "SoundManager#inherits", this ); }
 return [Singleton$1(SoundManager)]; },
        statics: {
            fields: {
                _backGroundMusics: null,
                _bgmWaitingList: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "SoundManager#init", this ); }

                    this._backGroundMusics = new (System.Collections.Generic.List$1(UnityEngine.AudioClip)).ctor();
                    this._bgmWaitingList = new (System.Collections.Generic.List$1(UnityEngine.AudioClip)).ctor();
                }
            },
            methods: {
                /*SoundManager.PlaySound:static start.*/
                PlaySound: function (sound) {
if ( TRACE ) { TRACE( "SoundManager#PlaySound", this ); }

                    if (sound.Clip == null) {
                        return;
                    }
                    switch (sound.soundType) {
                        case SoundType.Effect: 
                            if (UnityEngine.Object.op_Implicit(Singleton$1(SoundManager).Instance.fxMusicSource)) {
                                Singleton$1(SoundManager).Instance.fxMusicSource.PlayOneShot(sound.Clip);
                            }
                            break;
                        default: 
                            if (UnityEngine.Object.op_Implicit(Singleton$1(SoundManager).Instance.fxMusicSource)) {
                                Singleton$1(SoundManager).Instance.fxMusicSource.PlayOneShot(sound.Clip);
                            }
                            break;
                    }
                },
                /*SoundManager.PlaySound:static end.*/

                /*SoundManager.StopSound:static start.*/
                StopSound: function (sound) {
if ( TRACE ) { TRACE( "SoundManager#StopSound", this ); }

                    var $t;
                    if (sound.Clip == null) {
                        return;
                    }
                    switch (sound.soundType) {
                        default: 
                            UnityEngine.MonoBehaviour.op_Inequality(($t = Singleton$1(SoundManager).Instance), null) ? $t.fxMusicSource.Stop() : null;
                            break;
                    }
                },
                /*SoundManager.StopSound:static end.*/

                /*SoundManager.PlayRandomBGM:static start.*/
                PlayRandomBGM: function (sound) {
if ( TRACE ) { TRACE( "SoundManager#PlayRandomBGM", this ); }

                    if (sound.soundType !== SoundType.BackgroundMusic || sound.ClipList == null || sound.ClipList.Count === 0) {
                        return;
                    }
                    Singleton$1(SoundManager).Instance._isLoopRandomBGM = false;
                    SoundManager._backGroundMusics = sound.ClipList;
                    SoundManager._bgmWaitingList = new (System.Collections.Generic.List$1(UnityEngine.AudioClip)).$ctor1(SoundManager._backGroundMusics);
                    Singleton$1(SoundManager).Instance._isLoopRandomBGM = true;
                },
                /*SoundManager.PlayRandomBGM:static end.*/


            }
        },
        fields: {
            audioMixer: null,
            fxMusicSource: null,
            specialBgmSource: null,
            isPlayBgmOnStart: false,
            BGM: null,
            _isFxPauseBySpeed: false,
            _specialSoundStopCountDown: null,
            _specialSoundLoop: null,
            _specialSoundTween: null,
            _isLoopRandomBGM: false,
            _isEndGame: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "SoundManager#init", this ); }

                this.BGM = new SoundDefine();
                this.isPlayBgmOnStart = true;
                this._isLoopRandomBGM = false;
                this._isEndGame = false;
            }
        },
        methods: {
            /*SoundManager.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "SoundManager#Start", this ); }

                this.isPlayBgmOnStart = true;

                // m bo BGM AudioSource khng t ng pht
                if (UnityEngine.Component.op_Inequality(this.specialBgmSource, null)) {
                    this.specialBgmSource.Stop();
                    this.specialBgmSource.playOnAwake = false;
                }

                var playMusic = 1;
                var playSound = 1;
                this.OnSoundChange(playMusic);
                this.OnSoundFxChange(playSound);
            },
            /*SoundManager.Start end.*/

            /*SoundManager.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "SoundManager#Update", this ); }

                if (this.isPlayBgmOnStart && UnityEngine.Input.GetMouseButton(0)) {
                    this.isPlayBgmOnStart = false;
                    this.OnPlaySoundBG();
                }
            },
            /*SoundManager.Update end.*/

            /*SoundManager.OnPlaySoundBG start.*/
            OnPlaySoundBG: function () {
if ( TRACE ) { TRACE( "SoundManager#OnPlaySoundBG", this ); }

                // Dng nu ang pht v reset time v 0
                this.specialBgmSource.Stop();
                this.specialBgmSource.time = 0.0;

                this.specialBgmSource.clip = this.BGM.Clip;
                this.specialBgmSource.loop = this.BGM.Loop;
                this.specialBgmSource.Play();
                UnityEngine.Debug.Log$1("play bgm from start, time: " + System.Single.format(this.specialBgmSource.time));
            },
            /*SoundManager.OnPlaySoundBG end.*/

            /*SoundManager.OnSoundFxChange start.*/
            OnSoundFxChange: function (currentValue) {
if ( TRACE ) { TRACE( "SoundManager#OnSoundFxChange", this ); }

                if (this.audioMixer == null) {
                    return;
                }
                currentValue *= 2; // sound fx c m lng gp i
                var soundValue = currentValue === 0 ? -100 : Math.log(currentValue) / Math.log(10) * 20;
                var parameterName = System.Enum.getName(SoundMixerGroup, Bridge.box(SoundMixerGroup.SoundFx, SoundMixerGroup, System.Enum.toStringFn(SoundMixerGroup)));
                var checkSet = this.audioMixer.SetFloat(parameterName, soundValue);
            },
            /*SoundManager.OnSoundFxChange end.*/

            /*SoundManager.OnSoundChange start.*/
            OnSoundChange: function (currentValue) {
if ( TRACE ) { TRACE( "SoundManager#OnSoundChange", this ); }

                if (this.audioMixer == null) {
                    return;
                }
                var maxRangeDesign = 1.0;
                currentValue = MathHr.Remap(currentValue, 0, 1, 0, maxRangeDesign);
                var soundValue = currentValue === 0 ? -100 : Math.log(currentValue) / Math.log(10) * 20;
                var parameterName = System.Enum.getName(SoundMixerGroup, Bridge.box(SoundMixerGroup.Sound, SoundMixerGroup, System.Enum.toStringFn(SoundMixerGroup)));
                var checkSet = this.audioMixer.SetFloat(parameterName, soundValue);
            },
            /*SoundManager.OnSoundChange end.*/

            /*SoundManager.ChangeVolumeSpecialBgmSound start.*/
            ChangeVolumeSpecialBgmSound: function (currentValue) {
if ( TRACE ) { TRACE( "SoundManager#ChangeVolumeSpecialBgmSound", this ); }

                if (this.audioMixer == null) {
                    return;
                }
                var soundValue = currentValue === 0 ? -100 : Math.log(currentValue) / Math.log(10) * 20;
                var parameterName = System.Enum.getName(SoundMixerGroup, Bridge.box(SoundMixerGroup.SpecialSound, SoundMixerGroup, System.Enum.toStringFn(SoundMixerGroup)));
                var checkSet = this.audioMixer.SetFloat(parameterName, soundValue);
            },
            /*SoundManager.ChangeVolumeSpecialBgmSound end.*/

            /*SoundManager.OnMainSoundChange start.*/
            OnMainSoundChange: function (currentValue) {
if ( TRACE ) { TRACE( "SoundManager#OnMainSoundChange", this ); }

                if (this.audioMixer == null) {
                    return;
                }
                currentValue *= 2;
                var soundValue = currentValue === 0 ? -100 : Math.log(currentValue) / Math.log(10) * 20;
                var parameterName = System.Enum.getName(SoundMixerGroup, Bridge.box(SoundMixerGroup.MainSound, SoundMixerGroup, System.Enum.toStringFn(SoundMixerGroup)));
                var checkSet = this.audioMixer.SetFloat(parameterName, soundValue);
            },
            /*SoundManager.OnMainSoundChange end.*/

            /*SoundManager.OnEnableShowFxInGame start.*/
            OnEnableShowFxInGame: function (enable) {
if ( TRACE ) { TRACE( "SoundManager#OnEnableShowFxInGame", this ); }

                if (this.audioMixer == null) {
                    return;
                }
                var soundValue = enable ? Math.log(1) / Math.log(10) * 20 : -100;
                var parameterName = System.Enum.getName(SoundMixerGroup, Bridge.box(SoundMixerGroup.SoundFxInGame, SoundMixerGroup, System.Enum.toStringFn(SoundMixerGroup)));
                var checkSet = this.audioMixer.SetFloat(parameterName, soundValue);
            },
            /*SoundManager.OnEnableShowFxInGame end.*/

            /*SoundManager.SetSpeedAudioGroup start.*/
            SetSpeedAudioGroup: function (group, speed) {
if ( TRACE ) { TRACE( "SoundManager#SetSpeedAudioGroup", this ); }

                var $t;
                if (group === SoundMixerGroup.SoundFxInGame) {
                    if (speed === 0 && !this._isFxPauseBySpeed) {
                        this._isFxPauseBySpeed = true;
                        this.OnEnableShowFxInGame(false);
                    } else if (speed > 0 && this._isFxPauseBySpeed) {
                        this._isFxPauseBySpeed = false;
                        this.OnEnableShowFxInGame(true);
                    }
                }

                var actualValue = 1 - Math.abs(1 - speed) / 2 * ($t = 1 - speed, ($t === 0 ? 1 : Math.sign($t))); // cng thc ca mr xng rng
                var parameterName = (System.Enum.getName(SoundMixerGroup, Bridge.box(group, SoundMixerGroup, System.Enum.toStringFn(SoundMixerGroup))) || "") + "Pitch";
                var checkSet = this.audioMixer.SetFloat(parameterName, actualValue);
            },
            /*SoundManager.SetSpeedAudioGroup end.*/

            /*SoundManager.PlayOneShotFx start.*/
            /**
             * Hm pht mt m thanh vi Mixer l SoundFx
             *
             * @instance
             * @public
             * @this SoundManager
             * @memberof SoundManager
             * @param   {UnityEngine.AudioClip}    clip
             * @return  {void}
             */
            PlayOneShotFx: function (clip) {
if ( TRACE ) { TRACE( "SoundManager#PlayOneShotFx", this ); }

                this.fxMusicSource.PlayOneShot(clip);
            },
            /*SoundManager.PlayOneShotFx end.*/

            /*SoundManager.PlayOneShot start.*/
            /**
             * Hm pht mt m thanh vi Mixer l Sound
             *
             * @instance
             * @public
             * @this SoundManager
             * @memberof SoundManager
             * @param   {UnityEngine.AudioClip}    clip      
             * @param   {number}                   volume
             * @return  {void}
             */
            PlayOneShot: function (clip, volume) {
if ( TRACE ) { TRACE( "SoundManager#PlayOneShot", this ); }

                if (volume === void 0) { volume = 1.0; }
                this.fxMusicSource.PlayOneShot$1(clip, volume);
            },
            /*SoundManager.PlayOneShot end.*/

            /*SoundManager.PlayOneShotDelayed start.*/
            PlayOneShotDelayed: function (clip, delay, volume) {
if ( TRACE ) { TRACE( "SoundManager#PlayOneShotDelayed", this ); }

                if (volume === void 0) { volume = 1.0; }
                this.StartCoroutine$1(this.PlayDelayed(clip, delay, volume));
            },
            /*SoundManager.PlayOneShotDelayed end.*/

            /*SoundManager.PlayDelayed start.*/
            PlayDelayed: function (clip, delay, volume) {
if ( TRACE ) { TRACE( "SoundManager#PlayDelayed", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if (volume === void 0) { volume = 1.0; }
                                        $enumerator.current = HelperCoroutine.WaitSeconds(delay);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    this.PlayOneShot(clip, volume);

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*SoundManager.PlayDelayed end.*/

            /*SoundManager.PlaySpecialSoundLoop start.*/
            PlaySpecialSoundLoop: function (clip, delay, bgmRatio) {
if ( TRACE ) { TRACE( "SoundManager#PlaySpecialSoundLoop", this ); }

                if (delay === void 0) { delay = 0.0; }
                if (bgmRatio === void 0) { bgmRatio = 0.0; }
                if (this._specialSoundLoop != null) {
                    this.StopCoroutine$2(this._specialSoundLoop);
                    return;
                }
                this._specialSoundLoop = this.StartCoroutine$1(this.LoopSpecialSound(clip, delay, bgmRatio));
            },
            /*SoundManager.PlaySpecialSoundLoop end.*/

            /*SoundManager.LoopSpecialSound start.*/
            LoopSpecialSound: function (clip, delay, bgmRatio) {
if ( TRACE ) { TRACE( "SoundManager#LoopSpecialSound", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if (delay === void 0) { delay = 0.0; }
                                        if (bgmRatio === void 0) { bgmRatio = 0.0; }
                                        //float targetBgmVolume = DataManager.SettingData.Sound * bgmRatio;
                                        //OnSoundChange(targetBgmVolume);
                                        //ChangeVolumeSpecialBgmSound(DataManager.SettingData.Sound);
                                        Singleton$1(SoundManager).Instance.specialBgmSource.Stop();
                                        Singleton$1(SoundManager).Instance.specialBgmSource.clip = clip;
                                        Singleton$1(SoundManager).Instance.specialBgmSource.loop = true;
                                        Singleton$1(SoundManager).Instance.specialBgmSource.Play();
                                        if (delay !== 0) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 3;
                                        continue;
                                }
                                case 1: {
                                    $enumerator.current = HelperCoroutine.WaitSeconds(delay);
                                        $step = 2;
                                        return true;
                                }
                                case 2: {
                                    this.StopSpecialSoundLoop();
                                    $step = 3;
                                    continue;
                                }
                                case 3: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*SoundManager.LoopSpecialSound end.*/

            /*SoundManager.StopSpecialSoundLoop start.*/
            StopSpecialSoundLoop: function () {
if ( TRACE ) { TRACE( "SoundManager#StopSpecialSoundLoop", this ); }

                if (this._specialSoundLoop != null) {
                    this.StopCoroutine$2(this._specialSoundLoop);
                }
                this.specialBgmSource.Stop();
            },
            /*SoundManager.StopSpecialSoundLoop end.*/

            /*SoundManager.SetBoolEndGameUI start.*/
            SetBoolEndGameUI: function (value) {
if ( TRACE ) { TRACE( "SoundManager#SetBoolEndGameUI", this ); }

                this._isEndGame = value;
            },
            /*SoundManager.SetBoolEndGameUI end.*/


        }
    });
    /*SoundManager end.*/

    /*UiEndGame start.*/
    Bridge.define("UiEndGame", {
        inherits: function () {
if ( TRACE ) { TRACE( "UiEndGame#inherits", this ); }
 return [Singleton$1(UiEndGame)]; },
        fields: {
            m_endGameCanvas: null,
            m_headerCanvas: null,
            m_levelTransitionOverlay: null,
            m_endText: null,
            m_endText1: null,
            m_buttonText: null,
            m_buttonText1: null,
            m_endGameSound: null,
            m_loadingText: null,
            m_loadingCoroutine: null
        },
        methods: {
            /*UiEndGame.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "UiEndGame#Start", this ); }

                this.m_endGameCanvas.alpha = 0.0;
                this.m_endGameCanvas.gameObject.SetActive(false);
                this.m_headerCanvas.alpha = 1.0;
                this.m_headerCanvas.gameObject.SetActive(true);
            },
            /*UiEndGame.Start end.*/

            /*UiEndGame.ShowEndGameWin start.*/
            ShowEndGameWin: function () {
if ( TRACE ) { TRACE( "UiEndGame#ShowEndGameWin", this ); }

                this.m_endText.text = ("You Win!").toUpperCase();
                this.m_buttonText.text = ("Play Now").toUpperCase();
                this.m_endText1.text = ("You Win!").toUpperCase();
                this.m_buttonText1.text = ("Play Now").toUpperCase();
                Singleton$1(SoundManager).Instance.PlayOneShot(this.m_endGameSound[0]);
                this.FadeInEndGame();
            },
            /*UiEndGame.ShowEndGameWin end.*/

            /*UiEndGame.ShowEndGameLose start.*/
            ShowEndGameLose: function () {
if ( TRACE ) { TRACE( "UiEndGame#ShowEndGameLose", this ); }

                this.m_endText.text = ("You Lose!").toUpperCase();
                this.m_buttonText.text = ("Play Again").toUpperCase();
                this.m_endText1.text = ("You Lose!").toUpperCase();
                this.m_buttonText1.text = ("Play Again").toUpperCase();
                this.FadeInEndGame();
                Singleton$1(SoundManager).Instance.PlayOneShot(this.m_endGameSound[1]);
            },
            /*UiEndGame.ShowEndGameLose end.*/

            /*UiEndGame.StartLevelTransition start.*/
            StartLevelTransition: function (onComplete, delayBeforeFadeOut) {
if ( TRACE ) { TRACE( "UiEndGame#StartLevelTransition", this ); }

                if (onComplete === void 0) { onComplete = null; }
                if (delayBeforeFadeOut === void 0) { delayBeforeFadeOut = 0.25; }
                if (UnityEngine.MonoBehaviour.op_Inequality(this.m_levelTransitionOverlay, null)) {
                    !Bridge.staticEquals(GameplayEventsManager.OnBlockGamePlayInput, null) ? GameplayEventsManager.OnBlockGamePlayInput(true) : null;
                    DG.Tweening.ShortcutExtensions.DOKill(this.m_levelTransitionOverlay, true);
                    this.m_levelTransitionOverlay.alpha = 0.0;
                    this.m_levelTransitionOverlay.gameObject.SetActive(true);

                    // Bt u animation loading dots
                    this.StartLoadingDots();
                    DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), DG.Tweening.DOTweenModuleUI.DOFade(this.m_levelTransitionOverlay, 1.0, 1.0), Bridge.fn.bind(this, function () {
                        !Bridge.staticEquals(onComplete, null) ? onComplete() : null;

                        // Delay trc fade out
                        this.m_levelTransitionOverlay.alpha = 1.0;
                        DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), DG.Tweening.TweenSettingsExtensions.SetDelay(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), DG.Tweening.DOTweenModuleUI.DOFade(this.m_levelTransitionOverlay, 0.0, 1.0), delayBeforeFadeOut), Bridge.fn.bind(this, function () {
                            this.m_levelTransitionOverlay.gameObject.SetActive(false);
                            this.StopLoadingDots();
                            !Bridge.staticEquals(GameplayEventsManager.OnBlockGamePlayInput, null) ? GameplayEventsManager.OnBlockGamePlayInput(false) : null;
                            // Dng animation dots
                        }));
                    }));
                } else {
                    !Bridge.staticEquals(onComplete, null) ? onComplete() : null;
                }
            },
            /*UiEndGame.StartLevelTransition end.*/

            /*UiEndGame.FadeInEndGame start.*/
            FadeInEndGame: function () {
if ( TRACE ) { TRACE( "UiEndGame#FadeInEndGame", this ); }

                this.m_endGameCanvas.gameObject.SetActive(true);
                this.m_headerCanvas.gameObject.SetActive(true);
                DG.Tweening.DOTweenModuleUI.DOFade(this.m_endGameCanvas, 1.0, 1.0);
                DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), DG.Tweening.DOTweenModuleUI.DOFade(this.m_headerCanvas, 0.0, 1.0), Bridge.fn.bind(this, function () {
                    this.m_headerCanvas.gameObject.SetActive(false);
                }));
            },
            /*UiEndGame.FadeInEndGame end.*/

            /*UiEndGame.StartLoadingDots start.*/
            StartLoadingDots: function () {
if ( TRACE ) { TRACE( "UiEndGame#StartLoadingDots", this ); }

                if (this.m_loadingCoroutine != null) {
                    this.StopCoroutine$2(this.m_loadingCoroutine);
                }

                this.m_loadingCoroutine = this.StartCoroutine$1(this.LoadingDotsCoroutine());
            },
            /*UiEndGame.StartLoadingDots end.*/

            /*UiEndGame.StopLoadingDots start.*/
            StopLoadingDots: function () {
if ( TRACE ) { TRACE( "UiEndGame#StopLoadingDots", this ); }

                if (this.m_loadingCoroutine != null) {
                    this.StopCoroutine$2(this.m_loadingCoroutine);
                    this.m_loadingCoroutine = null;
                }
            },
            /*UiEndGame.StopLoadingDots end.*/

            /*UiEndGame.LoadingDotsCoroutine start.*/
            LoadingDotsCoroutine: function () {
if ( TRACE ) { TRACE( "UiEndGame#LoadingDotsCoroutine", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    dotCount,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    dotCount = 0;
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( true ) {
                                            $step = 2;
                                            continue;
                                        } 
                                        $step = 4;
                                        continue;
                                }
                                case 2: {
                                    dotCount = ((dotCount % 3) + 1) | 0; // 1  2  3  1
                                        this.m_loadingText.text = "Loading" + (System.String.fromCharCount(46, dotCount) || "");
                                        $enumerator.current = new UnityEngine.WaitForSeconds(0.25);
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    // 0.5 giy i 1 ln

                                        $step = 1;
                                        continue;
                                }
                                case 4: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*UiEndGame.LoadingDotsCoroutine end.*/


        }
    });
    /*UiEndGame end.*/

    /*UIEndGameXmas start.*/
    Bridge.define("UIEndGameXmas", {
        inherits: [UiEndGame],
        fields: {
            m_xmasHeaderImage: null,
            m_xmasWinSprite: null,
            m_xmasLoseSprite: null,
            m_xmasFooterImage: null,
            m_xmasFooterSprite: null
        },
        methods: {
            /*UIEndGameXmas.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "UIEndGameXmas#Start", this ); }

                UiEndGame.prototype.Start.call(this);
                this.m_endText.enabled = false;
                this.m_endText1.enabled = false;
                this.m_buttonText.enabled = false;
                this.m_buttonText1.enabled = false;
            },
            /*UIEndGameXmas.Start end.*/

            /*UIEndGameXmas.ShowEndGameWin start.*/
            ShowEndGameWin: function () {
if ( TRACE ) { TRACE( "UIEndGameXmas#ShowEndGameWin", this ); }

                this.m_xmasHeaderImage.sprite = this.m_xmasWinSprite;
                this.m_xmasFooterImage.sprite = this.m_xmasFooterSprite[0];
                Singleton$1(SoundManager).Instance.PlayOneShot(this.m_endGameSound[0]);
                this.FadeInEndGame();
            },
            /*UIEndGameXmas.ShowEndGameWin end.*/

            /*UIEndGameXmas.ShowEndGameLose start.*/
            ShowEndGameLose: function () {
if ( TRACE ) { TRACE( "UIEndGameXmas#ShowEndGameLose", this ); }

                this.m_xmasHeaderImage.sprite = this.m_xmasLoseSprite;
                this.m_xmasFooterImage.sprite = this.m_xmasFooterSprite[1];

                Singleton$1(SoundManager).Instance.PlayOneShot(this.m_endGameSound[1]);
                this.FadeInEndGame();
            },
            /*UIEndGameXmas.ShowEndGameLose end.*/


        }
    });
    /*UIEndGameXmas end.*/

    if ( MODULE_reflection ) {
    var $m = Bridge.setMetadata,
        $n = ["System.Collections","System","UnityEngine","UnityEngine.UI","TMPro","DG.Tweening","System.Collections.Generic","GogoGaga.OptimizedRopesAndCables","UnityEngine.Audio","UnityEngine.EventSystems","DG.Tweening.Core","DG.Tweening.Plugins.Core.PathCore","System.Globalization","DG.Tweening.Plugins.Options"];

    /*TutorialLayer start.*/
    $m("TutorialLayer", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"FlareEffectCoroutine","t":8,"sn":"FlareEffectCoroutine","rt":$n[0].IEnumerator},{"a":2,"n":"HideLayer","t":8,"sn":"HideLayer","rt":$n[1].Void},{"a":2,"n":"InitLayer","t":8,"sn":"InitLayer","rt":$n[1].Void},{"a":1,"n":"OnCollectorStartMove","t":8,"pi":[{"n":"obj","pt":CollectorController,"ps":0}],"sn":"OnCollectorStartMove","rt":$n[1].Void,"p":[CollectorController]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[1].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[1].Void},{"a":2,"n":"ShowLayer","t":8,"sn":"ShowLayer","rt":$n[1].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[1].Void},{"a":1,"n":"StartScaleText","t":8,"sn":"StartScaleText","rt":$n[1].Void},{"a":1,"n":"StopAllCoroutinesSafe","t":8,"sn":"StopAllCoroutinesSafe","rt":$n[1].Void},{"a":1,"n":"SwapHandSpriteCoroutine","t":8,"sn":"SwapHandSpriteCoroutine","rt":$n[0].IEnumerator},{"a":1,"n":"WorldToCanvasLocalPosition","t":8,"pi":[{"n":"targetCanvas","pt":$n[2].Canvas,"ps":0},{"n":"cam","pt":$n[2].Camera,"ps":1},{"n":"worldPos","pt":$n[2].Vector3,"ps":2}],"sn":"WorldToCanvasLocalPosition","rt":$n[2].Vector2,"p":[$n[2].Canvas,$n[2].Camera,$n[2].Vector3]},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"canvas","t":4,"rt":$n[2].Canvas,"sn":"canvas"},{"a":1,"n":"flareCoroutine","t":4,"rt":$n[2].Coroutine,"sn":"flareCoroutine"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"flareImage","t":4,"rt":$n[3].Image,"sn":"flareImage"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"handImage","t":4,"rt":$n[3].Image,"sn":"handImage"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"handSprites","t":4,"rt":System.Array.type(UnityEngine.Sprite),"sn":"handSprites"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"handTrans","t":4,"rt":$n[2].RectTransform,"sn":"handTrans"},{"a":1,"n":"playAnim","t":4,"rt":$n[1].Boolean,"sn":"playAnim","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"spriteIndex","t":4,"rt":$n[1].Int32,"sn":"spriteIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"swapHandCoroutine","t":4,"rt":$n[2].Coroutine,"sn":"swapHandCoroutine"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"tutorialText","t":4,"rt":$n[4].TMP_Text,"sn":"tutorialText"},{"a":1,"n":"tweenScaleText","t":4,"rt":$n[5].Tween,"sn":"tweenScaleText"}]}; }, $n);
    /*TutorialLayer end.*/

    /*ColorPalleteData start.*/
    $m("ColorPalleteData", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "ScriptableObjects/ColorPallete", menuName: "ScriptableObjects/ColorPallete"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"FindKeyByColor","t":8,"pi":[{"n":"colorToFind","pt":$n[2].Color,"ps":0}],"sn":"FindKeyByColor","rt":$n[1].String,"p":[$n[2].Color]},{"a":2,"n":"GetColorByCode","t":8,"pi":[{"n":"code","pt":$n[1].String,"ps":0}],"sn":"GetColorByCode","rt":$n[2].Color,"p":[$n[1].String]},{"a":2,"n":"GetMaterialByCode","t":8,"pi":[{"n":"code","pt":$n[1].String,"ps":0}],"sn":"GetMaterialByCode","rt":$n[2].Material,"p":[$n[1].String]},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[1].Void},{"a":1,"n":"OnValidate","t":8,"sn":"OnValidate","rt":$n[1].Void},{"at":[new UnityEngine.ContextMenu.ctor("SetupColor")],"a":2,"n":"SetupColor","t":8,"sn":"SetupColor","rt":$n[1].Void},{"at":[new UnityEngine.ContextMenu.ctor("SetupMaterials")],"a":2,"n":"SetupMaterials","t":8,"sn":"SetupMaterials","rt":$n[1].Void},{"a":2,"n":"ColorKeys","t":4,"rt":$n[6].List$1(System.String),"sn":"ColorKeys"},{"a":2,"n":"ColorsValues","t":4,"rt":$n[6].List$1(UnityEngine.Color),"sn":"ColorsValues"},{"a":2,"n":"MatPallete","t":4,"rt":$n[6].Dictionary$2(System.String,UnityEngine.Material),"sn":"MatPallete"},{"a":2,"n":"MatValues","t":4,"rt":$n[6].List$1(UnityEngine.Material),"sn":"MatValues"},{"a":2,"n":"colorPallete","t":4,"rt":$n[6].Dictionary$2(System.String,UnityEngine.Color),"sn":"colorPallete"}]}; }, $n);
    /*ColorPalleteData end.*/

    /*LevelGamePlayConfigSO start.*/
    $m("LevelGamePlayConfigSO", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "ScriptableObjects/LevelConfigGamePlay", menuName: "ScriptableObjects/LevelGamePlayConfig"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"GetLevelConfigData","t":8,"pi":[{"n":"levelId","pt":$n[1].Int32,"ps":0}],"sn":"GetLevelConfigData","rt":LevelConfig,"p":[$n[1].Int32]},{"a":2,"n":"GetLevelToLoad","t":8,"pi":[{"n":"playerCurrentLevel","pt":$n[1].Int32,"ps":0}],"sn":"GetLevelToLoad","rt":$n[1].Int32,"p":[$n[1].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":2,"n":"levelConfigDataList","t":4,"rt":$n[6].List$1(LevelConfig),"sn":"levelConfigDataList"}]}; }, $n);
    /*LevelGamePlayConfigSO end.*/

    /*Grid3DLayout start.*/
    $m("Grid3DLayout", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"at":[new UnityEngine.ContextMenu.ctor("Arrange Children")],"a":1,"n":"ArrangeChildren","t":8,"sn":"ArrangeChildren","rt":$n[1].Void},{"a":2,"n":"columns","t":4,"rt":$n[1].Int32,"sn":"columns","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"spacing","t":4,"rt":$n[1].Single,"sn":"spacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Grid3DLayout end.*/

    /*CollectorProjectileController start.*/
    $m("CollectorProjectileController", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[1].Void},{"a":2,"n":"Despawn","t":8,"pi":[{"n":"super","pt":$n[1].Boolean,"ps":0}],"sn":"Despawn","rt":$n[1].Void,"p":[$n[1].Boolean]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[1].Void},{"a":1,"n":"OnStop","t":8,"sn":"OnStop","rt":$n[1].Void},{"a":2,"n":"RotateToTarget","t":8,"sn":"RotateToTarget","rt":$n[1].Void},{"a":1,"n":"SetBulletMeshColor","t":8,"pi":[{"n":"_color","pt":$n[2].Color,"ps":0}],"sn":"SetBulletMeshColor","rt":$n[1].Void,"p":[$n[2].Color]},{"a":2,"n":"SetColor","t":8,"pi":[{"n":"color","pt":$n[2].Color,"ps":0}],"sn":"SetColor","rt":$n[1].Void,"p":[$n[2].Color]},{"a":2,"n":"SetPosition","t":8,"pi":[{"n":"pos","pt":$n[2].Vector3,"ps":0}],"sn":"SetPosition","rt":$n[1].Void,"p":[$n[2].Vector3]},{"a":2,"n":"SetReturnToPoolCallback","t":8,"pi":[{"n":"callback","pt":Function,"ps":0}],"sn":"SetReturnToPoolCallback","rt":$n[1].Void,"p":[Function]},{"a":2,"n":"StartProjectile","t":8,"pi":[{"n":"target","pt":PaintingPixelComponent,"ps":0},{"n":"speed","dv":-1.0,"o":true,"pt":$n[1].Single,"ps":1}],"sn":"StartProjectile","rt":$n[1].Void,"p":[PaintingPixelComponent,$n[1].Single]},{"a":2,"n":"StartProjectile","t":8,"pi":[{"n":"target","pt":$n[2].Vector3,"ps":0},{"n":"speed","dv":-1.0,"o":true,"pt":$n[1].Single,"ps":1}],"sn":"StartProjectile$1","rt":$n[1].Void,"p":[$n[2].Vector3,$n[1].Single]},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[1].Void},{"a":2,"n":"BulletMeshParticle","t":4,"rt":$n[2].ParticleSystem,"sn":"BulletMeshParticle"},{"a":2,"n":"CurrentTimer","t":4,"rt":$n[1].Single,"sn":"CurrentTimer","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"EffectOptions","t":4,"rt":InGameEffectOptions,"sn":"EffectOptions"},{"at":[new UnityEngine.HeaderAttribute("PARTICLE SYSTEM(s)")],"a":2,"n":"FlyingFXs","t":4,"rt":$n[6].List$1(UnityEngine.ParticleSystem),"sn":"FlyingFXs"},{"a":2,"n":"HitFXs","t":4,"rt":$n[6].List$1(UnityEngine.ParticleSystem),"sn":"HitFXs"},{"a":2,"n":"MyTransform","t":4,"rt":$n[2].Transform,"sn":"MyTransform"},{"a":2,"n":"Speed","t":4,"rt":$n[1].Single,"sn":"Speed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Stopped","t":4,"rt":$n[1].Boolean,"sn":"Stopped","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("STAT(s)")],"a":2,"n":"SuperAmmo","t":4,"rt":$n[1].Boolean,"sn":"SuperAmmo","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("REAL TIME DATA")],"a":2,"n":"Target","t":4,"rt":$n[2].Vector3,"sn":"Target"},{"a":2,"n":"TimeExisted","t":4,"rt":$n[1].Single,"sn":"TimeExisted","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"TimeExistedAfterHit","t":4,"rt":$n[1].Single,"sn":"TimeExistedAfterHit","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"TrailFX","t":4,"rt":$n[2].TrailRenderer,"sn":"TrailFX"},{"a":1,"n":"bulletRenderer","t":4,"rt":$n[2].Renderer,"sn":"bulletRenderer"},{"a":1,"n":"currentTarget","t":4,"rt":PaintingPixelComponent,"sn":"currentTarget"},{"a":1,"n":"returnToPoolCallback","t":4,"rt":Function,"sn":"returnToPoolCallback"}]}; }, $n);
    /*CollectorProjectileController end.*/

    /*EnableRandomRotate start.*/
    $m("EnableRandomRotate", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[1].Void},{"a":2,"n":"RandomRotate","t":8,"sn":"RandomRotate","rt":$n[1].Void},{"a":2,"n":"Target","t":4,"rt":$n[2].Transform,"sn":"Target"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"maxY","t":4,"rt":$n[1].Single,"sn":"maxY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"minY","t":4,"rt":$n[1].Single,"sn":"minY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*EnableRandomRotate end.*/

    /*IdleMoveUpDown start.*/
    $m("IdleMoveUpDown", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[1].Void},{"a":1,"n":"CreateMoveTween","t":8,"sn":"CreateMoveTween","rt":$n[1].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[1].Void},{"a":2,"n":"PlayTween","t":8,"sn":"PlayTween","rt":$n[1].Void},{"a":2,"n":"StopTween","t":8,"sn":"StopTween","rt":$n[1].Void},{"a":2,"n":"duration","t":4,"rt":$n[1].Single,"sn":"duration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"ease","t":4,"rt":$n[5].Ease,"sn":"ease","box":function ($v) { return Bridge.box($v, DG.Tweening.Ease, System.Enum.toStringFn(DG.Tweening.Ease));}},{"a":2,"n":"moveAmount","t":4,"rt":$n[1].Single,"sn":"moveAmount","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"moveTween","t":4,"rt":$n[5].Tween,"sn":"moveTween"},{"a":2,"n":"target","t":4,"rt":$n[2].Transform,"sn":"target"}]}; }, $n);
    /*IdleMoveUpDown end.*/

    /*IdleRotate start.*/
    $m("IdleRotate", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"BoostSpeed","t":8,"pi":[{"n":"speed","pt":$n[1].Single,"ps":0}],"sn":"BoostSpeed","rt":$n[1].Void,"p":[$n[1].Single]},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[1].Void},{"a":2,"n":"StartRotate","t":8,"sn":"StartRotate","rt":$n[1].Void},{"a":2,"n":"StopRotate","t":8,"sn":"StopRotate","rt":$n[1].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[1].Void},{"a":2,"n":"Active","t":4,"rt":$n[1].Boolean,"sn":"Active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"frameCounter","t":4,"rt":$n[1].Int32,"sn":"frameCounter","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"frameInterval","t":4,"rt":$n[1].Int32,"sn":"frameInterval","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.HeaderAttribute("STAT")],"a":2,"n":"rotationSpeed","t":4,"rt":$n[2].Vector3,"sn":"rotationSpeed"},{"at":[new UnityEngine.HeaderAttribute("OBJECT")],"a":2,"n":"target","t":4,"rt":$n[2].Transform,"sn":"target"},{"a":1,"n":"temporarySpeedBoost","t":4,"rt":$n[1].Single,"sn":"temporarySpeedBoost","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*IdleRotate end.*/

    /*InGameEffectOptions start.*/
    $m("InGameEffectOptions", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "IngameEffectSetting", menuName: "ColorPixelFlow/Ingame Effect Options", order: 1
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"BlockScaleFactorWhenDestroyed","t":4,"rt":$n[1].Single,"sn":"BlockScaleFactorWhenDestroyed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"BulletScale","t":4,"rt":$n[1].Single,"sn":"BulletScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("BULLET")],"a":2,"n":"BulletSpeed","t":4,"rt":$n[1].Single,"sn":"BulletSpeed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"ChangeBulletColor","t":4,"rt":$n[1].Boolean,"sn":"ChangeBulletColor","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"ChangeOutlineColor","t":4,"rt":$n[1].Boolean,"sn":"ChangeOutlineColor","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("ANIMATION: COLLECTOR")],"a":2,"n":"IdleRate","t":4,"rt":$n[1].Int32,"sn":"IdleRate","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"RabbitEarAnimation","t":4,"rt":$n[1].Boolean,"sn":"RabbitEarAnimation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"RabbitRandomIdleAnimation","t":4,"rt":$n[1].Boolean,"sn":"RabbitRandomIdleAnimation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("ANIMATION: BLOCK")],"a":2,"n":"ShakeNeighborBlocks","t":4,"rt":$n[1].Boolean,"sn":"ShakeNeighborBlocks","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"ShakeValue","t":4,"rt":$n[1].Single,"sn":"ShakeValue","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*InGameEffectOptions end.*/

    /*AlertFullSlotAnim start.*/
    $m("AlertFullSlotAnim", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[1].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[1].Void},{"a":2,"n":"PlayAlertAnim","t":8,"sn":"PlayAlertAnim","rt":$n[1].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"alertImages","t":4,"rt":System.Array.type(UnityEngine.UI.Image),"sn":"alertImages"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"animDuration","t":4,"rt":$n[1].Single,"sn":"animDuration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"cachedSequences","t":4,"rt":System.Array.type(DG.Tweening.Sequence),"sn":"cachedSequences"},{"a":1,"n":"timeDelayShow","t":4,"rt":$n[1].Single,"sn":"timeDelayShow","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*AlertFullSlotAnim end.*/

    /*CollectorColumnController start.*/
    $m("CollectorColumnController", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[1].Void},{"a":1,"n":"CacheSystemReferences","t":8,"sn":"CacheSystemReferences","rt":$n[1].Void},{"a":2,"n":"DeHighlightRows","t":8,"pi":[{"n":"row","dv":5,"o":true,"pt":$n[1].Int32,"ps":0}],"sn":"DeHighlightRows","rt":$n[1].Void,"p":[$n[1].Int32]},{"a":2,"n":"GetLockReadyToUnlock","t":8,"sn":"GetLockReadyToUnlock","rt":CollectorController},{"a":2,"n":"HighlightRows","t":8,"pi":[{"n":"row","dv":5,"o":true,"pt":$n[1].Int32,"ps":0},{"n":"min","dv":0.0,"o":true,"pt":$n[1].Single,"ps":1},{"n":"max","dv":1.5,"o":true,"pt":$n[1].Single,"ps":2},{"n":"duration","dv":0.5,"o":true,"pt":$n[1].Single,"ps":3}],"sn":"HighlightRows","rt":$n[1].Void,"p":[$n[1].Int32,$n[1].Single,$n[1].Single,$n[1].Single]},{"a":2,"n":"OnAKeyReadyToBeCollected","t":8,"sn":"OnAKeyReadyToBeCollected","rt":$n[1].Void},{"a":1,"n":"OnCollectorStartMove","t":8,"pi":[{"n":"collector","pt":CollectorController,"ps":0}],"sn":"OnCollectorStartMove","rt":$n[1].Void,"p":[CollectorController]},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[1].Void},{"a":1,"n":"RegisterEvents","t":8,"sn":"RegisterEvents","rt":$n[1].Void},{"a":2,"n":"RemoveAllCollectorWithColor","t":8,"pi":[{"n":"colorCode","pt":$n[1].String,"ps":0}],"sn":"RemoveAllCollectorWithColor","rt":$n[1].Void,"p":[$n[1].String]},{"a":1,"n":"RemoveAndRePositionCollectors","t":8,"pi":[{"n":"collectorsToRemove","pt":$n[6].List$1(CollectorController),"ps":0}],"sn":"RemoveAndRePositionCollectors","rt":$n[0].IEnumerator,"p":[$n[6].List$1(CollectorController)]},{"a":2,"n":"UpdateHiddenCollectorsState","t":8,"sn":"UpdateHiddenCollectorsState","rt":$n[1].Void},{"a":1,"n":"UpdatePosition","t":8,"pi":[{"n":"collectorsInColumn","pt":$n[6].List$1(CollectorController),"ps":0}],"sn":"UpdatePosition","rt":$n[1].Void,"p":[$n[6].List$1(CollectorController)]},{"a":1,"n":"_cachedCollectorRotation","t":4,"rt":$n[2].Vector3,"sn":"_cachedCollectorRotation"},{"a":1,"n":"_cachedFormationCenter","t":4,"rt":$n[2].Transform,"sn":"_cachedFormationCenter"},{"a":1,"n":"_cachedSpaceBetweenCollectors","t":4,"rt":$n[1].Single,"sn":"_cachedSpaceBetweenCollectors","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"_cachedSpaceBetweenColumns","t":4,"rt":$n[1].Single,"sn":"_cachedSpaceBetweenColumns","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"_cachedWaitForSeconds","is":true,"t":4,"rt":$n[2].WaitForSeconds,"sn":"_cachedWaitForSeconds"},{"a":1,"n":"_colorCodeCache","is":true,"t":4,"rt":$n[6].Dictionary$2(System.String,System.String),"sn":"_colorCodeCache","ro":true},{"a":1,"n":"_tempActiveCollectors","t":4,"rt":$n[6].List$1(CollectorController),"sn":"_tempActiveCollectors","ro":true},{"a":1,"n":"_tempCollectorsToDestroy","t":4,"rt":$n[6].List$1(CollectorController),"sn":"_tempCollectorsToDestroy","ro":true},{"a":1,"n":"_tempCollectorsToRemove","t":4,"rt":$n[6].List$1(CollectorController),"sn":"_tempCollectorsToRemove","ro":true},{"a":1,"n":"_tempDeadCollectors","t":4,"rt":$n[6].List$1(CollectorController),"sn":"_tempDeadCollectors","ro":true},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"collectorsSystem","t":4,"rt":LevelCollectorsSystem,"sn":"collectorsSystem"}]}; }, $n);
    /*CollectorColumnController end.*/

    /*CollectorGameManager start.*/
    $m("CollectorGameManager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[1].Void},{"a":1,"n":"CanMoveCollectorPath","t":8,"pi":[{"n":"controller","pt":CollectorController,"ps":0}],"sn":"CanMoveCollectorPath","rt":$n[1].Boolean,"p":[CollectorController],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"ForceMoveCollector","t":8,"pi":[{"n":"controller","pt":CollectorController,"ps":0}],"sn":"ForceMoveCollector","rt":$n[1].Void,"p":[CollectorController]},{"a":1,"n":"ForceRemoveCollector","t":8,"pi":[{"n":"collector","pt":CollectorController,"ps":0}],"sn":"ForceRemoveCollector","rt":$n[1].Void,"p":[CollectorController]},{"a":1,"n":"HandleStartMoveCollector","t":8,"pi":[{"n":"controller","pt":CollectorController,"ps":0}],"sn":"HandleStartMoveCollector","rt":$n[1].Void,"p":[CollectorController]},{"a":1,"n":"MoveCollectorCoroutine","t":8,"pi":[{"n":"controllers","pt":$n[6].List$1(CollectorController),"ps":0}],"sn":"MoveCollectorCoroutine","rt":$n[0].IEnumerator,"p":[$n[6].List$1(CollectorController)]},{"a":2,"n":"OnCollectorFinished","t":8,"pi":[{"n":"collector","pt":CollectorController,"ps":0}],"sn":"OnCollectorFinished","rt":$n[1].Void,"p":[CollectorController]},{"a":2,"n":"OnCompleteColor","t":8,"pi":[{"n":"collector","pt":CollectorController,"ps":0}],"sn":"OnCompleteColor","rt":$n[1].Void,"p":[CollectorController]},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[1].Void},{"a":1,"n":"OnPauseGame","t":8,"sn":"OnPauseGame","rt":$n[1].Void},{"a":1,"n":"OnResumeGame","t":8,"sn":"OnResumeGame","rt":$n[1].Void},{"at":[new UnityEngine.ContextMenu.ctor("OnRevive")],"a":1,"n":"PauseGame","t":8,"pi":[{"n":"isPause","pt":$n[1].Boolean,"ps":0}],"sn":"PauseGame","rt":$n[1].Void,"p":[$n[1].Boolean]},{"a":1,"n":"ProcessPendingQueueCoroutine","t":8,"sn":"ProcessPendingQueueCoroutine","rt":$n[0].IEnumerator},{"a":2,"n":"RequestMoveCollector","t":8,"pi":[{"n":"controller","pt":CollectorController,"ps":0}],"sn":"RequestMoveCollector","rt":$n[1].Void,"p":[CollectorController]},{"a":2,"n":"ActiveMovingControllers","t":16,"rt":$n[6].HashSet$1(CollectorController),"g":{"a":2,"n":"get_ActiveMovingControllers","t":8,"rt":$n[6].HashSet$1(CollectorController),"fg":"ActiveMovingControllers"},"fn":"ActiveMovingControllers"},{"a":2,"n":"Instance","is":true,"t":16,"rt":CollectorGameManager,"g":{"a":2,"n":"get_Instance","t":8,"rt":CollectorGameManager,"fg":"Instance","is":true},"s":{"a":1,"n":"set_Instance","t":8,"p":[CollectorGameManager],"rt":$n[1].Void,"fs":"Instance","is":true},"fn":"Instance"},{"a":1,"n":"activeMovingControllers","t":4,"rt":$n[6].HashSet$1(CollectorController),"sn":"activeMovingControllers","ro":true},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"canMoveStoreEqualCount","t":4,"rt":$n[1].Boolean,"sn":"canMoveStoreEqualCount","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"collectorOnDead","t":4,"rt":$n[6].List$1(CollectorController),"sn":"collectorOnDead"},{"at":[new UnityEngine.HeaderAttribute("Count click to move Store"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"countClickToMoveStore","t":4,"rt":$n[1].Int32,"sn":"countClickToMoveStore","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.HeaderAttribute("Settings")],"a":2,"n":"distanceTf","t":4,"rt":$n[1].Single,"sn":"distanceTf","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"gamePlaySound","t":4,"rt":GamePlaySound,"sn":"gamePlaySound"},{"a":2,"n":"gameplayManager","t":4,"rt":GameplayManager,"sn":"gameplayManager"},{"a":1,"n":"hasShowPrelose","t":4,"rt":$n[1].Boolean,"sn":"hasShowPrelose","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"inputManager","t":4,"rt":InputManager,"sn":"inputManager"},{"a":1,"n":"isProcessingPending","t":4,"rt":$n[1].Boolean,"sn":"isProcessingPending","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"moveLimiter","t":4,"rt":CollectorMoveLimiter,"sn":"moveLimiter"},{"a":2,"n":"pendingStartInterval","t":4,"rt":$n[1].Single,"sn":"pendingStartInterval","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"pendingStartQueue","t":4,"rt":$n[6].Queue$1(CollectorController),"sn":"pendingStartQueue","ro":true},{"at":[new UnityEngine.HeaderAttribute("Controllers")],"a":2,"n":"queueManager","t":4,"rt":CollectorQueueManager,"sn":"queueManager"},{"a":1,"n":"tempControllers","is":true,"t":4,"rt":$n[6].List$1(CollectorController),"sn":"tempControllers","ro":true},{"a":1,"backing":true,"n":"<Instance>k__BackingField","is":true,"t":4,"rt":CollectorGameManager,"sn":"Instance"}]}; }, $n);
    /*CollectorGameManager end.*/

    /*CollectorMoveLimiter start.*/
    $m("CollectorMoveLimiter", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddMaxActiveMoving","t":8,"pi":[{"n":"increment","dv":1,"o":true,"pt":$n[1].Int32,"ps":0}],"sn":"AddMaxActiveMoving","rt":$n[1].Void,"p":[$n[1].Int32]},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[1].Void},{"a":1,"n":"EnsurePoolSize","t":8,"sn":"EnsurePoolSize","rt":$n[1].Void},{"a":1,"n":"GetAllCollectorsInChain","t":8,"pi":[{"n":"main","pt":CollectorController,"ps":0},{"n":"partner","dv":null,"o":true,"pt":CollectorController,"ps":1}],"sn":"GetAllCollectorsInChain","rt":$n[6].List$1(CollectorController),"p":[CollectorController,CollectorController]},{"a":1,"n":"GetAndRemoveFreePad","t":8,"sn":"GetAndRemoveFreePad","rt":PadController},{"a":2,"n":"GetAvailableSlots","t":8,"sn":"GetAvailableSlots","rt":$n[1].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"GetMaxActiveMoving","t":8,"sn":"GetMaxActiveMoving","rt":$n[1].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"IsFullSlots","t":8,"sn":"IsFullSlots","rt":$n[1].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"OnCollectorMoveFinished","t":8,"pi":[{"n":"collector","pt":CollectorController,"ps":0}],"sn":"OnCollectorMoveFinished","rt":$n[1].Void,"p":[CollectorController]},{"a":1,"n":"ReturnPadToPool","t":8,"pi":[{"n":"pad","pt":PadController,"ps":0}],"sn":"ReturnPadToPool","rt":$n[1].Void,"p":[PadController]},{"a":2,"n":"SetMaxActiveMoving","t":8,"pi":[{"n":"value","pt":$n[1].Int32,"ps":0}],"sn":"SetMaxActiveMoving","rt":$n[1].Void,"p":[$n[1].Int32]},{"a":1,"n":"TextAnimScale","t":8,"sn":"TextAnimScale","rt":$n[1].Void},{"a":2,"n":"TextAnimShakeOnFull","t":8,"sn":"TextAnimShakeOnFull","rt":$n[1].Void},{"a":2,"n":"TryStartMove","t":8,"pi":[{"n":"main","pt":CollectorController,"ps":0},{"n":"partner","dv":null,"o":true,"pt":CollectorController,"ps":1}],"sn":"TryStartMove","rt":$n[1].Boolean,"p":[CollectorController,CollectorController],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"UpdatePoolLayout","t":8,"sn":"UpdatePoolLayout","rt":$n[1].Void},{"a":1,"n":"UpdateText","t":8,"sn":"UpdateText","rt":$n[1].Void},{"a":1,"n":"collectorToPad","t":4,"rt":$n[6].Dictionary$2(CollectorController,PadController),"sn":"collectorToPad"},{"at":[new UnityEngine.HeaderAttribute("References"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"defaultPosition","t":4,"rt":$n[2].Transform,"sn":"defaultPosition"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"limiterText","t":4,"rt":$n[4].TMP_Text,"sn":"limiterText"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"maxActiveMoving","t":4,"rt":$n[1].Int32,"sn":"maxActiveMoving","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"originalPos","t":4,"rt":$n[2].Vector2,"sn":"originalPos"},{"at":[new UnityEngine.HeaderAttribute("Settings"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"padController","t":4,"rt":PadController,"sn":"padController"},{"a":1,"n":"padPool","t":4,"rt":$n[6].List$1(PadController),"sn":"padPool"},{"at":[new UnityEngine.HeaderAttribute("Layout Config"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"padSpacing","t":4,"rt":$n[1].Single,"sn":"padSpacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"poolParent","t":4,"rt":$n[2].Transform,"sn":"poolParent"},{"a":1,"n":"seqShake","t":4,"rt":$n[5].Sequence,"sn":"seqShake"},{"a":1,"n":"textScaleTween","t":4,"rt":$n[5].Tween,"sn":"textScaleTween"}]}; }, $n);
    /*CollectorMoveLimiter end.*/

    /*CollectorQueueManager start.*/
    $m("CollectorQueueManager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddMaxSlot","t":8,"pi":[{"n":"increment","dv":1,"o":true,"pt":$n[1].Int32,"ps":0}],"sn":"AddMaxSlot","rt":$n[1].Void,"p":[$n[1].Int32]},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[1].Void},{"a":2,"n":"EnqueueCollector","t":8,"pi":[{"n":"collector","pt":CollectorController,"ps":0}],"sn":"EnqueueCollector","rt":$n[1].Void,"p":[CollectorController]},{"a":2,"n":"GetLastCollectorInQueue","t":8,"sn":"GetLastCollectorInQueue","rt":CollectorController},{"a":2,"n":"HasEnoughSlotsFor","t":8,"pi":[{"n":"_slot","pt":$n[1].Int32,"ps":0}],"sn":"HasEnoughSlotsFor","rt":$n[1].Boolean,"p":[$n[1].Int32],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsInQueue","t":8,"pi":[{"n":"collector","pt":CollectorController,"ps":0}],"sn":"IsInQueue","rt":$n[1].Boolean,"p":[CollectorController],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsQueueFull","t":8,"sn":"IsQueueFull","rt":$n[1].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"MoveCollectorToDeadPosition","t":8,"pi":[{"n":"collector","pt":CollectorController,"ps":0},{"n":"onComplete","dv":null,"o":true,"pt":Function,"ps":1}],"sn":"MoveCollectorToDeadPosition","rt":$n[1].Void,"p":[CollectorController,Function]},{"a":1,"n":"MoveCollectorToQueuePosition","t":8,"pi":[{"n":"collector","pt":CollectorController,"ps":0},{"n":"index","pt":$n[1].Int32,"ps":1}],"sn":"MoveCollectorToQueuePosition","rt":$n[0].IEnumerator,"p":[CollectorController,$n[1].Int32]},{"a":1,"n":"PushForwardCollectorOnQueue","t":8,"pi":[{"n":"collector","pt":CollectorController,"ps":0},{"n":"index","pt":$n[1].Int32,"ps":1}],"sn":"PushForwardCollectorOnQueue","rt":$n[1].Void,"p":[CollectorController,$n[1].Int32]},{"a":2,"n":"RemoveCollectorFromDeadQueue","t":8,"pi":[{"n":"collector","pt":CollectorController,"ps":0}],"sn":"RemoveCollectorFromDeadQueue","rt":$n[1].Void,"p":[CollectorController]},{"a":2,"n":"RemoveCollectorFromQueue","t":8,"pi":[{"n":"collector","pt":CollectorController,"ps":0}],"sn":"RemoveCollectorFromQueue","rt":$n[1].Void,"p":[CollectorController]},{"a":2,"n":"SetMaxSlot","t":8,"pi":[{"n":"newMaxSlot","pt":$n[1].Int32,"ps":0}],"sn":"SetMaxSlot","rt":$n[1].Void,"p":[$n[1].Int32]},{"a":2,"n":"alertFullSlotAnim","t":4,"rt":AlertFullSlotAnim,"sn":"alertFullSlotAnim"},{"a":2,"n":"deadOffset","t":4,"rt":$n[2].Vector3,"sn":"deadOffset"},{"a":2,"n":"deadQueue","t":4,"rt":$n[6].List$1(CollectorController),"sn":"deadQueue"},{"a":2,"n":"defaultDeadPosition","t":4,"rt":$n[2].Transform,"sn":"defaultDeadPosition"},{"a":2,"n":"maxSlot","t":4,"rt":$n[1].Int32,"sn":"maxSlot","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"queueArray","t":4,"rt":System.Array.type(CollectorController),"sn":"queueArray"},{"a":2,"n":"queuePositions","t":4,"rt":System.Array.type(UnityEngine.Transform),"sn":"queuePositions"}]}; }, $n);
    /*CollectorQueueManager end.*/

    /*GameplayManager start.*/
    $m("GameplayManager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"IsFirstLevelAndNotLast","t":8,"sn":"IsFirstLevelAndNotLast","rt":$n[1].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"OnCollectorDead","t":8,"pi":[{"n":"collectors","pt":CollectorController,"ps":0}],"sn":"OnCollectorDead","rt":$n[1].Void,"p":[CollectorController]},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[1].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[1].Void},{"a":1,"n":"OnEndGameAction","t":8,"pi":[{"n":"isWin","pt":$n[1].Boolean,"ps":0}],"sn":"OnEndGameAction","rt":$n[1].Void,"p":[$n[1].Boolean]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[1].Void},{"at":[new UnityEngine.ContextMenu.ctor("Start Game")],"a":1,"n":"StartGame","t":8,"sn":"StartGame","rt":$n[1].Void},{"a":2,"n":"IsStoreLimitForFirstLevelEnabled","t":16,"rt":$n[1].Boolean,"g":{"a":2,"n":"get_IsStoreLimitForFirstLevelEnabled","t":8,"rt":$n[1].Boolean,"fg":"IsStoreLimitForFirstLevelEnabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsStoreLimitForFirstLevelEnabled"},{"a":2,"n":"LevelId","t":16,"rt":$n[1].Int32,"g":{"a":2,"n":"get_LevelId","t":8,"rt":$n[1].Int32,"fg":"LevelId","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"LevelId"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"currentLevelConfig","t":4,"rt":LevelConfig,"sn":"currentLevelConfig"},{"at":[new UnityEngine.HeaderAttribute("Playable Store Config"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"enableStoreLimitForFirstLevel","t":4,"rt":$n[1].Boolean,"sn":"enableStoreLimitForFirstLevel","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"levelCollectorsSystem","t":4,"rt":LevelCollectorsSystem,"sn":"levelCollectorsSystem"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"levelGamePlayConfig","t":4,"rt":LevelGamePlayConfigSO,"sn":"levelGamePlayConfig"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"levelId","t":4,"rt":$n[1].Int32,"sn":"levelId","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"levelSetup","t":4,"rt":LevelConfigSetup,"sn":"levelSetup"}]}; }, $n);
    /*GameplayManager end.*/

    /*GamePlaySound start.*/
    $m("GamePlaySound", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"PlayClickCat","t":8,"sn":"PlayClickCat","rt":$n[1].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"clickCatSound","t":4,"rt":$n[2].AudioSource,"sn":"clickCatSound"}]}; }, $n);
    /*GamePlaySound end.*/

    /*InputManager start.*/
    $m("InputManager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[1].Void},{"a":2,"n":"BlockGameplayInput","t":8,"sn":"BlockGameplayInput","rt":$n[1].Void},{"a":1,"n":"CanProcessInput","t":8,"sn":"CanProcessInput","rt":$n[1].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"HandleBoosterCollectorChoosenInput","t":8,"sn":"HandleBoosterCollectorChoosenInput","rt":$n[1].Void},{"a":2,"n":"HandleCollectorChoosenInput","t":8,"sn":"HandleCollectorChoosenInput","rt":$n[1].Void},{"a":2,"n":"HandleSuperRabbitBoosterInput","t":8,"sn":"HandleSuperRabbitBoosterInput","rt":$n[1].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[1].Void},{"a":1,"n":"PerformRaycast","t":8,"pi":[{"n":"screenPoint","pt":$n[2].Vector3,"ps":0},{"n":"mask","pt":$n[2].LayerMask,"ps":1}],"sn":"PerformRaycast","rt":$n[1].Nullable$1(UnityEngine.RaycastHit),"p":[$n[2].Vector3,$n[2].LayerMask]},{"a":2,"n":"StartAllowPlayerToChooseBlock","t":8,"sn":"StartAllowPlayerToChooseBlock","rt":$n[1].Void},{"a":2,"n":"StartAllowPlayerToFreelyPick","t":8,"sn":"StartAllowPlayerToFreelyPick","rt":$n[1].Void},{"a":2,"n":"StopAllowPlayerToChooseBlock","t":8,"sn":"StopAllowPlayerToChooseBlock","rt":$n[1].Void},{"a":2,"n":"StopAllowPlayerToFreePick","t":8,"sn":"StopAllowPlayerToFreePick","rt":$n[1].Void},{"a":2,"n":"UnBlockGameplayInput","t":8,"sn":"UnBlockGameplayInput","rt":$n[1].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[1].Void},{"a":2,"n":"UpdateLastClickTime","t":8,"sn":"UpdateLastClickTime","rt":$n[1].Void},{"at":[new UnityEngine.HeaderAttribute("INPUT CONDITION(s)")],"a":2,"n":"BlockInput","t":4,"rt":$n[1].Boolean,"sn":"BlockInput","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("LAYER SETUP")],"a":2,"n":"CubeLayermask","t":4,"rt":$n[2].LayerMask,"sn":"CubeLayermask"},{"a":2,"n":"IsChoosingBlock","t":4,"rt":$n[1].Boolean,"sn":"IsChoosingBlock","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsFreePicking","t":4,"rt":$n[1].Boolean,"sn":"IsFreePicking","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"cachedMousePosition","t":4,"rt":$n[2].Vector3,"sn":"cachedMousePosition"},{"a":1,"n":"cachedRay","t":4,"rt":$n[2].Ray,"sn":"cachedRay"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"clickCooldown","t":4,"rt":$n[1].Single,"sn":"clickCooldown","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"collectorLayerMask","t":4,"rt":$n[1].Int32,"sn":"collectorLayerMask","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"gamePlayCamera","t":4,"rt":$n[2].Camera,"sn":"gamePlayCamera"},{"a":1,"n":"hitInfo","t":4,"rt":$n[2].RaycastHit,"sn":"hitInfo"},{"a":1,"n":"lastClickTime","t":4,"rt":$n[1].Single,"sn":"lastClickTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*InputManager end.*/

    /*PadController start.*/
    $m("PadController", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"DeferredSetParent","t":8,"pi":[{"n":"parent","pt":$n[2].Transform,"ps":0}],"sn":"DeferredSetParent","rt":$n[0].IEnumerator,"p":[$n[2].Transform]},{"a":2,"n":"OnCollectorEnterPad","t":8,"pi":[{"n":"collector","pt":CollectorController,"ps":0}],"sn":"OnCollectorEnterPad","rt":$n[1].Void,"p":[CollectorController]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[1].Void},{"a":2,"n":"PushForwardPad","t":8,"pi":[{"n":"targetPos","pt":$n[2].Vector3,"ps":0}],"sn":"PushForwardPad","rt":$n[1].Void,"p":[$n[2].Vector3]},{"a":2,"n":"ResetToDefault","t":8,"pi":[{"n":"position","pt":$n[2].Vector3,"ps":0},{"n":"parent","dv":null,"o":true,"pt":$n[2].Transform,"ps":1}],"sn":"ResetToDefault","rt":$n[1].Void,"p":[$n[2].Vector3,$n[2].Transform]},{"a":1,"n":"SetPositionAfterDelay","t":8,"sn":"SetPositionAfterDelay","rt":$n[1].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[1].Void},{"a":2,"n":"HasCollectorOnPad","t":4,"rt":$n[1].Boolean,"sn":"HasCollectorOnPad","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("EFFECT(s)")],"a":2,"n":"PadSmokeFX","t":4,"rt":$n[2].ParticleSystem,"sn":"PadSmokeFX"},{"a":1,"n":"_pendingCollector","t":4,"rt":CollectorController,"sn":"_pendingCollector"},{"a":2,"n":"meshTrans","t":4,"rt":$n[2].Transform,"sn":"meshTrans"},{"a":1,"n":"padMoveTween","t":4,"rt":$n[5].Tween,"sn":"padMoveTween"},{"a":1,"n":"padRotateTween","t":4,"rt":$n[5].Tween,"sn":"padRotateTween"},{"a":2,"n":"startTrans","t":4,"rt":$n[2].Transform,"sn":"startTrans"}]}; }, $n);
    /*PadController end.*/

    /*GameplayEventsManager start.*/
    $m("GameplayEventsManager", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"InstallFullGame","is":true,"t":8,"sn":"InstallFullGame","rt":$n[1].Void},{"a":2,"n":"CompleteColor","is":true,"t":4,"rt":Function,"sn":"CompleteColor"},{"a":2,"n":"ForceRemoveCollectorActive","is":true,"t":4,"rt":Function,"sn":"ForceRemoveCollectorActive"},{"a":2,"n":"GetFirstCollector","is":true,"t":4,"rt":Function,"sn":"GetFirstCollector"},{"a":2,"n":"OnACollectorFinishMove","is":true,"t":4,"rt":Function,"sn":"OnACollectorFinishMove"},{"a":2,"n":"OnACollectorMoveToQueue","is":true,"t":4,"rt":Function,"sn":"OnACollectorMoveToQueue"},{"a":2,"n":"OnAKeyReadyToBeCollected","is":true,"t":4,"rt":Function,"sn":"OnAKeyReadyToBeCollected"},{"a":2,"n":"OnAPipePixelDestroyed","is":true,"t":4,"rt":Function,"sn":"OnAPipePixelDestroyed"},{"a":2,"n":"OnAPixelDestroyed","is":true,"t":4,"rt":Function,"sn":"OnAPixelDestroyed"},{"a":2,"n":"OnAPixelDestroyedByCollector","is":true,"t":4,"rt":Function,"sn":"OnAPixelDestroyedByCollector"},{"a":2,"n":"OnAbsoluteWin","is":true,"t":4,"rt":Function,"sn":"OnAbsoluteWin"},{"a":2,"n":"OnBlockDissapear","is":true,"t":4,"rt":Function,"sn":"OnBlockDissapear"},{"a":2,"n":"OnBlockGamePlayInput","is":true,"t":4,"rt":Function,"sn":"OnBlockGamePlayInput"},{"a":2,"n":"OnCancelExecuteBooster","is":true,"t":4,"rt":Function,"sn":"OnCancelExecuteBooster"},{"a":2,"n":"OnClickACollector","is":true,"t":4,"rt":Function,"sn":"OnClickACollector"},{"a":2,"n":"OnCollectAKey","is":true,"t":4,"rt":Function,"sn":"OnCollectAKey"},{"a":2,"n":"OnCollectorMoveToConveyor","is":true,"t":4,"rt":Function,"sn":"OnCollectorMoveToConveyor"},{"a":2,"n":"OnCollectorMoveToFirstLine","is":true,"t":4,"rt":Function,"sn":"OnCollectorMoveToFirstLine"},{"a":2,"n":"OnCollectorRevealed","is":true,"t":4,"rt":Function,"sn":"OnCollectorRevealed"},{"a":2,"n":"OnCollectorStartMove","is":true,"t":4,"rt":Function,"sn":"OnCollectorStartMove"},{"a":2,"n":"OnCollectorsSquadChanged","is":true,"t":4,"rt":Function,"sn":"OnCollectorsSquadChanged"},{"a":2,"n":"OnEndExecuteBoosterNeedToHideUI","is":true,"t":4,"rt":Function,"sn":"OnEndExecuteBoosterNeedToHideUI"},{"a":2,"n":"OnEndGame","is":true,"t":4,"rt":Function,"sn":"OnEndGame"},{"a":2,"n":"OnExecuteBooster","is":true,"t":4,"rt":Function,"sn":"OnExecuteBooster"},{"a":2,"n":"OnExecuteBoosterNeedToHideUI","is":true,"t":4,"rt":Function,"sn":"OnExecuteBoosterNeedToHideUI"},{"a":2,"n":"OnFreePickACollector","is":true,"t":4,"rt":Function,"sn":"OnFreePickACollector"},{"a":2,"n":"OnGridObjectChanged","is":true,"t":4,"rt":Function,"sn":"OnGridObjectChanged"},{"a":2,"n":"OnGridPixelsDestroyedPassive","is":true,"t":4,"rt":Function,"sn":"OnGridPixelsDestroyedPassive"},{"a":2,"n":"OnPaintingInitializeDone","is":true,"t":4,"rt":Function,"sn":"OnPaintingInitializeDone"},{"a":2,"n":"OnSuperRabbitBlockSelected","is":true,"t":4,"rt":Function,"sn":"OnSuperRabbitBlockSelected"},{"a":2,"n":"OnUnlockLockObject","is":true,"t":4,"rt":Function,"sn":"OnUnlockLockObject"},{"a":2,"n":"PauseGame","is":true,"t":4,"rt":Function,"sn":"PauseGame"},{"a":2,"n":"ShowPopupRevive","is":true,"t":4,"rt":Function,"sn":"ShowPopupRevive"}]}; }, $n);
    /*GameplayEventsManager end.*/

    /*BulletDisplayHandler start.*/
    $m("BulletDisplayHandler", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[1].Void},{"a":1,"n":"ScaleText","t":8,"pi":[{"n":"isScale","pt":$n[1].Boolean,"ps":0}],"sn":"ScaleText","rt":$n[1].Void,"p":[$n[1].Boolean]},{"a":2,"n":"SetFadeText","t":8,"pi":[{"n":"isFaded","pt":$n[1].Boolean,"ps":0}],"sn":"SetFadeText","rt":$n[1].Void,"p":[$n[1].Boolean]},{"a":2,"n":"SetUpdateText","t":8,"pi":[{"n":"enable","pt":$n[1].Boolean,"ps":0}],"sn":"SetUpdateText","rt":$n[1].Void,"p":[$n[1].Boolean]},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[1].Void},{"a":2,"n":"UpdateBulletDisplay","t":8,"pi":[{"n":"bulletLeft","pt":$n[1].Int32,"ps":0}],"sn":"UpdateBulletDisplay","rt":$n[1].Void,"p":[$n[1].Int32]},{"a":1,"n":"UpdateRotateText","t":8,"sn":"UpdateRotateText","rt":$n[1].Void},{"a":2,"n":"Collector","t":4,"rt":ColorPixelsCollectorObject,"sn":"Collector"},{"a":1,"n":"_textTransform","t":4,"rt":$n[2].Transform,"sn":"_textTransform"},{"a":1,"n":"cachedWorldForward","t":4,"rt":$n[2].Quaternion,"sn":"cachedWorldForward"},{"a":1,"n":"camTrans","t":4,"rt":$n[2].Transform,"sn":"camTrans"},{"a":1,"n":"needUpdateText","t":4,"rt":$n[1].Boolean,"sn":"needUpdateText","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"scaleTwween","t":4,"rt":$n[5].Tween,"sn":"scaleTwween"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"text","t":4,"rt":$n[4].TMP_Text,"sn":"text"}]}; }, $n);
    /*BulletDisplayHandler end.*/

    /*CachedTransformPathMover start.*/
    $m("CachedTransformPathMover", function () { return {"nested":[CachedTransformPathMover.RotationInterpolationType,CachedTransformPathMover.MovementType],"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ChangeMovementType","t":8,"pi":[{"n":"newType","pt":CachedTransformPathMover.MovementType,"ps":0}],"sn":"ChangeMovementType","rt":$n[1].Void,"p":[CachedTransformPathMover.MovementType]},{"a":2,"n":"GetPositionAtDistance","t":8,"pi":[{"n":"distance","pt":$n[1].Single,"ps":0}],"sn":"GetPositionAtDistance","rt":$n[2].Vector3,"p":[$n[1].Single]},{"a":2,"n":"GetPositionAtTF","t":8,"pi":[{"n":"tf","pt":$n[1].Single,"ps":0}],"sn":"GetPositionAtTF","rt":$n[2].Vector3,"p":[$n[1].Single]},{"a":2,"n":"GetTangentAtDistance","t":8,"pi":[{"n":"distance","pt":$n[1].Single,"ps":0}],"sn":"GetTangentAtDistance","rt":$n[2].Vector3,"p":[$n[1].Single]},{"a":2,"n":"GetTangentAtTF","t":8,"pi":[{"n":"tf","pt":$n[1].Single,"ps":0}],"sn":"GetTangentAtTF","rt":$n[2].Vector3,"p":[$n[1].Single]},{"a":2,"n":"GetUpVectorAtDistance","t":8,"pi":[{"n":"distance","pt":$n[1].Single,"ps":0}],"sn":"GetUpVectorAtDistance","rt":$n[2].Vector3,"p":[$n[1].Single]},{"a":2,"n":"GetUpVectorAtTF","t":8,"pi":[{"n":"tf","pt":$n[1].Single,"ps":0}],"sn":"GetUpVectorAtTF","rt":$n[2].Vector3,"p":[$n[1].Single]},{"a":2,"n":"HandleSelectCollector","t":8,"pi":[{"n":"tf","pt":$n[1].Single,"ps":0},{"n":"callbackOnFinish","pt":Function,"ps":1}],"sn":"HandleSelectCollector","rt":$n[1].Void,"p":[$n[1].Single,Function]},{"a":1,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[1].Void},{"a":2,"n":"IsPathValid","t":8,"sn":"IsPathValid","rt":$n[1].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"MoveAlongPath","t":8,"sn":"MoveAlongPath","rt":$n[1].Void},{"a":2,"n":"PauseMovement","t":8,"sn":"PauseMovement","rt":$n[1].Void},{"a":2,"n":"SetDirection","t":8,"pi":[{"n":"newDirection","pt":$n[1].Int32,"ps":0}],"sn":"SetDirection","rt":$n[1].Void,"p":[$n[1].Int32]},{"a":2,"n":"SetMovementDirection","t":8,"pi":[{"n":"newDirection","pt":$n[1].Int32,"ps":0}],"sn":"SetMovementDirection","rt":$n[1].Void,"p":[$n[1].Int32]},{"a":2,"n":"SetPositionByDistance","t":8,"pi":[{"n":"distance","pt":$n[1].Single,"ps":0}],"sn":"SetPositionByDistance","rt":$n[1].Void,"p":[$n[1].Single]},{"a":2,"n":"SetPositionByTF","t":8,"pi":[{"n":"tf","pt":$n[1].Single,"ps":0}],"sn":"SetPositionByTF","rt":$n[1].Void,"p":[$n[1].Single]},{"a":2,"n":"SetSpeed","t":8,"pi":[{"n":"newSpeed","pt":$n[1].Single,"ps":0}],"sn":"SetSpeed","rt":$n[1].Void,"p":[$n[1].Single]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[1].Void},{"a":2,"n":"StartMovement","t":8,"sn":"StartMovement","rt":$n[1].Void},{"a":2,"n":"StartMovementByTF","t":8,"pi":[{"n":"targetTF","pt":$n[1].Single,"ps":0}],"sn":"StartMovementByTF","rt":$n[1].Void,"p":[$n[1].Single]},{"a":2,"n":"StopMovement","t":8,"sn":"StopMovement","rt":$n[1].Void},{"a":2,"n":"StopMovementAtCurrentPosition","t":8,"sn":"StopMovementAtCurrentPosition","rt":$n[1].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[1].Void},{"a":1,"n":"UpdatePositionByDistance","t":8,"pi":[{"n":"distance","pt":$n[1].Single,"ps":0}],"sn":"UpdatePositionByDistance","rt":$n[1].Void,"p":[$n[1].Single]},{"a":1,"n":"UpdatePositionByTF","t":8,"pi":[{"n":"tf","pt":$n[1].Single,"ps":0}],"sn":"UpdatePositionByTF","rt":$n[1].Void,"p":[$n[1].Single]},{"a":1,"n":"Path","t":16,"rt":PathTransformBasedCached,"g":{"a":1,"n":"get_Path","t":8,"rt":PathTransformBasedCached,"fg":"Path"},"fn":"Path"},{"a":2,"n":"LoopClamp","t":4,"rt":$n[2].Vector2,"sn":"LoopClamp"},{"a":1,"n":"OnMoveFinished","t":4,"rt":Function,"sn":"OnMoveFinished"},{"a":2,"n":"PingPongClamp","t":4,"rt":$n[2].Vector2,"sn":"PingPongClamp"},{"at":[new UnityEngine.HeaderAttribute("Automatic Movement")],"a":2,"n":"autoMove","t":4,"rt":$n[1].Boolean,"sn":"autoMove","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"cachedDeltaTime","t":4,"rt":$n[1].Single,"sn":"cachedDeltaTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"cachedNewRotation","t":4,"rt":$n[2].Quaternion,"sn":"cachedNewRotation"},{"a":1,"n":"cachedOrientationSpeedDeltaTime","t":4,"rt":$n[1].Single,"sn":"cachedOrientationSpeedDeltaTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"cachedPosition","t":4,"rt":$n[2].Vector3,"sn":"cachedPosition"},{"a":1,"n":"cachedSmoothOrientation","t":4,"rt":$n[1].Boolean,"sn":"cachedSmoothOrientation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"cachedTangent","t":4,"rt":$n[2].Vector3,"sn":"cachedTangent"},{"a":1,"n":"cachedUpVector","t":4,"rt":$n[2].Vector3,"sn":"cachedUpVector"},{"at":[new UnityEngine.TooltipAttribute("Current position along the spline in world units")],"a":2,"n":"currentDistance","t":4,"rt":$n[1].Single,"sn":"currentDistance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("Current position along the spline as a 0-1 value (0 = start, 1 = end)"),new UnityEngine.RangeAttribute(0.0, 1.0)],"a":2,"n":"currentTF","t":4,"rt":$n[1].Single,"sn":"currentTF","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("Movement direction: 1 for forward, -1 for backward")],"a":2,"n":"direction","t":4,"rt":$n[1].Int32,"sn":"direction","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.TooltipAttribute("End position for Clamp movement type as a 0-1 value (0 = start, 1 = end)"),new UnityEngine.RangeAttribute(0.0, 1.0)],"a":2,"n":"endTF","t":4,"rt":$n[1].Single,"sn":"endTF","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"isInitialized","t":4,"rt":$n[1].Boolean,"sn":"isInitialized","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"isWaitingToStart","t":4,"rt":$n[1].Boolean,"sn":"isWaitingToStart","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("Movement Type")],"a":2,"n":"movementType","t":4,"rt":CachedTransformPathMover.MovementType,"sn":"movementType","box":function ($v) { return Bridge.box($v, CachedTransformPathMover.MovementType, System.Enum.toStringFn(CachedTransformPathMover.MovementType));}},{"a":1,"n":"moverTransform","t":4,"rt":$n[2].Transform,"sn":"moverTransform"},{"at":[new UnityEngine.HeaderAttribute("Orientation")],"a":2,"n":"orientToPath","t":4,"rt":$n[1].Boolean,"sn":"orientToPath","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"orientationSpace","t":4,"rt":$n[2].Space,"sn":"orientationSpace","box":function ($v) { return Bridge.box($v, UnityEngine.Space, System.Enum.toStringFn(UnityEngine.Space));}},{"at":[new UnityEngine.TooltipAttribute("Speed of rotation interpolation (higher = faster)")],"a":2,"n":"orientationSpeed","t":4,"rt":$n[1].Single,"sn":"orientationSpeed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"pathValid","t":4,"rt":$n[1].Boolean,"sn":"pathValid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"previousTargetRotation","t":4,"rt":$n[2].Quaternion,"sn":"previousTargetRotation"},{"at":[new UnityEngine.TooltipAttribute("Interpolation method for rotation smoothing")],"a":2,"n":"rotationInterpolation","t":4,"rt":CachedTransformPathMover.RotationInterpolationType,"sn":"rotationInterpolation","box":function ($v) { return Bridge.box($v, CachedTransformPathMover.RotationInterpolationType, System.Enum.toStringFn(CachedTransformPathMover.RotationInterpolationType));}},{"a":1,"n":"shouldUpdateOrientation","t":4,"rt":$n[1].Boolean,"sn":"shouldUpdateOrientation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("Smooth Orientation"),new UnityEngine.TooltipAttribute("Enable smooth rotation instead of instant orientation")],"a":2,"n":"smoothOrientation","t":4,"rt":$n[1].Boolean,"sn":"smoothOrientation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("Movement Settings"),new UnityEngine.TooltipAttribute("Movement speed in units per second")],"a":2,"n":"speed","t":4,"rt":$n[1].Single,"sn":"speed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"startDelayTimer","t":4,"rt":$n[1].Single,"sn":"startDelayTimer","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"targetRotation","t":4,"rt":$n[2].Quaternion,"sn":"targetRotation"},{"at":[new UnityEngine.HeaderAttribute("Movement Mode")],"a":2,"n":"useDistanceBasedMovement","t":4,"rt":$n[1].Boolean,"sn":"useDistanceBasedMovement","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*CachedTransformPathMover end.*/

    /*CachedTransformPathMover+RotationInterpolationType start.*/
    $m("CachedTransformPathMover.RotationInterpolationType", function () { return {"td":CachedTransformPathMover,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Linear","is":true,"t":4,"rt":CachedTransformPathMover.RotationInterpolationType,"sn":"Linear","box":function ($v) { return Bridge.box($v, CachedTransformPathMover.RotationInterpolationType, System.Enum.toStringFn(CachedTransformPathMover.RotationInterpolationType));}},{"a":2,"n":"Spherical","is":true,"t":4,"rt":CachedTransformPathMover.RotationInterpolationType,"sn":"Spherical","box":function ($v) { return Bridge.box($v, CachedTransformPathMover.RotationInterpolationType, System.Enum.toStringFn(CachedTransformPathMover.RotationInterpolationType));}}]}; }, $n);
    /*CachedTransformPathMover+RotationInterpolationType end.*/

    /*CachedTransformPathMover+MovementType start.*/
    $m("CachedTransformPathMover.MovementType", function () { return {"td":CachedTransformPathMover,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clamp","is":true,"t":4,"rt":CachedTransformPathMover.MovementType,"sn":"Clamp","box":function ($v) { return Bridge.box($v, CachedTransformPathMover.MovementType, System.Enum.toStringFn(CachedTransformPathMover.MovementType));}},{"a":2,"n":"Loop","is":true,"t":4,"rt":CachedTransformPathMover.MovementType,"sn":"Loop","box":function ($v) { return Bridge.box($v, CachedTransformPathMover.MovementType, System.Enum.toStringFn(CachedTransformPathMover.MovementType));}},{"a":2,"n":"LoopClamp","is":true,"t":4,"rt":CachedTransformPathMover.MovementType,"sn":"LoopClamp","box":function ($v) { return Bridge.box($v, CachedTransformPathMover.MovementType, System.Enum.toStringFn(CachedTransformPathMover.MovementType));}},{"a":2,"n":"PingPong","is":true,"t":4,"rt":CachedTransformPathMover.MovementType,"sn":"PingPong","box":function ($v) { return Bridge.box($v, CachedTransformPathMover.MovementType, System.Enum.toStringFn(CachedTransformPathMover.MovementType));}}]}; }, $n);
    /*CachedTransformPathMover+MovementType end.*/

    /*CollectorAnimation start.*/
    $m("CollectorAnimation", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[1].Void},{"a":1,"n":"CacheBreathTween","t":8,"sn":"CacheBreathTween","rt":$n[1].Void},{"a":1,"n":"CacheStretchTween","t":8,"sn":"CacheStretchTween","rt":$n[1].Void},{"a":1,"n":"CompleteColorPixelsAnimation","t":8,"pi":[{"n":"actionOnComplete","dv":null,"o":true,"pt":Function,"ps":0}],"sn":"CompleteColorPixelsAnimation","rt":$n[1].Void,"p":[Function]},{"a":1,"n":"CreateJumpTween","t":8,"sn":"CreateJumpTween","rt":$n[1].Void},{"a":1,"n":"CreateSquashTween","t":8,"sn":"CreateSquashTween","rt":$n[1].Void},{"a":2,"n":"DelayStartBreathing","t":8,"pi":[{"n":"extraDelay","dv":0.0,"o":true,"pt":$n[1].Single,"ps":0}],"sn":"DelayStartBreathing","rt":$n[0].IEnumerator,"p":[$n[1].Single]},{"a":1,"n":"MoveToBeltPosition","t":8,"pi":[{"n":"newPos","pt":$n[2].Vector3,"ps":0},{"n":"actionOnComplete","dv":null,"o":true,"pt":Function,"ps":1}],"sn":"MoveToBeltPosition","rt":$n[1].Void,"p":[$n[2].Vector3,Function]},{"a":1,"n":"MoveToDeadPosition","t":8,"pi":[{"n":"newPos","pt":$n[2].Vector3,"ps":0},{"n":"actionOnComplete","dv":null,"o":true,"pt":Function,"ps":1}],"sn":"MoveToDeadPosition","rt":$n[1].Void,"p":[$n[2].Vector3,Function]},{"a":1,"n":"MoveToQueuePosition","t":8,"pi":[{"n":"newPos","pt":$n[2].Vector3,"ps":0},{"n":"actionOnComplete","dv":null,"o":true,"pt":Function,"ps":1}],"sn":"MoveToQueuePosition","rt":$n[1].Void,"p":[$n[2].Vector3,Function]},{"a":1,"n":"MoveToQueueRotateBack","t":8,"pi":[{"n":"newPos","pt":$n[2].Vector3,"ps":0},{"n":"actionOnComplete","dv":null,"o":true,"pt":Function,"ps":1}],"sn":"MoveToQueueRotateBack","rt":$n[1].Void,"p":[$n[2].Vector3,Function]},{"a":1,"n":"OnClickACollector","t":8,"pi":[{"n":"_collector","pt":CollectorController,"ps":0},{"n":"canBeMoved","pt":$n[1].Boolean,"ps":1}],"sn":"OnClickACollector","rt":$n[1].Void,"p":[CollectorController,$n[1].Boolean]},{"a":1,"n":"OnCollectorMoveToBelt","t":8,"pi":[{"n":"_collector","pt":CollectorController,"ps":0}],"sn":"OnCollectorMoveToBelt","rt":$n[1].Void,"p":[CollectorController]},{"a":1,"n":"OnCollectorMoveToFirstLine","t":8,"pi":[{"n":"_collector","pt":CollectorController,"ps":0},{"n":"hidden","pt":$n[1].Boolean,"ps":1}],"sn":"OnCollectorMoveToFirstLine","rt":$n[1].Void,"p":[CollectorController,$n[1].Boolean]},{"a":1,"n":"OnCollectorStartMove","t":8,"pi":[{"n":"_collector","pt":CollectorController,"ps":0}],"sn":"OnCollectorStartMove","rt":$n[1].Void,"p":[CollectorController]},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[1].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[1].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[1].Void},{"a":2,"n":"PlayAnim","t":8,"pi":[{"n":"vector3","pt":$n[2].Vector3,"ps":0},{"n":"animState","pt":CollectorAnimState,"ps":1},{"n":"actionOnComplete","dv":null,"o":true,"pt":Function,"ps":2}],"sn":"PlayAnim","rt":$n[1].Void,"p":[$n[2].Vector3,CollectorAnimState,Function]},{"a":2,"n":"PlayBoxReveal","t":8,"sn":"PlayBoxReveal","rt":$n[1].Void},{"at":[new UnityEngine.ContextMenu.ctor("Play Jump")],"a":2,"n":"PlayJump","t":8,"sn":"PlayJump","rt":$n[1].Void},{"at":[new UnityEngine.ContextMenu.ctor("Play Shoot Animation")],"a":2,"n":"PlayShootAnimation","t":8,"sn":"PlayShootAnimation","rt":$n[1].Void},{"at":[new UnityEngine.ContextMenu.ctor("Play Squash")],"a":2,"n":"PlaySquash","t":8,"sn":"PlaySquash","rt":$n[1].Void},{"at":[new UnityEngine.ContextMenu.ctor("Play Stretch")],"a":2,"n":"PlayStretch","t":8,"sn":"PlayStretch","rt":$n[1].Void},{"a":1,"n":"PushForwardAnimation","t":8,"pi":[{"n":"newPos","pt":$n[2].Vector3,"ps":0},{"n":"actionOnComplete","dv":null,"o":true,"pt":Function,"ps":1}],"sn":"PushForwardAnimation","rt":$n[1].Void,"p":[$n[2].Vector3,Function]},{"a":1,"n":"PushForwardOnQueue","t":8,"pi":[{"n":"newPos","pt":$n[2].Vector3,"ps":0},{"n":"actionOnComplete","dv":null,"o":true,"pt":Function,"ps":1}],"sn":"PushForwardOnQueue","rt":$n[1].Void,"p":[$n[2].Vector3,Function]},{"a":1,"n":"RegisterEvents","t":8,"sn":"RegisterEvents","rt":$n[1].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[1].Void},{"at":[new UnityEngine.ContextMenu.ctor("Start Breathing")],"a":2,"n":"StartBreathing","t":8,"sn":"StartBreathing","rt":$n[1].Void},{"a":1,"n":"StartEarIdleAnimation","t":8,"sn":"StartEarIdleAnimation","rt":$n[0].IEnumerator},{"a":1,"n":"StopAnimation","t":8,"sn":"StopAnimation","rt":$n[1].Void},{"a":2,"n":"StopBreathing","t":8,"sn":"StopBreathing","rt":$n[1].Void},{"a":2,"n":"StopJump","t":8,"sn":"StopJump","rt":$n[1].Void},{"a":2,"n":"StopStretch","t":8,"sn":"StopStretch","rt":$n[1].Void},{"a":1,"n":"UnRegisterEvents","t":8,"sn":"UnRegisterEvents","rt":$n[1].Void},{"a":1,"n":"UnlockLockObjectAnimation","t":8,"pi":[{"n":"newPos","pt":$n[2].Vector3,"ps":0},{"n":"actionOnComplete","dv":null,"o":true,"pt":Function,"ps":1}],"sn":"UnlockLockObjectAnimation","rt":$n[1].Void,"p":[$n[2].Vector3,Function]},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[1].Void},{"a":2,"n":"BoxAnimator","t":4,"rt":$n[2].Animator,"sn":"BoxAnimator"},{"at":[new UnityEngine.HeaderAttribute("BOX ANIMATION")],"a":2,"n":"BoxJumpAnimation","t":4,"rt":$n[1].String,"sn":"BoxJumpAnimation"},{"a":2,"n":"BoxRandomRotate","t":4,"rt":EnableRandomRotate,"sn":"BoxRandomRotate"},{"a":2,"n":"BoxRevealAnimation","t":4,"rt":$n[1].String,"sn":"BoxRevealAnimation"},{"at":[new UnityEngine.HeaderAttribute("JUMPING")],"a":2,"n":"CollectorBody","t":4,"rt":$n[2].Transform,"sn":"CollectorBody"},{"at":[new UnityEngine.HeaderAttribute("CONTROLLER(s)")],"a":2,"n":"CollectorController","t":4,"rt":ColorPixelsCollectorObject,"sn":"CollectorController"},{"a":2,"n":"CollectorInfoController","t":4,"rt":CollectorController,"sn":"CollectorInfoController"},{"a":2,"n":"DefaultScale","t":4,"rt":$n[1].Single,"sn":"DefaultScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"EarIdleAnimation","t":4,"rt":$n[1].String,"sn":"EarIdleAnimation"},{"a":2,"n":"EarIdleRate","t":4,"rt":$n[2].Vector2,"sn":"EarIdleRate"},{"a":2,"n":"EffectOptions","t":4,"rt":InGameEffectOptions,"sn":"EffectOptions"},{"at":[new UnityEngine.HeaderAttribute("IDLE")],"a":2,"n":"IdleAnimations","t":4,"rt":$n[1].Array.type(System.String),"sn":"IdleAnimations"},{"at":[new UnityEngine.HeaderAttribute("RUNTIME DATA")],"a":2,"n":"JumpingToBelt","t":4,"rt":$n[1].Boolean,"sn":"JumpingToBelt","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"OnBeltScale","t":4,"rt":$n[1].Single,"sn":"OnBeltScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"OnDeadScale","t":4,"rt":$n[1].Single,"sn":"OnDeadScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"RabbitAnimator","t":4,"rt":$n[2].Animator,"sn":"RabbitAnimator"},{"at":[new UnityEngine.HeaderAttribute("BREATH")],"a":2,"n":"RabbitRoot","t":4,"rt":$n[2].Transform,"sn":"RabbitRoot"},{"a":2,"n":"RabbitTransform","t":4,"rt":$n[2].Transform,"sn":"RabbitTransform"},{"a":2,"n":"RareIdleAnimation","t":4,"rt":$n[1].String,"sn":"RareIdleAnimation"},{"at":[new UnityEngine.HeaderAttribute("SCALE")],"a":2,"n":"RootTransform","t":4,"rt":$n[2].Transform,"sn":"RootTransform"},{"at":[new UnityEngine.HeaderAttribute("SHOOT")],"a":2,"n":"ShootAnimation","t":4,"rt":$n[1].String,"sn":"ShootAnimation"},{"a":2,"n":"ShootRate","t":4,"rt":$n[1].Single,"sn":"ShootRate","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"breathAnimCoroutine","t":4,"rt":$n[2].Coroutine,"sn":"breathAnimCoroutine"},{"a":2,"n":"breathScaleX","t":4,"rt":$n[1].Single,"sn":"breathScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"breathScaleY","t":4,"rt":$n[1].Single,"sn":"breathScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"breathTween","t":4,"rt":$n[5].Sequence,"sn":"breathTween"},{"a":1,"n":"cachedJumpSeq","t":4,"rt":$n[5].Sequence,"sn":"cachedJumpSeq"},{"a":1,"n":"cachedSquashSeq","t":4,"rt":$n[5].Sequence,"sn":"cachedSquashSeq"},{"a":1,"n":"defaultCollectorScale","t":4,"rt":$n[2].Vector3,"sn":"defaultCollectorScale"},{"a":1,"n":"defaultPos","t":4,"rt":$n[2].Vector3,"sn":"defaultPos"},{"a":1,"n":"defaultRabbitRootScale","t":4,"rt":$n[2].Vector3,"sn":"defaultRabbitRootScale"},{"a":2,"n":"downEase","t":4,"rt":$n[5].Ease,"sn":"downEase","box":function ($v) { return Bridge.box($v, DG.Tweening.Ease, System.Enum.toStringFn(DG.Tweening.Ease));}},{"a":2,"n":"duration","t":4,"rt":$n[1].Single,"sn":"duration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"durationDown","t":4,"rt":$n[1].Single,"sn":"durationDown","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"durationRecover","t":4,"rt":$n[1].Single,"sn":"durationRecover","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"durationUp","t":4,"rt":$n[1].Single,"sn":"durationUp","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"earAnimCoroutine","t":4,"rt":$n[2].Coroutine,"sn":"earAnimCoroutine"},{"a":1,"n":"earIdleTimer","t":4,"rt":$n[1].Single,"sn":"earIdleTimer","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"jumpHeight","t":4,"rt":$n[1].Single,"sn":"jumpHeight","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"jumpScaleY","t":4,"rt":$n[1].Single,"sn":"jumpScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"recoverEase","t":4,"rt":$n[5].Ease,"sn":"recoverEase","box":function ($v) { return Bridge.box($v, DG.Tweening.Ease, System.Enum.toStringFn(DG.Tweening.Ease));}},{"a":1,"n":"shootTimer","t":4,"rt":$n[1].Single,"sn":"shootTimer","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"squashScaleX","t":4,"rt":$n[1].Single,"sn":"squashScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"squashScaleX2","t":4,"rt":$n[1].Single,"sn":"squashScaleX2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"squashScaleY","t":4,"rt":$n[1].Single,"sn":"squashScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("SQUASH")],"a":2,"n":"squashScaleY2","t":4,"rt":$n[1].Single,"sn":"squashScaleY2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"stretchDuration","t":4,"rt":$n[1].Single,"sn":"stretchDuration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("STRETCH ON CLICK")],"a":2,"n":"stretchScaleY","t":4,"rt":$n[1].Single,"sn":"stretchScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"stretchTween","t":4,"rt":$n[5].Sequence,"sn":"stretchTween"},{"a":1,"n":"tweenMoveToQueuePosition","t":4,"rt":$n[5].Sequence,"sn":"tweenMoveToQueuePosition"},{"a":1,"n":"tweenPushForward","t":4,"rt":$n[5].Tween,"sn":"tweenPushForward"},{"a":1,"n":"tweenPushForwardOnQueue","t":4,"rt":$n[5].Tween,"sn":"tweenPushForwardOnQueue"},{"a":2,"n":"upEase","t":4,"rt":$n[5].Ease,"sn":"upEase","box":function ($v) { return Bridge.box($v, DG.Tweening.Ease, System.Enum.toStringFn(DG.Tweening.Ease));}}]}; }, $n);
    /*CollectorAnimation end.*/

    /*CollectorAnimState start.*/
    $m("CollectorAnimState", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"CompleteColorPixels","is":true,"t":4,"rt":CollectorAnimState,"sn":"CompleteColorPixels","box":function ($v) { return Bridge.box($v, CollectorAnimState, System.Enum.toStringFn(CollectorAnimState));}},{"a":2,"n":"Idle","is":true,"t":4,"rt":CollectorAnimState,"sn":"Idle","box":function ($v) { return Bridge.box($v, CollectorAnimState, System.Enum.toStringFn(CollectorAnimState));}},{"a":2,"n":"MoveToConveyorBelt","is":true,"t":4,"rt":CollectorAnimState,"sn":"MoveToConveyorBelt","box":function ($v) { return Bridge.box($v, CollectorAnimState, System.Enum.toStringFn(CollectorAnimState));}},{"a":2,"n":"MoveToDeadPosition","is":true,"t":4,"rt":CollectorAnimState,"sn":"MoveToDeadPosition","box":function ($v) { return Bridge.box($v, CollectorAnimState, System.Enum.toStringFn(CollectorAnimState));}},{"a":2,"n":"MoveToQueue","is":true,"t":4,"rt":CollectorAnimState,"sn":"MoveToQueue","box":function ($v) { return Bridge.box($v, CollectorAnimState, System.Enum.toStringFn(CollectorAnimState));}},{"a":2,"n":"MoveToQueueRotateBack","is":true,"t":4,"rt":CollectorAnimState,"sn":"MoveToQueueRotateBack","box":function ($v) { return Bridge.box($v, CollectorAnimState, System.Enum.toStringFn(CollectorAnimState));}},{"a":2,"n":"PushForward","is":true,"t":4,"rt":CollectorAnimState,"sn":"PushForward","box":function ($v) { return Bridge.box($v, CollectorAnimState, System.Enum.toStringFn(CollectorAnimState));}},{"a":2,"n":"PushForwardOnConveyorBelt","is":true,"t":4,"rt":CollectorAnimState,"sn":"PushForwardOnConveyorBelt","box":function ($v) { return Bridge.box($v, CollectorAnimState, System.Enum.toStringFn(CollectorAnimState));}},{"a":2,"n":"UnlockLockObject","is":true,"t":4,"rt":CollectorAnimState,"sn":"UnlockLockObject","box":function ($v) { return Bridge.box($v, CollectorAnimState, System.Enum.toStringFn(CollectorAnimState));}}]}; }, $n);
    /*CollectorAnimState end.*/

    /*CollectorController start.*/
    $m("CollectorController", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[1].Void},{"a":2,"n":"CanMove","t":8,"sn":"CanMove","rt":$n[1].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"DeUpdateText","t":8,"sn":"DeUpdateText","rt":$n[1].Void},{"a":2,"n":"GetCurrentTF","t":8,"sn":"GetCurrentTF","rt":$n[1].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GetPositionByTF","t":8,"pi":[{"n":"tf","pt":$n[1].Single,"ps":0}],"sn":"GetPositionByTF","rt":$n[2].Vector3,"p":[$n[1].Single]},{"a":2,"n":"GetStartPosition","t":8,"sn":"GetStartPosition","rt":$n[2].Vector3},{"a":2,"n":"HandleCompleteColorPixels","t":8,"sn":"HandleCompleteColorPixels","rt":$n[1].Void},{"a":1,"n":"HandleCompleteColorPixelsDirect","t":8,"sn":"HandleCompleteColorPixelsDirect","rt":$n[1].Void},{"a":2,"n":"MoveToPos","t":8,"pi":[{"n":"newPos","pt":$n[2].Vector3,"ps":0},{"n":"animState","pt":CollectorAnimState,"ps":1},{"n":"actionOnComplete","dv":null,"o":true,"pt":Function,"ps":2}],"sn":"MoveToPos","rt":$n[1].Void,"p":[$n[2].Vector3,CollectorAnimState,Function]},{"a":2,"n":"OnAbsoluteWin","t":8,"sn":"OnAbsoluteWin","rt":$n[1].Void},{"a":2,"n":"OnCollectorMoveFinished","t":8,"sn":"OnCollectorMoveFinished","rt":$n[1].Void},{"a":2,"n":"OnCompletePixel","t":8,"sn":"OnCompletePixel","rt":$n[1].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[1].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[1].Void},{"a":2,"n":"PauseMovement","t":8,"sn":"PauseMovement","rt":$n[1].Void},{"a":2,"n":"ResumeMovement","t":8,"sn":"ResumeMovement","rt":$n[1].Void},{"a":2,"n":"SetFadeBulletText","t":8,"pi":[{"n":"isFaded","pt":$n[1].Boolean,"ps":0}],"sn":"SetFadeBulletText","rt":$n[1].Void,"p":[$n[1].Boolean]},{"a":2,"n":"StartMovement","t":8,"pi":[{"n":"targetTF","pt":$n[1].Single,"ps":0}],"sn":"StartMovement","rt":$n[1].Void,"p":[$n[1].Single]},{"a":2,"n":"StopMovementAtCurrentPosition","t":8,"sn":"StopMovementAtCurrentPosition","rt":$n[0].IEnumerator},{"a":2,"n":"UnlockCollector","t":8,"sn":"UnlockCollector","rt":$n[1].Void},{"a":2,"n":"UpdateVisiblityBasedOnRow","t":8,"sn":"UpdateVisiblityBasedOnRow","rt":$n[1].Void},{"a":2,"n":"ColorCollector","t":4,"rt":ColorPixelsCollectorObject,"sn":"ColorCollector"},{"a":2,"n":"ColumnIndex","t":4,"rt":$n[1].Int32,"sn":"ColumnIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"IndexInColumn","t":4,"rt":$n[1].Int32,"sn":"IndexInColumn","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"IsCompleteColor","t":4,"rt":$n[1].Boolean,"sn":"IsCompleteColor","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsLockObject","t":4,"rt":$n[1].Boolean,"sn":"IsLockObject","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"LockController","t":4,"rt":LockObject,"sn":"LockController"},{"a":2,"n":"SlotOnQueue","t":4,"rt":$n[1].Int32,"sn":"SlotOnQueue","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"State","t":4,"rt":CollectorState,"sn":"State","box":function ($v) { return Bridge.box($v, CollectorState, System.Enum.toStringFn(CollectorState));}},{"a":1,"n":"Vector3Forward","is":true,"t":4,"rt":$n[2].Vector3,"sn":"Vector3Forward","ro":true},{"a":1,"n":"Vector3One","is":true,"t":4,"rt":$n[2].Vector3,"sn":"Vector3One","ro":true},{"a":1,"n":"Vector3Right","is":true,"t":4,"rt":$n[2].Vector3,"sn":"Vector3Right","ro":true},{"a":1,"n":"Vector3Up","is":true,"t":4,"rt":$n[2].Vector3,"sn":"Vector3Up","ro":true},{"a":1,"n":"Vector3Zero","is":true,"t":4,"rt":$n[2].Vector3,"sn":"Vector3Zero","ro":true},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"anim","t":4,"rt":CollectorAnimation,"sn":"anim"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"bulletDisplayHandler","t":4,"rt":BulletDisplayHandler,"sn":"bulletDisplayHandler"},{"a":2,"n":"collectorConnect","t":4,"rt":$n[6].List$1(CollectorController),"sn":"collectorConnect"},{"a":1,"n":"hasCompleted","t":4,"rt":$n[1].Boolean,"sn":"hasCompleted","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"movementHandle","t":4,"rt":CachedTransformPathMover,"sn":"movementHandle"},{"a":1,"n":"waitForEndOfFrame","t":4,"rt":$n[2].WaitForEndOfFrame,"sn":"waitForEndOfFrame"}]}; }, $n);
    /*CollectorController end.*/

    /*CollectorState start.*/
    $m("CollectorState", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Completed","is":true,"t":4,"rt":CollectorState,"sn":"Completed","box":function ($v) { return Bridge.box($v, CollectorState, System.Enum.toStringFn(CollectorState));}},{"a":2,"n":"InColumn","is":true,"t":4,"rt":CollectorState,"sn":"InColumn","box":function ($v) { return Bridge.box($v, CollectorState, System.Enum.toStringFn(CollectorState));}},{"a":2,"n":"InDeadQueue","is":true,"t":4,"rt":CollectorState,"sn":"InDeadQueue","box":function ($v) { return Bridge.box($v, CollectorState, System.Enum.toStringFn(CollectorState));}},{"a":2,"n":"InQueue","is":true,"t":4,"rt":CollectorState,"sn":"InQueue","box":function ($v) { return Bridge.box($v, CollectorState, System.Enum.toStringFn(CollectorState));}},{"a":2,"n":"Moving","is":true,"t":4,"rt":CollectorState,"sn":"Moving","box":function ($v) { return Bridge.box($v, CollectorState, System.Enum.toStringFn(CollectorState));}}]}; }, $n);
    /*CollectorState end.*/

    /*CollectorMachanicObjectBase start.*/
    $m("CollectorMachanicObjectBase", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ID","t":4,"rt":$n[1].Int32,"sn":"ID","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*CollectorMachanicObjectBase end.*/

    /*CollectorProjectilePool start.*/
    $m("CollectorProjectilePool", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[1].Void},{"a":1,"n":"CreateProjectile","t":8,"pi":[{"n":"super","pt":$n[1].Boolean,"ps":0},{"n":"active","dv":false,"o":true,"pt":$n[1].Boolean,"ps":1}],"sn":"CreateProjectile","rt":CollectorProjectileController,"p":[$n[1].Boolean,$n[1].Boolean]},{"a":2,"n":"GetProjectile","t":8,"pi":[{"n":"super","pt":$n[1].Boolean,"ps":0}],"sn":"GetProjectile","rt":CollectorProjectileController,"p":[$n[1].Boolean]},{"a":1,"n":"InitializePool","t":8,"sn":"InitializePool","rt":$n[1].Void},{"a":2,"n":"ReturnToPool","t":8,"pi":[{"n":"proj","pt":CollectorProjectileController,"ps":0},{"n":"super","pt":$n[1].Boolean,"ps":1}],"sn":"ReturnToPool","rt":$n[1].Void,"p":[CollectorProjectileController,$n[1].Boolean]},{"a":2,"n":"Instance","is":true,"t":16,"rt":CollectorProjectilePool,"g":{"a":2,"n":"get_Instance","t":8,"rt":CollectorProjectilePool,"fg":"Instance","is":true},"s":{"a":1,"n":"set_Instance","t":8,"p":[CollectorProjectilePool],"rt":$n[1].Void,"fs":"Instance","is":true},"fn":"Instance"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"initialCount","t":4,"rt":$n[1].Int32,"sn":"initialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"normalBulletPool","t":4,"rt":$n[6].Queue$1(CollectorProjectileController),"sn":"normalBulletPool","ro":true},{"at":[new UnityEngine.HeaderAttribute("Pool Setup"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"normalProjectilePrefab","t":4,"rt":CollectorProjectileController,"sn":"normalProjectilePrefab"},{"a":1,"n":"superBulletPool","t":4,"rt":$n[6].Queue$1(CollectorProjectileController),"sn":"superBulletPool","ro":true},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"superProjectilePrefab","t":4,"rt":CollectorProjectileController,"sn":"superProjectilePrefab"},{"a":1,"backing":true,"n":"<Instance>k__BackingField","is":true,"t":4,"rt":CollectorProjectilePool,"sn":"Instance"}]}; }, $n);
    /*CollectorProjectilePool end.*/

    /*CollectorVisualHandler start.*/
    $m("CollectorVisualHandler", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[1].Void},{"a":1,"n":"DelayReveal","t":8,"pi":[{"n":"delay","pt":$n[1].Single,"ps":0}],"sn":"DelayReveal","rt":$n[0].IEnumerator,"p":[$n[1].Single]},{"a":2,"n":"HideRope","t":8,"sn":"HideRope","rt":$n[1].Void},{"a":1,"n":"OnACollectorRevealed","t":8,"pi":[{"n":"_collector","pt":ColorPixelsCollectorObject,"ps":0}],"sn":"OnACollectorRevealed","rt":$n[1].Void,"p":[ColorPixelsCollectorObject]},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[1].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[1].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[1].Void},{"a":2,"n":"PlayMuzzleEffect","t":8,"sn":"PlayMuzzleEffect","rt":$n[1].Void},{"a":2,"n":"RefreshColor","t":8,"sn":"RefreshColor","rt":$n[1].Void},{"a":1,"n":"RegisterEvents","t":8,"sn":"RegisterEvents","rt":$n[1].Void},{"a":2,"n":"SetBulletText","t":8,"pi":[{"n":"bullet","pt":$n[1].Int32,"ps":0}],"sn":"SetBulletText","rt":$n[1].Void,"p":[$n[1].Int32]},{"a":2,"n":"SetColor","t":8,"pi":[{"n":"colorCode","pt":$n[1].String,"ps":0}],"sn":"SetColor","rt":$n[1].Void,"p":[$n[1].String]},{"a":1,"n":"SetFloat","t":8,"pi":[{"n":"prop","pt":$n[1].String,"ps":0},{"n":"value","pt":$n[1].Single,"ps":1}],"sn":"SetFloat","rt":$n[1].Void,"p":[$n[1].String,$n[1].Single]},{"a":2,"n":"SetHiddenState","t":8,"pi":[{"n":"_hidden","pt":$n[1].Boolean,"ps":0},{"n":"instantly","dv":true,"o":true,"pt":$n[1].Boolean,"ps":1}],"sn":"SetHiddenState","rt":$n[1].Void,"p":[$n[1].Boolean,$n[1].Boolean]},{"a":2,"n":"SetLockedIcon","t":8,"pi":[{"n":"locked","pt":$n[1].Boolean,"ps":0}],"sn":"SetLockedIcon","rt":$n[1].Void,"p":[$n[1].Boolean]},{"a":2,"n":"SetMaterial","t":8,"pi":[{"n":"colorCode","pt":$n[1].String,"ps":0},{"n":"mat","pt":$n[2].Material,"ps":1}],"sn":"SetMaterial","rt":$n[1].Void,"p":[$n[1].String,$n[2].Material]},{"a":1,"n":"SetMeshColor","t":8,"pi":[{"n":"_color","pt":$n[2].Color,"ps":0}],"sn":"SetMeshColor","rt":$n[1].Void,"p":[$n[2].Color]},{"a":1,"n":"SetMeshMaterial","t":8,"pi":[{"n":"mat","pt":$n[2].Material,"ps":0}],"sn":"SetMeshMaterial","rt":$n[1].Void,"p":[$n[2].Material]},{"a":2,"n":"SetMuzzleColor","t":8,"sn":"SetMuzzleColor","rt":$n[1].Void},{"a":2,"n":"SetRopeColor","t":8,"pi":[{"n":"_firstColor","pt":$n[2].Color,"ps":0},{"n":"_secondColor","pt":$n[2].Color,"ps":1}],"sn":"SetRopeColor","rt":$n[1].Void,"p":[$n[2].Color,$n[2].Color]},{"a":2,"n":"SetVisisble","t":8,"pi":[{"n":"visible","pt":$n[1].Boolean,"ps":0}],"sn":"SetVisisble","rt":$n[1].Void,"p":[$n[1].Boolean]},{"a":2,"n":"SetupRope","t":8,"pi":[{"n":"active","pt":$n[1].Boolean,"ps":0},{"n":"target","pt":CollectorVisualHandler,"ps":1}],"sn":"SetupRope","rt":$n[1].Void,"p":[$n[1].Boolean,CollectorVisualHandler]},{"a":2,"n":"StartHighlight","t":8,"pi":[{"n":"min","dv":0.0,"o":true,"pt":$n[1].Single,"ps":0},{"n":"max","dv":1.5,"o":true,"pt":$n[1].Single,"ps":1},{"n":"duration","dv":0.5,"o":true,"pt":$n[1].Single,"ps":2}],"sn":"StartHighlight","rt":$n[1].Void,"p":[$n[1].Single,$n[1].Single,$n[1].Single]},{"a":2,"n":"StartRimBlink","t":8,"pi":[{"n":"min","dv":0.0,"o":true,"pt":$n[1].Single,"ps":0},{"n":"max","dv":1.5,"o":true,"pt":$n[1].Single,"ps":1},{"n":"duration","dv":0.5,"o":true,"pt":$n[1].Single,"ps":2}],"sn":"StartRimBlink","rt":$n[1].Void,"p":[$n[1].Single,$n[1].Single,$n[1].Single]},{"a":2,"n":"StartTrailHighSpeed","t":8,"sn":"StartTrailHighSpeed","rt":$n[1].Void},{"a":2,"n":"StopHighlight","t":8,"sn":"StopHighlight","rt":$n[1].Void},{"a":2,"n":"StopTrailHighSpeed","t":8,"sn":"StopTrailHighSpeed","rt":$n[1].Void},{"a":1,"n":"UnRegisterEvents","t":8,"sn":"UnRegisterEvents","rt":$n[1].Void},{"a":2,"n":"UpdateRopeColor","t":8,"sn":"UpdateRopeColor","rt":$n[1].Void},{"a":2,"n":"Animator","t":4,"rt":CollectorAnimation,"sn":"Animator"},{"at":[new UnityEngine.HeaderAttribute("VFX")],"a":2,"n":"BulletSpawner","t":4,"rt":$n[2].Transform,"sn":"BulletSpawner"},{"at":[new UnityEngine.HeaderAttribute("Object: BULLET")],"a":2,"n":"BulletsText","t":4,"rt":$n[4].TMP_Text,"sn":"BulletsText"},{"at":[new UnityEngine.HeaderAttribute("Object: HIDDEN")],"a":2,"n":"CattonBox","t":4,"rt":$n[2].GameObject,"sn":"CattonBox"},{"a":2,"n":"CollectorHandle","t":4,"rt":ColorPixelsCollectorObject,"sn":"CollectorHandle"},{"a":2,"n":"CollectorMuzzleVFX","t":4,"rt":$n[2].ParticleSystem,"sn":"CollectorMuzzleVFX"},{"at":[new UnityEngine.HeaderAttribute("Real time data")],"a":2,"n":"CurrentColor","t":4,"rt":$n[2].Color,"sn":"CurrentColor"},{"a":2,"n":"GunnerRenderers","t":4,"rt":$n[6].List$1(UnityEngine.Renderer),"sn":"GunnerRenderers"},{"a":2,"n":"HiddenOutlineColor","t":4,"rt":$n[2].Color,"sn":"HiddenOutlineColor"},{"a":2,"n":"HiddenRopeColor","t":4,"rt":$n[2].Color,"sn":"HiddenRopeColor"},{"a":2,"n":"HighSpeedTrail","t":4,"rt":$n[2].ParticleSystem,"sn":"HighSpeedTrail"},{"at":[new UnityEngine.HeaderAttribute("Object: LOCK")],"a":2,"n":"LockSpriteRenderer","t":4,"rt":$n[2].SpriteRenderer,"sn":"LockSpriteRenderer"},{"a":2,"n":"OriginalMat","t":4,"rt":$n[2].Material,"sn":"OriginalMat"},{"a":2,"n":"QuestionMarkSpriteRenderer","t":4,"rt":$n[2].SpriteRenderer,"sn":"QuestionMarkSpriteRenderer"},{"a":2,"n":"ReavealVFX","t":4,"rt":$n[2].ParticleSystem,"sn":"ReavealVFX"},{"a":2,"n":"TankRope","t":4,"rt":$n[7].Rope,"sn":"TankRope"},{"a":2,"n":"TankRopeMesh","t":4,"rt":$n[7].RopeMesh,"sn":"TankRopeMesh"},{"at":[new UnityEngine.HeaderAttribute("Object: ROPE")],"a":2,"n":"TankRopeObj","t":4,"rt":$n[2].GameObject,"sn":"TankRopeObj"},{"a":1,"n":"block","t":4,"rt":$n[2].MaterialPropertyBlock,"sn":"block"},{"a":1,"n":"colorCache","t":4,"rt":$n[6].Dictionary$2(System.String,UnityEngine.Color),"sn":"colorCache"},{"a":2,"n":"colorPalette","t":4,"rt":ColorPalleteData,"sn":"colorPalette"},{"a":1,"n":"connectedTarget","t":4,"rt":CollectorVisualHandler,"sn":"connectedTarget"},{"a":1,"n":"hidden","t":4,"rt":$n[1].Boolean,"sn":"hidden","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"rimTween","t":4,"rt":$n[5].Tween,"sn":"rimTween"}]}; }, $n);
    /*CollectorVisualHandler end.*/

    /*ColorPixelsCollectorObject start.*/
    $m("ColorPixelsCollectorObject", function () { return {"nested":[ColorPixelsCollectorObject.State],"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ApplyHiddenState","t":8,"sn":"ApplyHiddenState","rt":$n[1].Void},{"a":2,"n":"ApplyLockedState","t":8,"sn":"ApplyLockedState","rt":$n[1].Void},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[1].Void},{"a":1,"n":"CheckAndDestroyNearbyPixels","t":8,"sn":"CheckAndDestroyNearbyPixels","rt":$n[1].Void},{"a":1,"n":"CheckForObstaclesInColumn","t":8,"pi":[{"n":"targetPixel","pt":PaintingPixel,"ps":0}],"sn":"CheckForObstaclesInColumn","rt":$n[1].Boolean,"p":[PaintingPixel],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"CheckForObstaclesInRow","t":8,"pi":[{"n":"targetPixel","pt":PaintingPixel,"ps":0}],"sn":"CheckForObstaclesInRow","rt":$n[1].Boolean,"p":[PaintingPixel],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"CheckMovementDirectionChange","t":8,"sn":"CheckMovementDirectionChange","rt":$n[1].Void},{"a":2,"n":"CheckTargetOnAbsoluteWin","t":8,"sn":"CheckTargetOnAbsoluteWin","rt":$n[1].Void},{"a":1,"n":"DetermineMovementDirection","t":8,"pi":[{"n":"tangent","pt":$n[2].Vector3,"ps":0}],"sn":"DetermineMovementDirection","rt":MovementDirection,"p":[$n[2].Vector3],"box":function ($v) { return Bridge.box($v, MovementDirection, System.Enum.toStringFn(MovementDirection));}},{"a":1,"n":"InitializeCollector","t":8,"sn":"InitializeCollector","rt":$n[1].Void},{"a":1,"n":"IsHorizontalDirection","t":8,"pi":[{"n":"direction","pt":MovementDirection,"ps":0}],"sn":"IsHorizontalDirection","rt":$n[1].Boolean,"p":[MovementDirection],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"IsVerticalDirection","t":8,"pi":[{"n":"direction","pt":MovementDirection,"ps":0}],"sn":"IsVerticalDirection","rt":$n[1].Boolean,"p":[MovementDirection],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"OnAbsoluteWin","t":8,"pi":[{"n":"isMoving","pt":$n[1].Boolean,"ps":0}],"sn":"OnAbsoluteWin","rt":$n[1].Void,"p":[$n[1].Boolean]},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[1].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[1].Void},{"a":1,"n":"OnGridPaintingObjectInitialized","t":8,"pi":[{"n":"_gridObject","pt":PaintingGridObject,"ps":0}],"sn":"OnGridPaintingObjectInitialized","rt":$n[1].Void,"p":[PaintingGridObject]},{"a":1,"n":"OnGridPixelsChanged","t":8,"pi":[{"n":"changedGrid","pt":PaintingGridObject,"ps":0}],"sn":"OnGridPixelsChanged","rt":$n[1].Void,"p":[PaintingGridObject]},{"a":1,"n":"OnRunOutOfBulletDestroyed","t":8,"sn":"OnRunOutOfBulletDestroyed","rt":$n[1].Void},{"a":2,"n":"OnStartMove","t":8,"sn":"OnStartMove","rt":$n[1].Void},{"a":1,"n":"RegisterEvents","t":8,"sn":"RegisterEvents","rt":$n[1].Void},{"a":2,"n":"Reveal","t":8,"sn":"Reveal","rt":$n[1].Void},{"a":1,"n":"RotateMesh","t":8,"sn":"RotateMesh","rt":$n[1].Void},{"a":2,"n":"SelfDestroy","t":8,"sn":"SelfDestroy","rt":$n[1].Void},{"a":2,"n":"SetActiveCollector","t":8,"pi":[{"n":"active","pt":$n[1].Boolean,"ps":0}],"sn":"SetActiveCollector","rt":$n[1].Void,"p":[$n[1].Boolean]},{"a":2,"n":"SetBullet","t":8,"pi":[{"n":"bulletCount","pt":$n[1].Int32,"ps":0}],"sn":"SetBullet","rt":$n[1].Void,"p":[$n[1].Int32]},{"a":2,"n":"SetCollectorActive","t":8,"pi":[{"n":"active","pt":$n[1].Boolean,"ps":0}],"sn":"SetCollectorActive","rt":$n[1].Void,"p":[$n[1].Boolean]},{"a":2,"n":"SetStatusAttributes","t":8,"sn":"SetStatusAttributes","rt":$n[1].Void},{"a":1,"n":"ShootPixel","t":8,"pi":[{"n":"pixel","pt":PaintingPixel,"ps":0}],"sn":"ShootPixel","rt":$n[1].Void,"p":[PaintingPixel]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[1].Void},{"a":2,"n":"Unlock","t":8,"sn":"Unlock","rt":$n[1].Void},{"a":1,"n":"UnregisterEvents","t":8,"sn":"UnregisterEvents","rt":$n[1].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[1].Void},{"a":2,"n":"UpdatePossibleTargets","t":8,"sn":"UpdatePossibleTargets","rt":$n[1].Void},{"a":2,"n":"Available","t":16,"rt":$n[1].Boolean,"g":{"a":2,"n":"get_Available","t":8,"rt":$n[1].Boolean,"fg":"Available","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"Available"},{"at":[new UnityEngine.HeaderAttribute("ABSOLUTE WIN")],"a":2,"n":"AbsoluteCheckRate","t":4,"rt":$n[1].Int32,"sn":"AbsoluteCheckRate","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"AbsoluteWinSpeed","t":4,"rt":$n[1].Single,"sn":"AbsoluteWinSpeed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("Shooting Mechanics"),new UnityEngine.TooltipAttribute("Max number of bullets")],"a":2,"n":"BulletCapacity","t":4,"rt":$n[1].Int32,"sn":"BulletCapacity","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.TooltipAttribute("Bullets left")],"a":2,"n":"BulletLeft","t":4,"rt":$n[1].Int32,"sn":"BulletLeft","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.HeaderAttribute("OPTIMIZATION"),new UnityEngine.TooltipAttribute("Number of frames to skip between checks")],"a":2,"n":"CheckIntervalFrames","t":4,"rt":$n[1].Int32,"sn":"CheckIntervalFrames","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"CollectorAnimator","t":4,"rt":CollectorAnimation,"sn":"CollectorAnimator"},{"at":[new UnityEngine.HeaderAttribute("Color Matching"),new UnityEngine.TooltipAttribute("Pixel's color code that this object can shoot. Color of this object based on pixel's color")],"a":2,"n":"CollectorColor","t":4,"rt":$n[1].String,"sn":"CollectorColor"},{"a":2,"n":"ConnectedCollectorsIDs","t":4,"rt":$n[6].List$1(System.Int32),"sn":"ConnectedCollectorsIDs"},{"a":2,"n":"CurrentColor","t":4,"rt":$n[2].Color,"sn":"CurrentColor"},{"at":[new UnityEngine.HeaderAttribute("Target Grid"),new UnityEngine.TooltipAttribute("Current target grid object")],"a":2,"n":"CurrentGrid","t":4,"rt":PaintingGridObject,"sn":"CurrentGrid"},{"a":2,"n":"CurrentState","t":4,"rt":ColorPixelsCollectorObject.State,"sn":"CurrentState","box":function ($v) { return Bridge.box($v, ColorPixelsCollectorObject.State, System.Enum.toStringFn(ColorPixelsCollectorObject.State));}},{"a":2,"n":"CurrentTargetPosition","t":4,"rt":$n[2].Vector3,"sn":"CurrentTargetPosition"},{"at":[new UnityEngine.HeaderAttribute("Detection Settings"),new UnityEngine.TooltipAttribute("Distance threshold to detect and shoot nearby pixels")],"a":2,"n":"DetectionRadius","t":4,"rt":$n[1].Single,"sn":"DetectionRadius","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("Runtime Data")],"a":2,"n":"IsCollectorActive","t":4,"rt":$n[1].Boolean,"sn":"IsCollectorActive","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsHidden","t":4,"rt":$n[1].Boolean,"sn":"IsHidden","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsHided","t":4,"rt":$n[1].Boolean,"sn":"IsHided","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("CONFIG ATTRIBUTES")],"a":2,"n":"IsLocked","t":4,"rt":$n[1].Boolean,"sn":"IsLocked","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Minimum distance moved before checking again")],"a":2,"n":"MinMoveDistance","t":4,"rt":$n[1].Single,"sn":"MinMoveDistance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("Movement"),new UnityEngine.TooltipAttribute("Movement handler script for spline movement")],"a":2,"n":"MovementHandle","t":4,"rt":CachedTransformPathMover,"sn":"MovementHandle"},{"a":2,"n":"NormalSpeed","t":4,"rt":$n[1].Single,"sn":"NormalSpeed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"OnCompleteAllColorPixels","t":4,"rt":Function,"sn":"OnCompleteAllColorPixels"},{"a":2,"n":"RabbitRootTransform","t":4,"rt":$n[2].Transform,"sn":"RabbitRootTransform"},{"a":2,"n":"RabbitRotateTransform","t":4,"rt":$n[2].Transform,"sn":"RabbitRotateTransform"},{"a":2,"n":"VisualHandler","t":4,"rt":CollectorVisualHandler,"sn":"VisualHandler"},{"a":1,"n":"_frameCounter","t":4,"rt":$n[1].Int32,"sn":"_frameCounter","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"_lastCheckPosition","t":4,"rt":$n[2].Vector3,"sn":"_lastCheckPosition"},{"a":1,"n":"_minMoveDistanceSqr","t":4,"rt":$n[1].Single,"sn":"_minMoveDistanceSqr","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"bulletDisplayHandler","t":4,"rt":BulletDisplayHandler,"sn":"bulletDisplayHandler"},{"a":1,"n":"cachedRotation","t":4,"rt":$n[2].Vector3,"sn":"cachedRotation"},{"a":1,"n":"cachedTargets","t":4,"rt":System.Array.type(PaintingPixel),"sn":"cachedTargets"},{"a":1,"n":"currentFrameCount","t":4,"rt":$n[1].Int32,"sn":"currentFrameCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"currentMovementDirection","t":4,"rt":MovementDirection,"sn":"currentMovementDirection","box":function ($v) { return Bridge.box($v, MovementDirection, System.Enum.toStringFn(MovementDirection));}},{"a":1,"n":"dead","t":4,"rt":$n[1].Boolean,"sn":"dead","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"hasRotated","t":4,"rt":$n[1].Boolean,"sn":"hasRotated","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"maxTargetCapacity","t":4,"rt":$n[1].Int32,"sn":"maxTargetCapacity","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"possibleTargets","t":4,"rt":System.Array.type(PaintingPixel),"sn":"possibleTargets"},{"a":1,"n":"possibleTargetsCount","t":4,"rt":$n[1].Int32,"sn":"possibleTargetsCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"previousMovementDirection","t":4,"rt":$n[2].Vector3,"sn":"previousMovementDirection"},{"a":1,"n":"processedHorizontalPositions","t":4,"rt":$n[6].HashSet$1(System.Int32),"sn":"processedHorizontalPositions"},{"a":1,"n":"processedVerticalPositions","t":4,"rt":$n[6].HashSet$1(System.Int32),"sn":"processedVerticalPositions"},{"a":1,"n":"tempOutlinePixelsList","t":4,"rt":$n[6].List$1(PaintingPixel),"sn":"tempOutlinePixelsList"}]}; }, $n);
    /*ColorPixelsCollectorObject end.*/

    /*ColorPixelsCollectorObject+State start.*/
    $m("ColorPixelsCollectorObject.State", function () { return {"td":ColorPixelsCollectorObject,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AbsoluteWin","is":true,"t":4,"rt":ColorPixelsCollectorObject.State,"sn":"AbsoluteWin","box":function ($v) { return Bridge.box($v, ColorPixelsCollectorObject.State, System.Enum.toStringFn(ColorPixelsCollectorObject.State));}},{"a":2,"n":"Normal","is":true,"t":4,"rt":ColorPixelsCollectorObject.State,"sn":"Normal","box":function ($v) { return Bridge.box($v, ColorPixelsCollectorObject.State, System.Enum.toStringFn(ColorPixelsCollectorObject.State));}}]}; }, $n);
    /*ColorPixelsCollectorObject+State end.*/

    /*MovementDirection start.*/
    $m("MovementDirection", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"HorizontalLeftToRight","is":true,"t":4,"rt":MovementDirection,"sn":"HorizontalLeftToRight","box":function ($v) { return Bridge.box($v, MovementDirection, System.Enum.toStringFn(MovementDirection));}},{"a":2,"n":"HorizontalRightToLeft","is":true,"t":4,"rt":MovementDirection,"sn":"HorizontalRightToLeft","box":function ($v) { return Bridge.box($v, MovementDirection, System.Enum.toStringFn(MovementDirection));}},{"a":2,"n":"Unknown","is":true,"t":4,"rt":MovementDirection,"sn":"Unknown","box":function ($v) { return Bridge.box($v, MovementDirection, System.Enum.toStringFn(MovementDirection));}},{"a":2,"n":"VerticalBottomToTop","is":true,"t":4,"rt":MovementDirection,"sn":"VerticalBottomToTop","box":function ($v) { return Bridge.box($v, MovementDirection, System.Enum.toStringFn(MovementDirection));}},{"a":2,"n":"VerticalTopToBottom","is":true,"t":4,"rt":MovementDirection,"sn":"VerticalTopToBottom","box":function ($v) { return Bridge.box($v, MovementDirection, System.Enum.toStringFn(MovementDirection));}}]}; }, $n);
    /*MovementDirection end.*/

    /*CullableObject start.*/
    $m("CullableObject", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"CheckVisibility","t":8,"sn":"CheckVisibility","rt":$n[1].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"ForceDisable","t":8,"sn":"ForceDisable","rt":$n[1].Void},{"a":2,"n":"ForceEnable","t":8,"sn":"ForceEnable","rt":$n[1].Void},{"a":2,"n":"IsVisible","t":8,"sn":"IsVisible","rt":$n[1].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"OnBecameInvisible","t":8,"sn":"OnBecameInvisible","rt":$n[1].Void},{"a":1,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[1].Void},{"a":1,"n":"OnDrawGizmosSelected","t":8,"sn":"OnDrawGizmosSelected","rt":$n[1].Void},{"a":2,"n":"SetMaxDistance","t":8,"pi":[{"n":"distance","pt":$n[1].Single,"ps":0}],"sn":"SetMaxDistance","rt":$n[1].Void,"p":[$n[1].Single]},{"a":1,"n":"SetRenderers","t":8,"pi":[{"n":"enable","pt":$n[1].Boolean,"ps":0}],"sn":"SetRenderers","rt":$n[1].Void,"p":[$n[1].Boolean]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[1].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[1].Void},{"a":1,"n":"cam","t":4,"rt":$n[2].Camera,"sn":"cam"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"checkInterval","t":4,"rt":$n[1].Single,"sn":"checkInterval","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"isVisible","t":4,"rt":$n[1].Boolean,"sn":"isVisible","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"maxDistance","t":4,"rt":$n[1].Single,"sn":"maxDistance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"originalStates","t":4,"rt":$n[1].Array.type(System.Boolean),"sn":"originalStates"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"showDebug","t":4,"rt":$n[1].Boolean,"sn":"showDebug","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("Settings"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"targetRenderers","t":4,"rt":System.Array.type(UnityEngine.Renderer),"sn":"targetRenderers"},{"a":1,"n":"timer","t":4,"rt":$n[1].Single,"sn":"timer","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*CullableObject end.*/

    /*LockObject start.*/
    $m("LockObject", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[1].Void},{"a":2,"n":"Unlock","t":8,"sn":"Unlock","rt":$n[1].Void},{"at":[new UnityEngine.ContextMenu.ctor("UnlockWithVisual")],"a":2,"n":"UnlockWithVisual","t":8,"sn":"UnlockWithVisual","rt":$n[1].Void},{"a":2,"n":"IsUnlocked","t":4,"rt":$n[1].Boolean,"sn":"IsUnlocked","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Row","t":4,"rt":$n[1].Int32,"sn":"Row","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"collectorController","t":4,"rt":CollectorController,"sn":"collectorController"}]}; }, $n);
    /*LockObject end.*/

    /*CollectorColumn start.*/
    $m("CollectorColumn", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"CollectorsInColumn","t":4,"rt":$n[6].List$1(CollectorMachanicObjectBase),"sn":"CollectorsInColumn"}]}; }, $n);
    /*CollectorColumn end.*/

    /*CollectorRearrangeIDs start.*/
    $m("CollectorRearrangeIDs", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"CurrentCollectorsConfigs","t":4,"rt":$n[6].List$1(LevelColorCollectorsConfig),"sn":"CurrentCollectorsConfigs"}]}; }, $n);
    /*CollectorRearrangeIDs end.*/

    /*KeyObjectSetup start.*/
    $m("KeyObjectSetup", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[KeyObjectSetup],"pi":[{"n":"_stock","pt":KeyObjectSetup,"ps":0}],"sn":"$ctor1"},{"a":2,"n":".ctor","t":1,"p":[$n[6].List$1(PaintingPixelConfig)],"pi":[{"n":"pixelCovered","pt":$n[6].List$1(PaintingPixelConfig),"ps":0}],"sn":"$ctor2"},{"a":2,"n":"ColorCode","t":4,"rt":$n[1].String,"sn":"ColorCode","ro":true},{"a":2,"n":"PixelCovered","t":4,"rt":$n[6].List$1(PaintingPixelConfig),"sn":"PixelCovered"}]}; }, $n);
    /*KeyObjectSetup end.*/

    /*LevelColorCollectorsConfig start.*/
    $m("LevelColorCollectorsConfig", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "LevelColorCollectorsConfig", menuName: "ColorPixelFlow/Level Color Collectors Config", order: 2
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ClearData","t":8,"sn":"ClearData","rt":$n[1].Void},{"a":2,"n":"EnsureBidirectionalConnections","t":8,"sn":"EnsureBidirectionalConnections","rt":$n[1].Void},{"a":2,"n":"GetAllCollectorConfigs","t":8,"sn":"GetAllCollectorConfigs","rt":$n[6].List$1(SingleColorCollectorConfig)},{"a":2,"n":"GetCollectorConfigByID","is":true,"t":8,"pi":[{"n":"_list","pt":$n[6].List$1(SingleColorCollectorConfig),"ps":0},{"n":"ID","pt":$n[1].Int32,"ps":1}],"sn":"GetCollectorConfigByID","rt":SingleColorCollectorConfig,"p":[$n[6].List$1(SingleColorCollectorConfig),$n[1].Int32]},{"a":2,"n":"NumberOfCollectors","t":8,"sn":"NumberOfCollectors","rt":$n[1].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"NumberOfColumns","t":8,"sn":"NumberOfColumns","rt":$n[1].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"NumberOfLocks","t":8,"sn":"NumberOfLocks","rt":$n[1].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ReArrangeID","t":8,"sn":"ReArrangeID","rt":$n[1].Void},{"a":2,"n":"RemoveCollector","t":8,"pi":[{"n":"id","pt":$n[1].Int32,"ps":0}],"sn":"RemoveCollector","rt":$n[1].Void,"p":[$n[1].Int32]},{"at":[new UnityEngine.HeaderAttribute("Collector Squad Configuration")],"a":2,"n":"CollectorColumns","t":4,"rt":$n[6].List$1(ColumnOfCollectorConfig),"sn":"CollectorColumns"}]}; }, $n);
    /*LevelColorCollectorsConfig end.*/

    /*ColumnOfCollectorConfig start.*/
    $m("ColumnOfCollectorConfig", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[ColumnOfCollectorConfig],"pi":[{"n":"_stock","pt":ColumnOfCollectorConfig,"ps":0}],"sn":"$ctor1"},{"a":2,"n":"Collectors","t":4,"rt":$n[6].List$1(SingleColorCollectorConfig),"sn":"Collectors"},{"a":2,"n":"Locks","t":4,"rt":$n[6].List$1(LockObjectConfig),"sn":"Locks"}]}; }, $n);
    /*ColumnOfCollectorConfig end.*/

    /*LevelColorCollectorsConfigBackUp start.*/
    $m("LevelColorCollectorsConfigBackUp", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"n":".ctor","t":1,"p":[LevelColorCollectorsConfig],"pi":[{"n":"_stock","pt":LevelColorCollectorsConfig,"ps":0}],"sn":"ctor"},{"a":2,"n":"CollectorColumns","t":4,"rt":$n[6].List$1(ColumnOfCollectorConfig),"sn":"CollectorColumns"},{"a":2,"n":"DateTime","t":4,"rt":$n[1].String,"sn":"DateTime"}]}; }, $n);
    /*LevelColorCollectorsConfigBackUp end.*/

    /*LevelConfig start.*/
    $m("LevelConfig", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "LevelConfig", menuName: "ScriptableObjects/LevelConfig", order: 1
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"BlocksPaintingConfig","t":4,"rt":PaintingConfig,"sn":"BlocksPaintingConfig"},{"a":2,"n":"CollectorsConfig","t":4,"rt":LevelColorCollectorsConfig,"sn":"CollectorsConfig"},{"a":2,"n":"ColorsUsed","t":4,"rt":$n[6].List$1(System.String),"sn":"ColorsUsed"}]}; }, $n);
    /*LevelConfig end.*/

    /*LevelConfigGetAllColorCode start.*/
    $m("LevelConfigGetAllColorCode", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"at":[new UnityEngine.ContextMenu.ctor("Extract Color Codes")],"a":2,"n":"ExtractColorCodes","t":8,"sn":"ExtractColorCodes","rt":$n[1].Void},{"a":2,"n":"Levels","t":4,"rt":$n[6].List$1(LevelConfig),"sn":"Levels"}]}; }, $n);
    /*LevelConfigGetAllColorCode end.*/

    /*LevelMechanicObjectPrefabs start.*/
    $m("LevelMechanicObjectPrefabs", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "LevelObjectPrefabs", menuName: "ColorPixelFlow/Level Object Prefabs", order: 0
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"BigBlockPrefab","t":4,"rt":$n[2].GameObject,"sn":"BigBlockPrefab"},{"at":[new UnityEngine.SpaceAttribute.ctor()],"a":2,"n":"ColorPallete","t":4,"rt":ColorPalleteData,"sn":"ColorPallete"},{"a":2,"n":"DefaultBlockPrefab","t":4,"rt":$n[2].GameObject,"sn":"DefaultBlockPrefab"},{"at":[new UnityEngine.SpaceAttribute.ctor()],"a":2,"n":"GunnerPrefab","t":4,"rt":$n[2].GameObject,"sn":"GunnerPrefab"},{"a":2,"n":"KeyObjectPrefab","t":4,"rt":$n[2].GameObject,"sn":"KeyObjectPrefab"},{"at":[new UnityEngine.SpaceAttribute.ctor()],"a":2,"n":"LockPrefab","t":4,"rt":$n[2].GameObject,"sn":"LockPrefab"},{"a":2,"n":"PipeBodyPrefab","t":4,"rt":$n[2].GameObject,"sn":"PipeBodyPrefab"},{"a":2,"n":"PipeHeadPrefab","t":4,"rt":$n[2].GameObject,"sn":"PipeHeadPrefab"},{"a":2,"n":"PipeObjectPrefab","t":4,"rt":$n[2].GameObject,"sn":"PipeObjectPrefab"},{"a":2,"n":"PipeTailPrefab","t":4,"rt":$n[2].GameObject,"sn":"PipeTailPrefab"}]}; }, $n);
    /*LevelMechanicObjectPrefabs end.*/

    /*PaintingConfig start.*/
    $m("PaintingConfig", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "PaintingConfig", menuName: "ScriptableObjects/PaintingConfig", order: 1
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ClearData","t":8,"sn":"ClearData","rt":$n[1].Void},{"a":2,"n":"GetAllWorkingPixels","t":8,"sn":"GetAllWorkingPixels","rt":$n[6].List$1(PaintingPixelConfig)},{"a":2,"n":"GetAllWorkingPixelsExceptHearts","t":8,"sn":"GetAllWorkingPixelsExceptHearts","rt":$n[6].List$1(PaintingPixelConfig)},{"a":2,"n":"GetKeySetup","t":8,"pi":[{"n":"startPixel","pt":PaintingPixel,"ps":0},{"n":"endPixel","pt":PaintingPixel,"ps":1}],"sn":"GetKeySetup","rt":KeyObjectSetup,"p":[PaintingPixel,PaintingPixel]},{"a":2,"n":"GetPipeSetup","t":8,"pi":[{"n":"startPixel","pt":PaintingPixel,"ps":0},{"n":"endPixel","pt":PaintingPixel,"ps":1}],"sn":"GetPipeSetup","rt":PipeObjectSetup,"p":[PaintingPixel,PaintingPixel]},{"a":2,"n":"GetWallSetup","t":8,"pi":[{"n":"startPixel","pt":PaintingPixel,"ps":0},{"n":"endPixel","pt":PaintingPixel,"ps":1}],"sn":"GetWallSetup","rt":WallObjectSetup,"p":[PaintingPixel,PaintingPixel]},{"a":2,"n":"HidePixelsUnderPipes","t":8,"sn":"HidePixelsUnderPipes","rt":$n[1].Void},{"a":2,"n":"ReShowPixelsUnderPipe","t":8,"pi":[{"n":"_pipe","pt":PipeObject,"ps":0}],"sn":"ReShowPixelsUnderPipe","rt":$n[1].Void,"p":[PipeObject]},{"at":[new UnityEngine.HeaderAttribute("SPECIAL OBJECT: ADDITION PIXELS")],"a":2,"n":"AdditionPixels","t":4,"rt":$n[6].List$1(PaintingPixelConfig),"sn":"AdditionPixels"},{"at":[new UnityEngine.HeaderAttribute("SPECIAL OBJECT: KEY")],"a":2,"n":"KeySetups","t":4,"rt":$n[6].List$1(KeyObjectSetup),"sn":"KeySetups"},{"a":2,"n":"PaintingSize","t":4,"rt":$n[2].Vector2,"sn":"PaintingSize"},{"at":[new UnityEngine.HeaderAttribute("SPECIAL OBJECT: PIPE")],"a":2,"n":"PipeSetups","t":4,"rt":$n[6].List$1(PipeObjectSetup),"sn":"PipeSetups"},{"a":2,"n":"Pixels","t":4,"rt":$n[6].List$1(PaintingPixelConfig),"sn":"Pixels"},{"a":2,"n":"Sprite","t":4,"rt":$n[2].Sprite,"sn":"Sprite"},{"at":[new UnityEngine.HeaderAttribute("SPECIAL OBJECT: WALL")],"a":2,"n":"WallSetups","t":4,"rt":$n[6].List$1(WallObjectSetup),"sn":"WallSetups"}]}; }, $n);
    /*PaintingConfig end.*/

    /*PaintingConfigBackUp start.*/
    $m("PaintingConfigBackUp", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"n":".ctor","t":1,"p":[PaintingConfig],"pi":[{"n":"_stock","pt":PaintingConfig,"ps":0}],"sn":"ctor"},{"a":2,"n":"AdditionPixels","t":4,"rt":$n[6].List$1(PaintingPixelConfig),"sn":"AdditionPixels"},{"a":2,"n":"DateTime","t":4,"rt":$n[1].String,"sn":"DateTime"},{"a":2,"n":"KeySetup","t":4,"rt":$n[6].List$1(KeyObjectSetup),"sn":"KeySetup"},{"a":2,"n":"PipeSetup","t":4,"rt":$n[6].List$1(PipeObjectSetup),"sn":"PipeSetup"},{"a":2,"n":"Pixels","t":4,"rt":$n[6].List$1(PaintingPixelConfig),"sn":"Pixels"},{"a":2,"n":"WallSetup","t":4,"rt":$n[6].List$1(WallObjectSetup),"sn":"WallSetup"},{"a":2,"n":"_paintingSize","t":4,"rt":$n[2].Vector2,"sn":"_paintingSize"}]}; }, $n);
    /*PaintingConfigBackUp end.*/

    /*PaintingPixel start.*/
    $m("PaintingPixel", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[PaintingPixelConfig,$n[2].Material],"pi":[{"n":"config","pt":PaintingPixelConfig,"ps":0},{"n":"initialMaterial","dv":null,"o":true,"pt":$n[2].Material,"ps":1}],"sn":"$ctor1"},{"a":2,"n":".ctor","t":1,"p":[$n[1].Int32,$n[1].Int32,$n[2].Color,$n[2].Vector3,$n[1].Int32,$n[1].Boolean,$n[2].GameObject,$n[2].Material],"pi":[{"n":"column","pt":$n[1].Int32,"ps":0},{"n":"row","pt":$n[1].Int32,"ps":1},{"n":"color","pt":$n[2].Color,"ps":2},{"n":"worldPos","pt":$n[2].Vector3,"ps":3},{"n":"heart","pt":$n[1].Int32,"ps":4},{"n":"hidden","pt":$n[1].Boolean,"ps":5},{"n":"pixelObject","dv":null,"o":true,"pt":$n[2].GameObject,"ps":6},{"n":"material","dv":null,"o":true,"pt":$n[2].Material,"ps":7}],"sn":"$ctor2"},{"a":2,"n":"DestroyObject","t":8,"sn":"DestroyObject","rt":$n[1].Void},{"a":2,"n":"DestroyPixel","t":8,"pi":[{"n":"invokeEvent","dv":true,"o":true,"pt":$n[1].Boolean,"ps":0},{"n":"collectorObject","dv":null,"o":true,"pt":ColorPixelsCollectorObject,"ps":1}],"sn":"DestroyPixel","rt":$n[1].Void,"p":[$n[1].Boolean,ColorPixelsCollectorObject]},{"a":2,"n":"InCount","t":8,"sn":"InCount","rt":$n[1].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsCompleteHidden","t":8,"sn":"IsCompleteHidden","rt":$n[1].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SetPosition","t":8,"pi":[{"n":"newPos","pt":$n[2].Vector3,"ps":0}],"sn":"SetPosition","rt":$n[1].Void,"p":[$n[2].Vector3]},{"a":2,"n":"SetUp","t":8,"pi":[{"n":"color","pt":$n[2].Color,"ps":0},{"n":"colorCode","pt":$n[1].String,"ps":1},{"n":"hidden","pt":$n[1].Boolean,"ps":2}],"sn":"SetUp","rt":$n[1].Void,"p":[$n[2].Color,$n[1].String,$n[1].Boolean]},{"a":2,"n":"ShowPixelObject","t":8,"sn":"ShowPixelObject","rt":$n[1].Void},{"a":2,"n":"Hearts","t":4,"rt":$n[1].Int32,"sn":"Hearts","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"Hidden","t":4,"rt":$n[1].Boolean,"sn":"Hidden","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Indestructible","t":4,"rt":$n[1].Boolean,"sn":"Indestructible","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsPipePixel","t":4,"rt":$n[1].Boolean,"sn":"IsPipePixel","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsWallPixel","t":4,"rt":$n[1].Boolean,"sn":"IsWallPixel","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("sharedMaterial")],"a":2,"n":"Material","t":4,"rt":$n[2].Material,"sn":"Material"},{"a":2,"n":"PixelComponent","t":4,"rt":PaintingPixelComponent,"sn":"PixelComponent"},{"a":2,"n":"UsePaletteMaterialColor","t":4,"rt":$n[1].Boolean,"sn":"UsePaletteMaterialColor","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"VunableToAll","t":4,"rt":$n[1].Boolean,"sn":"VunableToAll","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"color","t":4,"rt":$n[2].Color,"sn":"color"},{"a":2,"n":"colorCode","t":4,"rt":$n[1].String,"sn":"colorCode"},{"a":2,"n":"column","t":4,"rt":$n[1].Int32,"sn":"column","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"destroyed","t":4,"rt":$n[1].Boolean,"sn":"destroyed","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"name","t":4,"rt":$n[1].String,"sn":"name"},{"a":2,"n":"pixelObject","t":4,"rt":$n[2].GameObject,"sn":"pixelObject"},{"a":2,"n":"row","t":4,"rt":$n[1].Int32,"sn":"row","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"worldPos","t":4,"rt":$n[2].Vector3,"sn":"worldPos"}]}; }, $n);
    /*PaintingPixel end.*/

    /*PaintingPixelComponent start.*/
    $m("PaintingPixelComponent", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"ApplyColorOverride","t":8,"sn":"ApplyColorOverride","rt":$n[1].Void},{"a":2,"n":"ApplyPosition","t":8,"sn":"ApplyPosition","rt":$n[1].Void},{"a":2,"n":"ApplyVisual","t":8,"sn":"ApplyVisual","rt":$n[1].Void},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[1].Void},{"a":2,"n":"ClearColorOverride","t":8,"sn":"ClearColorOverride","rt":$n[1].Void},{"a":1,"n":"ColorEqual","t":8,"pi":[{"n":"a","pt":$n[2].Color,"ps":0},{"n":"b","pt":$n[2].Color,"ps":1},{"n":"tolerance","dv":0.001,"o":true,"pt":$n[1].Single,"ps":2}],"sn":"ColorEqual","rt":$n[1].Boolean,"p":[$n[2].Color,$n[2].Color,$n[1].Single],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"CreatePumpTween","t":8,"sn":"CreatePumpTween","rt":$n[1].Void},{"at":[new UnityEngine.ContextMenu.ctor("Create Shake Tween")],"a":1,"n":"CreateShakeTween","t":8,"sn":"CreateShakeTween","rt":$n[1].Void},{"a":2,"n":"DestroyPixelVisually","t":8,"sn":"DestroyPixelVisually","rt":$n[1].Void},{"a":2,"n":"Destroyed","t":8,"sn":"Destroyed$1","rt":$n[1].Void},{"a":2,"n":"GetWorldPosition","t":8,"sn":"GetWorldPosition","rt":$n[2].Vector3},{"a":2,"n":"HideVisualOnly","t":8,"sn":"HideVisualOnly","rt":$n[1].Void},{"a":2,"n":"IsDestroyed","t":8,"sn":"IsDestroyed","rt":$n[1].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[1].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[1].Void},{"a":2,"n":"PlayPumpAndDisable","t":8,"sn":"PlayPumpAndDisable","rt":$n[1].Void},{"at":[new UnityEngine.ContextMenu.ctor("Play Shake")],"a":2,"n":"PlayShake","t":8,"sn":"PlayShake","rt":$n[1].Void},{"a":2,"n":"SelfDestroy","t":8,"sn":"SelfDestroy","rt":$n[1].Void},{"a":2,"n":"SetColor","t":8,"pi":[{"n":"color","pt":$n[2].Color,"ps":0}],"sn":"SetColor","rt":$n[1].Void,"p":[$n[2].Color]},{"a":1,"n":"SetRendererMaterial","t":8,"sn":"SetRendererMaterial","rt":$n[1].Void},{"a":2,"n":"SetUp","t":8,"pi":[{"n":"newPixel","pt":PaintingPixel,"ps":0}],"sn":"SetUp","rt":$n[1].Void,"p":[PaintingPixel]},{"a":2,"n":"ShowVisualOnly","t":8,"sn":"ShowVisualOnly","rt":$n[1].Void},{"a":2,"n":"StopShake","t":8,"sn":"StopShake","rt":$n[1].Void},{"a":2,"n":"CubeRenderer","t":4,"rt":$n[2].MeshRenderer,"sn":"CubeRenderer"},{"a":2,"n":"CubeTransform","t":4,"rt":$n[2].Transform,"sn":"CubeTransform"},{"a":2,"n":"CurrentHearts","t":4,"rt":$n[1].Int32,"sn":"CurrentHearts","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.HeaderAttribute("ANIM: SHAKE")],"a":2,"n":"EffectOptions","t":4,"rt":InGameEffectOptions,"sn":"EffectOptions"},{"a":2,"n":"PixelData","t":4,"rt":PaintingPixel,"sn":"PixelData"},{"at":[new UnityEngine.HeaderAttribute("Perf/Debug")],"a":2,"n":"UseLazyTweens","t":4,"rt":$n[1].Boolean,"sn":"UseLazyTweens","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_logMissingOnce","is":true,"t":4,"rt":$n[1].Boolean,"sn":"_logMissingOnce","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"initScale","t":4,"rt":$n[2].Vector3,"sn":"initScale"},{"a":1,"n":"pumpTween","t":4,"rt":$n[5].Sequence,"sn":"pumpTween"},{"a":2,"n":"shakeDuration","t":4,"rt":$n[1].Single,"sn":"shakeDuration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"shakeLoops","t":4,"rt":$n[1].Int32,"sn":"shakeLoops","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"shakeTween","t":4,"rt":$n[5].Sequence,"sn":"shakeTween"}]}; }, $n);
    /*PaintingPixelComponent end.*/

    /*PaintingPixelConfig start.*/
    $m("PaintingPixelConfig", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[PaintingPixel],"pi":[{"n":"_pixelObj","pt":PaintingPixel,"ps":0}],"sn":"$ctor1"},{"a":2,"n":".ctor","t":1,"p":[PaintingPixelConfig],"pi":[{"n":"_stock","pt":PaintingPixelConfig,"ps":0}],"sn":"$ctor2"},{"a":2,"n":"Hidden","t":4,"rt":$n[1].Boolean,"sn":"Hidden","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"color","t":4,"rt":$n[2].Color,"sn":"color"},{"a":2,"n":"colorCode","t":4,"rt":$n[1].String,"sn":"colorCode"},{"a":2,"n":"column","t":4,"rt":$n[1].Int32,"sn":"column","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"row","t":4,"rt":$n[1].Int32,"sn":"row","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*PaintingPixelConfig end.*/

    /*PaintingSharedAttributes start.*/
    $m("PaintingSharedAttributes", function () { return {"nested":[PaintingSharedAttributes.IntPixelListPair,PaintingSharedAttributes.ColorPixelListPair],"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"GetCollectorConfigByID","is":true,"t":8,"pi":[{"n":"_list","pt":$n[6].List$1(SingleColorCollectorConfig),"ps":0},{"n":"ID","pt":$n[1].Int32,"ps":1}],"sn":"GetCollectorConfigByID","rt":SingleColorCollectorConfig,"p":[$n[6].List$1(SingleColorCollectorConfig),$n[1].Int32]},{"a":2,"n":"InsertRelative","is":true,"t":8,"pi":[{"n":"list","pt":$n[6].List$1(System.Object),"ps":0},{"n":"newItem","pt":System.Object,"ps":1},{"n":"targetItem","pt":System.Object,"ps":2},{"n":"higher","pt":$n[1].Boolean,"ps":3}],"tpc":1,"tprm":["T"],"sn":"InsertRelative","rt":$n[1].Void,"p":[$n[6].List$1(System.Object),System.Object,System.Object,$n[1].Boolean]},{"a":2,"n":"MoveRelative","is":true,"t":8,"pi":[{"n":"list","pt":$n[6].List$1(System.Object),"ps":0},{"n":"itemToMove","pt":System.Object,"ps":1},{"n":"targetItem","pt":System.Object,"ps":2},{"n":"higher","pt":$n[1].Boolean,"ps":3}],"tpc":1,"tprm":["T"],"sn":"MoveRelative","rt":$n[1].Void,"p":[$n[6].List$1(System.Object),System.Object,System.Object,$n[1].Boolean]},{"a":2,"n":"Shuffle","is":true,"t":8,"pi":[{"n":"list","pt":$n[6].IList$1(System.Object),"ps":0}],"tpc":1,"tprm":["T"],"sn":"Shuffle","rt":$n[1].Void,"p":[$n[6].IList$1(System.Object)]},{"a":2,"n":"CollectorsConfigPath","is":true,"t":4,"rt":$n[1].String,"sn":"CollectorsConfigPath"},{"a":2,"n":"DefaultColorKey","is":true,"t":4,"rt":$n[1].String,"sn":"DefaultColorKey"},{"a":2,"n":"LevelConfigPath","is":true,"t":4,"rt":$n[1].String,"sn":"LevelConfigPath"},{"a":2,"n":"LockKeyColorDefine","is":true,"t":4,"rt":$n[1].String,"sn":"LockKeyColorDefine"},{"a":2,"n":"PaintingConfigPath","is":true,"t":4,"rt":$n[1].String,"sn":"PaintingConfigPath"},{"a":2,"n":"TransparentColorKey","is":true,"t":4,"rt":$n[1].String,"sn":"TransparentColorKey"}]}; }, $n);
    /*PaintingSharedAttributes end.*/

    /*PaintingSharedAttributes+IntPixelListPair start.*/
    $m("PaintingSharedAttributes.IntPixelListPair", function () { return {"td":PaintingSharedAttributes,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"n":".ctor","t":1,"p":[$n[1].Int32,$n[6].List$1(PaintingPixel)],"pi":[{"n":"key","pt":$n[1].Int32,"ps":0},{"n":"pixels","pt":$n[6].List$1(PaintingPixel),"ps":1}],"sn":"ctor"},{"a":2,"n":"key","t":4,"rt":$n[1].Int32,"sn":"key","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"pixels","t":4,"rt":$n[6].List$1(PaintingPixel),"sn":"pixels"}]}; }, $n);
    /*PaintingSharedAttributes+IntPixelListPair end.*/

    /*PaintingSharedAttributes+ColorPixelListPair start.*/
    $m("PaintingSharedAttributes.ColorPixelListPair", function () { return {"td":PaintingSharedAttributes,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"n":".ctor","t":1,"p":[$n[1].String,$n[6].List$1(PaintingPixel)],"pi":[{"n":"colorCode","pt":$n[1].String,"ps":0},{"n":"pixels","pt":$n[6].List$1(PaintingPixel),"ps":1}],"sn":"ctor"},{"a":2,"n":"ColorCode","t":4,"rt":$n[1].String,"sn":"ColorCode"},{"a":2,"n":"pixels","t":4,"rt":$n[6].List$1(PaintingPixel),"sn":"pixels"}]}; }, $n);
    /*PaintingSharedAttributes+ColorPixelListPair end.*/

    /*PipeObjectSetup start.*/
    $m("PipeObjectSetup", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[PipeObjectSetup],"pi":[{"n":"_stock","pt":PipeObjectSetup,"ps":0}],"sn":"$ctor1"},{"a":2,"n":".ctor","t":1,"p":[$n[6].List$1(PaintingPixelConfig),$n[1].String,$n[2].Vector3,$n[1].Int32],"pi":[{"n":"pixelCovered","pt":$n[6].List$1(PaintingPixelConfig),"ps":0},{"n":"colorCode","pt":$n[1].String,"ps":1},{"n":"scale","pt":$n[2].Vector3,"ps":2},{"n":"heart","pt":$n[1].Int32,"ps":3}],"sn":"$ctor2"},{"a":2,"n":"ColorCode","t":4,"rt":$n[1].String,"sn":"ColorCode"},{"a":2,"n":"Hearts","t":4,"rt":$n[1].Int32,"sn":"Hearts","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"PixelCovered","t":4,"rt":$n[6].List$1(PaintingPixelConfig),"sn":"PixelCovered"},{"a":2,"n":"Scale","t":4,"rt":$n[2].Vector3,"sn":"Scale"}]}; }, $n);
    /*PipeObjectSetup end.*/

    /*PixelMaterialFallbackProvider start.*/
    $m("PixelMaterialFallbackProvider", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[1].Void},{"a":2,"n":"GlobalFallback","is":true,"t":16,"rt":$n[2].Material,"g":{"a":2,"n":"get_GlobalFallback","t":8,"rt":$n[2].Material,"fg":"GlobalFallback","is":true},"fn":"GlobalFallback"},{"at":[new UnityEngine.TooltipAttribute("Fallback material used when a pixel's material reference is missing. Should be a palette/shared asset, NOT an instanced material.")],"a":2,"n":"FallbackMaterial","t":4,"rt":$n[2].Material,"sn":"FallbackMaterial"},{"a":1,"n":"_instance","is":true,"t":4,"rt":PixelMaterialFallbackProvider,"sn":"_instance"}]}; }, $n);
    /*PixelMaterialFallbackProvider end.*/

    /*SplineDataContainer start.*/
    $m("SplineDataContainer", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "SplineDataContainer", menuName: "Curvy/Spline Data Container", order: 1
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"InitializeArrays","t":8,"pi":[{"n":"size","pt":$n[1].Int32,"ps":0}],"sn":"InitializeArrays","rt":$n[1].Void,"p":[$n[1].Int32]},{"a":2,"n":"IsValid","t":8,"sn":"IsValid","rt":$n[1].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"distances","t":4,"rt":$n[1].Array.type(System.Single),"sn":"distances"},{"at":[new UnityEngine.HeaderAttribute("Cached Spline Data")],"a":2,"n":"positions","t":4,"rt":System.Array.type(UnityEngine.Vector3),"sn":"positions"},{"a":2,"n":"resolution","t":4,"rt":$n[1].Single,"sn":"resolution","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"sampleCount","t":4,"rt":$n[1].Int32,"sn":"sampleCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"tangents","t":4,"rt":System.Array.type(UnityEngine.Vector3),"sn":"tangents"},{"at":[new UnityEngine.HeaderAttribute("Spline Metadata")],"a":2,"n":"totalDistance","t":4,"rt":$n[1].Single,"sn":"totalDistance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"upVectors","t":4,"rt":System.Array.type(UnityEngine.Vector3),"sn":"upVectors"},{"a":2,"n":"version","t":4,"rt":$n[1].String,"sn":"version"}]}; }, $n);
    /*SplineDataContainer end.*/

    /*WallObjectSetup start.*/
    $m("WallObjectSetup", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[WallObjectSetup],"pi":[{"n":"_stock","pt":WallObjectSetup,"ps":0}],"sn":"$ctor2"},{"a":2,"n":".ctor","t":1,"p":[$n[6].List$1(PaintingPixelConfig),$n[1].String,$n[1].Int32],"pi":[{"n":"pixelCovered","pt":$n[6].List$1(PaintingPixelConfig),"ps":0},{"n":"colorCode","pt":$n[1].String,"ps":1},{"n":"hearts","pt":$n[1].Int32,"ps":2}],"sn":"$ctor1"},{"a":2,"n":"ColorCode","t":4,"rt":$n[1].String,"sn":"ColorCode"},{"a":2,"n":"Hearts","t":4,"rt":$n[1].Int32,"sn":"Hearts","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"PixelCovered","t":4,"rt":$n[6].List$1(PaintingPixelConfig),"sn":"PixelCovered"}]}; }, $n);
    /*WallObjectSetup end.*/

    /*HelperCoroutine start.*/
    $m("HelperCoroutine", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"ClearCache","is":true,"t":8,"sn":"ClearCache","rt":$n[1].Void},{"a":1,"n":"DelayCall","is":true,"t":8,"pi":[{"n":"frames","pt":$n[1].Int32,"ps":0},{"n":"callback","pt":Function,"ps":1}],"sn":"DelayCall","rt":$n[0].IEnumerator,"p":[$n[1].Int32,Function]},{"a":1,"n":"DelayCall","is":true,"t":8,"pi":[{"n":"seconds","pt":$n[1].Single,"ps":0},{"n":"callback","pt":Function,"ps":1}],"sn":"DelayCall$1","rt":$n[0].IEnumerator,"p":[$n[1].Single,Function]},{"a":2,"n":"DelayFrames","is":true,"t":8,"pi":[{"n":"mono","pt":$n[2].MonoBehaviour,"ps":0},{"n":"frames","pt":$n[1].Int32,"ps":1},{"n":"callback","pt":Function,"ps":2}],"sn":"DelayFrames","rt":$n[1].Void,"p":[$n[2].MonoBehaviour,$n[1].Int32,Function]},{"a":2,"n":"DelaySeconds","is":true,"t":8,"pi":[{"n":"mono","pt":$n[2].MonoBehaviour,"ps":0},{"n":"seconds","pt":$n[1].Single,"ps":1},{"n":"callback","pt":Function,"ps":2}],"sn":"DelaySeconds","rt":$n[1].Void,"p":[$n[2].MonoBehaviour,$n[1].Single,Function]},{"a":1,"n":"RunCall","is":true,"t":8,"pi":[{"n":"frames","pt":$n[1].Int32,"ps":0},{"n":"callback","pt":Function,"ps":1}],"sn":"RunCall","rt":$n[0].IEnumerator,"p":[$n[1].Int32,Function]},{"a":1,"n":"RunCall","is":true,"t":8,"pi":[{"n":"seconds","pt":$n[1].Single,"ps":0},{"n":"callback","pt":Function,"ps":1}],"sn":"RunCall$1","rt":$n[0].IEnumerator,"p":[$n[1].Single,Function]},{"a":2,"n":"RunOnFrames","is":true,"t":8,"pi":[{"n":"mono","pt":$n[2].MonoBehaviour,"ps":0},{"n":"frames","pt":$n[1].Int32,"ps":1},{"n":"callback","pt":Function,"ps":2}],"sn":"RunOnFrames","rt":$n[1].Void,"p":[$n[2].MonoBehaviour,$n[1].Int32,Function]},{"a":2,"n":"RunOnSeconds","is":true,"t":8,"pi":[{"n":"mono","pt":$n[2].MonoBehaviour,"ps":0},{"n":"seconds","pt":$n[1].Single,"ps":1},{"n":"callback","pt":Function,"ps":2}],"sn":"RunOnSeconds","rt":$n[1].Void,"p":[$n[2].MonoBehaviour,$n[1].Single,Function]},{"a":2,"n":"WaitSeconds","is":true,"t":8,"pi":[{"n":"seconds","pt":$n[1].Single,"ps":0}],"sn":"WaitSeconds","rt":$n[2].WaitForSeconds,"p":[$n[1].Single]},{"a":1,"n":"MAX_CACHE_SIZE","is":true,"t":4,"rt":$n[1].Int32,"sn":"MAX_CACHE_SIZE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"_waitForSeconds","is":true,"t":4,"rt":$n[6].Dictionary$2(System.Single,UnityEngine.WaitForSeconds),"sn":"_waitForSeconds"}]}; }, $n);
    /*HelperCoroutine end.*/

    /*Singleton$1 start.*/
    $m("Singleton$1", function (T) { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"v":true,"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[1].Void},{"a":2,"n":"Instance","is":true,"t":16,"rt":T,"g":{"a":2,"n":"get_Instance","t":8,"rt":T,"fg":"Instance","is":true},"s":{"a":3,"n":"set_Instance","t":8,"p":[T],"rt":$n[1].Void,"fs":"Instance","is":true},"fn":"Instance"},{"a":1,"backing":true,"n":"<Instance>k__BackingField","is":true,"t":4,"rt":T,"sn":"Instance"}]}; }, $n);
    /*Singleton$1 end.*/

    /*SoundDefine start.*/
    $m("SoundDefine", function () { return {"att":1057033,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[1].Void},{"a":2,"n":"Clip","t":4,"rt":$n[2].AudioClip,"sn":"Clip"},{"a":2,"n":"ClipList","t":4,"rt":$n[6].List$1(UnityEngine.AudioClip),"sn":"ClipList"},{"a":2,"n":"Loop","t":4,"rt":$n[1].Boolean,"sn":"Loop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"soundType","t":4,"rt":SoundType,"sn":"soundType","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}}]}; }, $n);
    /*SoundDefine end.*/

    /*SoundType start.*/
    $m("SoundType", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"BackgroundMusic","is":true,"t":4,"rt":SoundType,"sn":"BackgroundMusic","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Button","is":true,"t":4,"rt":SoundType,"sn":"Button","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Effect","is":true,"t":4,"rt":SoundType,"sn":"Effect","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Hide","is":true,"t":4,"rt":SoundType,"sn":"Hide","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"MouseSystem","is":true,"t":4,"rt":SoundType,"sn":"MouseSystem","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"None","is":true,"t":4,"rt":SoundType,"sn":"None","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Slider","is":true,"t":4,"rt":SoundType,"sn":"Slider","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}},{"a":2,"n":"Toggle","is":true,"t":4,"rt":SoundType,"sn":"Toggle","box":function ($v) { return Bridge.box($v, SoundType, System.Enum.toStringFn(SoundType));}}]}; }, $n);
    /*SoundType end.*/

    /*SoundManager start.*/
    $m("SoundManager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"ChangeVolumeSpecialBgmSound","t":8,"pi":[{"n":"currentValue","pt":$n[1].Single,"ps":0}],"sn":"ChangeVolumeSpecialBgmSound","rt":$n[1].Void,"p":[$n[1].Single]},{"a":2,"n":"LoopSpecialSound","t":8,"pi":[{"n":"clip","pt":$n[2].AudioClip,"ps":0},{"n":"delay","dv":0.0,"o":true,"pt":$n[1].Single,"ps":1},{"n":"bgmRatio","dv":0.0,"o":true,"pt":$n[1].Single,"ps":2}],"sn":"LoopSpecialSound","rt":$n[0].IEnumerator,"p":[$n[2].AudioClip,$n[1].Single,$n[1].Single]},{"a":1,"n":"OnEnableShowFxInGame","t":8,"pi":[{"n":"enable","pt":$n[1].Boolean,"ps":0}],"sn":"OnEnableShowFxInGame","rt":$n[1].Void,"p":[$n[1].Boolean]},{"a":1,"n":"OnMainSoundChange","t":8,"pi":[{"n":"currentValue","pt":$n[1].Single,"ps":0}],"sn":"OnMainSoundChange","rt":$n[1].Void,"p":[$n[1].Single]},{"a":2,"n":"OnPlaySoundBG","t":8,"sn":"OnPlaySoundBG","rt":$n[1].Void},{"a":1,"n":"OnSoundChange","t":8,"pi":[{"n":"currentValue","pt":$n[1].Single,"ps":0}],"sn":"OnSoundChange","rt":$n[1].Void,"p":[$n[1].Single]},{"a":1,"n":"OnSoundFxChange","t":8,"pi":[{"n":"currentValue","pt":$n[1].Single,"ps":0}],"sn":"OnSoundFxChange","rt":$n[1].Void,"p":[$n[1].Single]},{"a":1,"n":"PlayDelayed","t":8,"pi":[{"n":"clip","pt":$n[2].AudioClip,"ps":0},{"n":"delay","pt":$n[1].Single,"ps":1},{"n":"volume","dv":1.0,"o":true,"pt":$n[1].Single,"ps":2}],"sn":"PlayDelayed","rt":$n[0].IEnumerator,"p":[$n[2].AudioClip,$n[1].Single,$n[1].Single]},{"a":2,"n":"PlayOneShot","t":8,"pi":[{"n":"clip","pt":$n[2].AudioClip,"ps":0},{"n":"volume","dv":1.0,"o":true,"pt":$n[1].Single,"ps":1}],"sn":"PlayOneShot","rt":$n[1].Void,"p":[$n[2].AudioClip,$n[1].Single]},{"a":2,"n":"PlayOneShotDelayed","t":8,"pi":[{"n":"clip","pt":$n[2].AudioClip,"ps":0},{"n":"delay","pt":$n[1].Single,"ps":1},{"n":"volume","dv":1.0,"o":true,"pt":$n[1].Single,"ps":2}],"sn":"PlayOneShotDelayed","rt":$n[1].Void,"p":[$n[2].AudioClip,$n[1].Single,$n[1].Single]},{"a":2,"n":"PlayOneShotFx","t":8,"pi":[{"n":"clip","pt":$n[2].AudioClip,"ps":0}],"sn":"PlayOneShotFx","rt":$n[1].Void,"p":[$n[2].AudioClip]},{"a":2,"n":"PlayRandomBGM","is":true,"t":8,"pi":[{"n":"sound","pt":SoundDefine,"ps":0}],"sn":"PlayRandomBGM","rt":$n[1].Void,"p":[SoundDefine]},{"a":2,"n":"PlaySound","is":true,"t":8,"pi":[{"n":"sound","pt":SoundDefine,"ps":0}],"sn":"PlaySound","rt":$n[1].Void,"p":[SoundDefine]},{"a":2,"n":"PlaySpecialSoundLoop","t":8,"pi":[{"n":"clip","pt":$n[2].AudioClip,"ps":0},{"n":"delay","dv":0.0,"o":true,"pt":$n[1].Single,"ps":1},{"n":"bgmRatio","dv":0.0,"o":true,"pt":$n[1].Single,"ps":2}],"sn":"PlaySpecialSoundLoop","rt":$n[1].Void,"p":[$n[2].AudioClip,$n[1].Single,$n[1].Single]},{"a":1,"n":"SetBoolEndGameUI","t":8,"pi":[{"n":"value","pt":$n[1].Boolean,"ps":0}],"sn":"SetBoolEndGameUI","rt":$n[1].Void,"p":[$n[1].Boolean]},{"a":2,"n":"SetSpeedAudioGroup","t":8,"pi":[{"n":"group","pt":SoundMixerGroup,"ps":0},{"n":"speed","pt":$n[1].Single,"ps":1}],"sn":"SetSpeedAudioGroup","rt":$n[1].Void,"p":[SoundMixerGroup,$n[1].Single]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[1].Void},{"a":2,"n":"StopSound","is":true,"t":8,"pi":[{"n":"sound","pt":SoundDefine,"ps":0}],"sn":"StopSound","rt":$n[1].Void,"p":[SoundDefine]},{"a":2,"n":"StopSpecialSoundLoop","t":8,"sn":"StopSpecialSoundLoop","rt":$n[1].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[1].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"BGM","t":4,"rt":SoundDefine,"sn":"BGM"},{"a":1,"n":"_backGroundMusics","is":true,"t":4,"rt":$n[6].List$1(UnityEngine.AudioClip),"sn":"_backGroundMusics"},{"a":1,"n":"_bgmWaitingList","is":true,"t":4,"rt":$n[6].List$1(UnityEngine.AudioClip),"sn":"_bgmWaitingList"},{"a":1,"n":"_isEndGame","t":4,"rt":$n[1].Boolean,"sn":"_isEndGame","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_isFxPauseBySpeed","t":4,"rt":$n[1].Boolean,"sn":"_isFxPauseBySpeed","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_isLoopRandomBGM","t":4,"rt":$n[1].Boolean,"sn":"_isLoopRandomBGM","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_specialSoundLoop","t":4,"rt":$n[2].Coroutine,"sn":"_specialSoundLoop"},{"a":1,"n":"_specialSoundStopCountDown","t":4,"rt":$n[2].Coroutine,"sn":"_specialSoundStopCountDown"},{"a":1,"n":"_specialSoundTween","t":4,"rt":$n[5].Tween,"sn":"_specialSoundTween"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"audioMixer","t":4,"rt":$n[8].AudioMixer,"sn":"audioMixer"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"fxMusicSource","t":4,"rt":$n[2].AudioSource,"sn":"fxMusicSource"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isPlayBgmOnStart","t":4,"rt":$n[1].Boolean,"sn":"isPlayBgmOnStart","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"specialBgmSource","t":4,"rt":$n[2].AudioSource,"sn":"specialBgmSource"}]}; }, $n);
    /*SoundManager end.*/

    /*SoundMixerGroup start.*/
    $m("SoundMixerGroup", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"MainSound","is":true,"t":4,"rt":SoundMixerGroup,"sn":"MainSound","box":function ($v) { return Bridge.box($v, SoundMixerGroup, System.Enum.toStringFn(SoundMixerGroup));}},{"a":2,"n":"Sound","is":true,"t":4,"rt":SoundMixerGroup,"sn":"Sound","box":function ($v) { return Bridge.box($v, SoundMixerGroup, System.Enum.toStringFn(SoundMixerGroup));}},{"a":2,"n":"SoundFx","is":true,"t":4,"rt":SoundMixerGroup,"sn":"SoundFx","box":function ($v) { return Bridge.box($v, SoundMixerGroup, System.Enum.toStringFn(SoundMixerGroup));}},{"a":2,"n":"SoundFxInGame","is":true,"t":4,"rt":SoundMixerGroup,"sn":"SoundFxInGame","box":function ($v) { return Bridge.box($v, SoundMixerGroup, System.Enum.toStringFn(SoundMixerGroup));}},{"a":2,"n":"SpecialSound","is":true,"t":4,"rt":SoundMixerGroup,"sn":"SpecialSound","box":function ($v) { return Bridge.box($v, SoundMixerGroup, System.Enum.toStringFn(SoundMixerGroup));}}]}; }, $n);
    /*SoundMixerGroup end.*/

    /*MathHr start.*/
    $m("MathHr", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"Remap","is":true,"t":8,"pi":[{"n":"main","pt":$n[1].Single,"ps":0},{"n":"minIn","pt":$n[1].Single,"ps":1},{"n":"maxIn","pt":$n[1].Single,"ps":2},{"n":"minOut","pt":$n[1].Single,"ps":3},{"n":"maxOut","pt":$n[1].Single,"ps":4}],"sn":"Remap","rt":$n[1].Single,"p":[$n[1].Single,$n[1].Single,$n[1].Single,$n[1].Single,$n[1].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*MathHr end.*/

    /*SoundUIElement start.*/
    $m("SoundUIElement", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"v":true,"a":3,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[1].Void},{"v":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[1].Void},{"v":true,"a":3,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[1].Void},{"a":2,"n":"OnPointerClick","t":8,"pi":[{"n":"eventData","pt":$n[9].PointerEventData,"ps":0}],"sn":"OnPointerClick","rt":$n[1].Void,"p":[$n[9].PointerEventData]},{"a":2,"n":"OnSubmit","t":8,"pi":[{"n":"eventData","pt":$n[9].BaseEventData,"ps":0}],"sn":"OnSubmit","rt":$n[1].Void,"p":[$n[9].BaseEventData]},{"a":2,"n":"PlayBGM","t":8,"sn":"PlayBGM","rt":$n[0].IEnumerator},{"a":1,"n":"button","t":16,"rt":$n[3].Selectable,"g":{"a":1,"n":"get_button","t":8,"rt":$n[3].Selectable,"fg":"button"},"fn":"button"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"PlayOnEnable","t":4,"rt":$n[1].Boolean,"sn":"PlayOnEnable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Sound","t":4,"rt":SoundDefine,"sn":"Sound"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"StopOnDisable","t":4,"rt":$n[1].Boolean,"sn":"StopOnDisable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_button","t":4,"rt":$n[3].Selectable,"sn":"_button"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isPlayRandomBackGroundMusic","t":4,"rt":$n[1].Boolean,"sn":"isPlayRandomBackGroundMusic","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"playWithInteractable","t":4,"rt":$n[1].Boolean,"sn":"playWithInteractable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*SoundUIElement end.*/

    /*AutoTextureScale start.*/
    $m("AutoTextureScale", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ActiveScaler","t":8,"sn":"ActiveScaler","rt":$n[1].Void},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[1].Void},{"a":2,"n":"DeActiveTextureScaler","t":8,"sn":"DeActiveTextureScaler","rt":$n[1].Void},{"a":1,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[1].Void},{"a":1,"n":"UpdateTextureUV","t":8,"sn":"UpdateTextureUV","rt":$n[1].Void},{"a":2,"n":"Active","t":4,"rt":$n[1].Boolean,"sn":"Active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"block","t":4,"rt":$n[2].MaterialPropertyBlock,"sn":"block"},{"a":1,"n":"frameCounter","t":4,"rt":$n[1].Int32,"sn":"frameCounter","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"referenceScale","t":4,"rt":$n[2].Vector3,"sn":"referenceScale"},{"a":2,"n":"referenceTiling","t":4,"rt":$n[2].Vector2,"sn":"referenceTiling"},{"a":2,"n":"rend","t":4,"rt":$n[2].Renderer,"sn":"rend"},{"at":[new UnityEngine.RangeAttribute(1.0, 60.0)],"a":2,"n":"updateEveryNFrames","t":4,"rt":$n[1].Int32,"sn":"updateEveryNFrames","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*AutoTextureScale end.*/

    /*KeyObject start.*/
    $m("KeyObject", function () { return {"nested":[KeyObject.KeyState],"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[1].Void},{"a":2,"n":"BorderContains","t":8,"pi":[{"n":"_pixel","pt":PaintingPixel,"ps":0}],"sn":"BorderContains","rt":$n[1].Boolean,"p":[PaintingPixel],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"pipePixels","pt":$n[6].List$1(PaintingPixel),"ps":0}],"sn":"Initialize","rt":$n[1].Void,"p":[$n[6].List$1(PaintingPixel)]},{"a":2,"n":"OnAPixelBorderDestroyed","t":8,"sn":"OnAPixelBorderDestroyed","rt":$n[1].Void},{"a":1,"n":"OnCollected","t":8,"pi":[{"n":"_locker","pt":CollectorController,"ps":0}],"sn":"OnCollected","rt":$n[1].Void,"p":[CollectorController]},{"a":2,"n":"OnCollectedByLock","t":8,"pi":[{"n":"_unlocker","pt":CollectorController,"ps":0}],"sn":"OnCollectedByLock","rt":$n[1].Void,"p":[CollectorController]},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[1].Void},{"a":1,"n":"OnGridChange","t":8,"pi":[{"n":"gridObject","pt":PaintingGridObject,"ps":0}],"sn":"OnGridChange","rt":$n[1].Void,"p":[PaintingGridObject]},{"a":2,"n":"SelfDestroy","t":8,"sn":"SelfDestroy","rt":$n[1].Void},{"a":2,"n":"Collected","t":16,"rt":$n[1].Boolean,"g":{"a":2,"n":"get_Collected","t":8,"rt":$n[1].Boolean,"fg":"Collected","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"Collected"},{"a":2,"n":"Locked","t":16,"rt":$n[1].Boolean,"g":{"a":2,"n":"get_Locked","t":8,"rt":$n[1].Boolean,"fg":"Locked","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"Locked"},{"a":2,"n":"ReadyToCollected","t":16,"rt":$n[1].Boolean,"g":{"a":2,"n":"get_ReadyToCollected","t":8,"rt":$n[1].Boolean,"fg":"ReadyToCollected","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"ReadyToCollected"},{"a":2,"n":"BorderPixels","t":4,"rt":$n[6].List$1(UnityEngine.Vector2),"sn":"BorderPixels"},{"a":2,"n":"CollectedFX","t":4,"rt":$n[2].ParticleSystem,"sn":"CollectedFX"},{"a":2,"n":"CollectedSoundFX","t":4,"rt":$n[2].AudioClip,"sn":"CollectedSoundFX"},{"a":2,"n":"CurrentState","t":4,"rt":KeyObject.KeyState,"sn":"CurrentState","box":function ($v) { return Bridge.box($v, KeyObject.KeyState, System.Enum.toStringFn(KeyObject.KeyState));}},{"a":2,"n":"IdleMoving","t":4,"rt":IdleMoveUpDown,"sn":"IdleMoving"},{"at":[new UnityEngine.HeaderAttribute("SOUND")],"a":2,"n":"KeyAudioSource","t":4,"rt":$n[2].AudioSource,"sn":"KeyAudioSource"},{"a":2,"n":"KeyFlySoundFX","t":4,"rt":$n[2].AudioClip,"sn":"KeyFlySoundFX"},{"at":[new UnityEngine.HeaderAttribute("VISUAL")],"a":2,"n":"KeyRenderer","t":4,"rt":$n[2].Renderer,"sn":"KeyRenderer"},{"at":[new UnityEngine.HeaderAttribute("Wall Structure")],"a":2,"n":"KeyTransform","t":4,"rt":$n[2].Transform,"sn":"KeyTransform"},{"a":2,"n":"PaintingPixelsCovered","t":4,"rt":$n[6].List$1(PaintingPixel),"sn":"PaintingPixelsCovered"},{"a":2,"n":"Rotating","t":4,"rt":IdleRotate,"sn":"Rotating"},{"a":2,"n":"TwinkleFX","t":4,"rt":$n[2].ParticleSystem,"sn":"TwinkleFX"}]}; }, $n);
    /*KeyObject end.*/

    /*KeyObject+KeyState start.*/
    $m("KeyObject.KeyState", function () { return {"td":KeyObject,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Collected","is":true,"t":4,"rt":KeyObject.KeyState,"sn":"Collected","box":function ($v) { return Bridge.box($v, KeyObject.KeyState, System.Enum.toStringFn(KeyObject.KeyState));}},{"a":2,"n":"Locked","is":true,"t":4,"rt":KeyObject.KeyState,"sn":"Locked","box":function ($v) { return Bridge.box($v, KeyObject.KeyState, System.Enum.toStringFn(KeyObject.KeyState));}},{"a":2,"n":"ReadyToCollect","is":true,"t":4,"rt":KeyObject.KeyState,"sn":"ReadyToCollect","box":function ($v) { return Bridge.box($v, KeyObject.KeyState, System.Enum.toStringFn(KeyObject.KeyState));}}]}; }, $n);
    /*KeyObject+KeyState end.*/

    /*LevelCollectorsSystem start.*/
    $m("LevelCollectorsSystem", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[1].Void},{"a":2,"n":"ClearExistingCollectors","t":8,"sn":"ClearExistingCollectors","rt":$n[1].Void},{"a":2,"n":"ClearExistingLocks","t":8,"sn":"ClearExistingLocks","rt":$n[1].Void},{"a":2,"n":"CloneNewFromCollector","t":8,"pi":[{"n":"original","pt":ColorPixelsCollectorObject,"ps":0}],"sn":"CloneNewFromCollector","rt":ColorPixelsCollectorObject,"p":[ColorPixelsCollectorObject]},{"a":2,"n":"CreateLockObject","t":8,"sn":"CreateLockObject","rt":$n[1].Void},{"a":1,"n":"FindCollectorControllerByID","t":8,"pi":[{"n":"id","pt":$n[1].Int32,"ps":0}],"sn":"FindCollectorControllerByID","rt":CollectorController,"p":[$n[1].Int32]},{"a":1,"n":"FindConnectedGroup","t":8,"pi":[{"n":"startController","pt":CollectorController,"ps":0}],"sn":"FindConnectedGroup","rt":$n[6].HashSet$1(CollectorController),"p":[CollectorController]},{"a":2,"n":"GetBulletsByColor","t":8,"pi":[{"n":"colorCode","pt":$n[1].String,"ps":0}],"sn":"GetBulletsByColor","rt":$n[1].Int32,"p":[$n[1].String],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"GetCollectorByID","t":8,"pi":[{"n":"ID","pt":$n[1].Int32,"ps":0},{"n":"index","out":true,"pt":$n[1].Int32,"ps":1}],"sn":"GetCollectorByID","rt":ColorPixelsCollectorObject,"p":[$n[1].Int32,$n[1].Int32]},{"a":1,"n":"GetFirstCollector","t":8,"sn":"GetFirstCollector","rt":$n[2].Transform},{"a":1,"n":"GetFirstLockedCollectorMet","t":8,"sn":"GetFirstLockedCollectorMet","rt":LockObject},{"a":1,"n":"InitializeCollections","t":8,"sn":"InitializeCollections","rt":$n[1].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[1].Void},{"a":1,"n":"OnInitializedCollectors","t":8,"sn":"OnInitializedCollectors","rt":$n[1].Void},{"a":1,"n":"OnPlayerCollectAKey","t":8,"sn":"OnPlayerCollectAKey","rt":$n[1].Void},{"a":2,"n":"ReArrangePosition","t":8,"sn":"ReArrangePosition","rt":$n[1].Void},{"a":2,"n":"RemoveCollector","t":8,"pi":[{"n":"target","pt":ColorPixelsCollectorObject,"ps":0}],"sn":"RemoveCollector","rt":$n[1].Void,"p":[ColorPixelsCollectorObject]},{"a":2,"n":"SetUpAndArrangePosition","t":8,"pi":[{"n":"collumnCount","pt":$n[1].Int32,"ps":0}],"sn":"SetUpAndArrangePosition","rt":$n[1].Void,"p":[$n[1].Int32]},{"a":2,"n":"SetupCollectorControllersConnect","t":8,"sn":"SetupCollectorControllersConnect","rt":$n[1].Void},{"a":2,"n":"SetupCollectorsAndMechanic","t":8,"sn":"SetupCollectorsAndMechanic","rt":$n[1].Void},{"a":2,"n":"SetupConnectedCollectors","t":8,"sn":"SetupConnectedCollectors","rt":$n[1].Void},{"a":2,"n":"CollectorContainer","t":4,"rt":$n[2].Transform,"sn":"CollectorContainer"},{"a":2,"n":"CollectorControllersColumns","t":4,"rt":$n[6].List$1(System.Collections.Generic.List$1(CollectorController)),"sn":"CollectorControllersColumns"},{"a":2,"n":"CollectorRotation","t":4,"rt":$n[2].Vector3,"sn":"CollectorRotation"},{"a":2,"n":"CurrentCollectors","t":4,"rt":$n[6].List$1(ColorPixelsCollectorObject),"sn":"CurrentCollectors"},{"a":2,"n":"CurrentLevelCollectorsConfig","t":4,"rt":LevelColorCollectorsConfig,"sn":"CurrentLevelCollectorsConfig"},{"at":[new UnityEngine.HeaderAttribute("Runtime Data")],"a":2,"n":"CurrentLocks","t":4,"rt":$n[6].List$1(LockObject),"sn":"CurrentLocks"},{"a":2,"n":"CurrentTotalCollectors","t":4,"rt":$n[1].Int32,"sn":"CurrentTotalCollectors","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.HeaderAttribute("Formation Settings")],"a":2,"n":"FormationCenter","t":4,"rt":$n[2].Transform,"sn":"FormationCenter"},{"at":[new UnityEngine.HeaderAttribute("Configuration")],"a":2,"n":"LevelSetup","t":4,"rt":LevelConfigSetup,"sn":"LevelSetup"},{"a":2,"n":"ObjectsInColumns","t":4,"rt":$n[6].List$1(CollectorColumn),"sn":"ObjectsInColumns"},{"a":2,"n":"PrefabSource","t":4,"rt":LevelMechanicObjectPrefabs,"sn":"PrefabSource"},{"a":2,"n":"SpaceBetweenCollectors","t":4,"rt":$n[1].Single,"sn":"SpaceBetweenCollectors","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"SpaceBetweenColumns","t":4,"rt":$n[1].Single,"sn":"SpaceBetweenColumns","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"_collectorIndexByID","t":4,"rt":$n[6].Dictionary$2(System.Int32,System.Int32),"sn":"_collectorIndexByID"},{"a":1,"n":"_collectorsByID","t":4,"rt":$n[6].Dictionary$2(System.Int32,ColorPixelsCollectorObject),"sn":"_collectorsByID"},{"at":[new UnityEngine.HeaderAttribute("Performance Optimization")],"a":1,"n":"_staticProcessedIndices","is":true,"t":4,"rt":$n[6].HashSet$1(System.Int32),"sn":"_staticProcessedIndices","ro":true},{"a":1,"n":"_staticQueue","is":true,"t":4,"rt":$n[6].Queue$1(ColorPixelsCollectorObject),"sn":"_staticQueue","ro":true},{"a":1,"n":"_tempCurrentGroup","t":4,"rt":$n[6].List$1(ColorPixelsCollectorObject),"sn":"_tempCurrentGroup"},{"a":1,"n":"_tempProgressedIndex","t":4,"rt":$n[6].List$1(System.Int32),"sn":"_tempProgressedIndex"},{"a":1,"n":"_tempQueue","is":true,"t":4,"rt":$n[6].Queue$1(CollectorController),"sn":"_tempQueue","ro":true},{"a":1,"n":"_tempVisited","is":true,"t":4,"rt":$n[6].HashSet$1(CollectorController),"sn":"_tempVisited","ro":true},{"a":2,"n":"collectorControllersByID","t":4,"rt":$n[6].Dictionary$2(System.Int32,CollectorController),"sn":"collectorControllersByID"}]}; }, $n);
    /*LevelCollectorsSystem end.*/

    /*PaintingGridEffects start.*/
    $m("PaintingGridEffects", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"PlayBlockDestroyedAudio","t":8,"sn":"PlayBlockDestroyedAudio","rt":$n[1].Void},{"a":2,"n":"BlockDestroyedClip","t":4,"rt":$n[2].AudioClip,"sn":"BlockDestroyedClip"},{"at":[new UnityEngine.HeaderAttribute("SFX")],"a":2,"n":"GridAudioSource","t":4,"rt":$n[2].AudioSource,"sn":"GridAudioSource"}]}; }, $n);
    /*PaintingGridEffects end.*/

    /*PaintingGridObject start.*/
    $m("PaintingGridObject", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AddPixelToColorsMapping","t":8,"pi":[{"n":"colorCode","pt":$n[1].String,"ps":0},{"n":"pixel","pt":PaintingPixel,"ps":1}],"sn":"AddPixelToColorsMapping","rt":$n[1].Void,"p":[$n[1].String,PaintingPixel]},{"a":1,"n":"AddPixelToColumnMapping","t":8,"pi":[{"n":"column","pt":$n[1].Int32,"ps":0},{"n":"pixel","pt":PaintingPixel,"ps":1}],"sn":"AddPixelToColumnMapping","rt":$n[1].Void,"p":[$n[1].Int32,PaintingPixel]},{"a":1,"n":"AddPixelToMappings","t":8,"pi":[{"n":"pixel","pt":PaintingPixel,"ps":0}],"sn":"AddPixelToMappings","rt":$n[1].Void,"p":[PaintingPixel]},{"a":1,"n":"AddPixelToRowMapping","t":8,"pi":[{"n":"row","pt":$n[1].Int32,"ps":0},{"n":"pixel","pt":PaintingPixel,"ps":1}],"sn":"AddPixelToRowMapping","rt":$n[1].Void,"p":[$n[1].Int32,PaintingPixel]},{"a":1,"n":"ApplyColorVariation","t":8,"pi":[{"n":"originalColor","pt":$n[2].Color,"ps":0},{"n":"variationAmount","pt":$n[1].Single,"ps":1}],"sn":"ApplyColorVariation","rt":$n[2].Color,"p":[$n[2].Color,$n[1].Single]},{"a":2,"n":"ApplyKeyConfigurations","t":8,"pi":[{"n":"paintingConfig","pt":PaintingConfig,"ps":0}],"sn":"ApplyKeyConfigurations","rt":$n[1].Void,"p":[PaintingConfig]},{"a":2,"n":"ApplyPaintingConfig","t":8,"pi":[{"n":"paintingConfig","pt":PaintingConfig,"ps":0}],"sn":"ApplyPaintingConfig","rt":$n[1].Void,"p":[PaintingConfig]},{"a":2,"n":"ApplyPipeConfigurations","t":8,"pi":[{"n":"paintingConfig","pt":PaintingConfig,"ps":0}],"sn":"ApplyPipeConfigurations","rt":$n[1].Void,"p":[PaintingConfig]},{"a":2,"n":"ApplyWallConfigurations","t":8,"pi":[{"n":"paintingConfig","pt":PaintingConfig,"ps":0}],"sn":"ApplyWallConfigurations","rt":$n[1].Void,"p":[PaintingConfig]},{"a":1,"n":"ApproximatelyEqual","is":true,"t":8,"pi":[{"n":"a","pt":$n[2].Color,"ps":0},{"n":"b","pt":$n[2].Color,"ps":1},{"n":"eps","dv":0.001,"o":true,"pt":$n[1].Single,"ps":2}],"sn":"ApproximatelyEqual","rt":$n[1].Boolean,"p":[$n[2].Color,$n[2].Color,$n[1].Single],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[1].Void},{"a":2,"n":"BatchSetColorByCode","t":8,"pi":[{"n":"colorCode","pt":$n[1].String,"ps":0},{"n":"newColor","pt":$n[2].Color,"ps":1},{"n":"includeHidden","dv":false,"o":true,"pt":$n[1].Boolean,"ps":2}],"sn":"BatchSetColorByCode","rt":$n[1].Int32,"p":[$n[1].String,$n[2].Color,$n[1].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BatchSetColorsByCodes","t":8,"pi":[{"n":"colorMap","pt":$n[6].Dictionary$2(System.String,UnityEngine.Color),"ps":0},{"n":"includeHidden","dv":false,"o":true,"pt":$n[1].Boolean,"ps":1}],"sn":"BatchSetColorsByCodes","rt":$n[1].Int32,"p":[$n[6].Dictionary$2(System.String,UnityEngine.Color),$n[1].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"CalculatePixelPosition","t":8,"pi":[{"n":"col","pt":$n[1].Int32,"ps":0},{"n":"row","pt":$n[1].Int32,"ps":1},{"n":"yOffset","dv":0.0,"o":true,"pt":$n[1].Single,"ps":2}],"sn":"CalculatePixelPosition","rt":$n[2].Vector3,"p":[$n[1].Int32,$n[1].Int32,$n[1].Single]},{"a":2,"n":"CalculatePixelPositionAbstract","t":8,"pi":[{"n":"col","pt":$n[1].Int32,"ps":0},{"n":"row","pt":$n[1].Int32,"ps":1},{"n":"yOffset","dv":0.0,"o":true,"pt":$n[1].Single,"ps":2}],"sn":"CalculatePixelPositionAbstract","rt":$n[2].Vector3,"p":[$n[1].Int32,$n[1].Int32,$n[1].Single]},{"a":2,"n":"ClearAllAdditionPixels","t":8,"sn":"ClearAllAdditionPixels","rt":$n[1].Void},{"a":2,"n":"ClearAllKeys","t":8,"sn":"ClearAllKeys","rt":$n[1].Void},{"a":2,"n":"ClearAllPipes","t":8,"sn":"ClearAllPipes","rt":$n[1].Void},{"a":2,"n":"ClearAllWalls","t":8,"sn":"ClearAllWalls","rt":$n[1].Void},{"a":1,"n":"ClearColorCodeMaterials","t":8,"sn":"ClearColorCodeMaterials","rt":$n[1].Void},{"a":2,"n":"ClearToWhite","t":8,"sn":"ClearToWhite","rt":$n[1].Void},{"a":2,"n":"CreateKeyObject","t":8,"pi":[{"n":"keySetup","pt":KeyObjectSetup,"ps":0}],"sn":"CreateKeyObject","rt":KeyObject,"p":[KeyObjectSetup]},{"a":2,"n":"CreateNewPaintingPixelAbstract","t":8,"pi":[{"n":"pixelConfig","pt":PaintingPixelConfig,"ps":0},{"n":"calculatePositon","dv":false,"o":true,"pt":$n[1].Boolean,"ps":1},{"n":"sharedMaterial","dv":null,"o":true,"pt":$n[2].Material,"ps":2}],"sn":"CreateNewPaintingPixelAbstract","rt":PaintingPixel,"p":[PaintingPixelConfig,$n[1].Boolean,$n[2].Material]},{"a":2,"n":"CreateNewPaintingPixelReal","t":8,"pi":[{"n":"pixelConfig","pt":PaintingPixelConfig,"ps":0},{"n":"calculatePositon","dv":false,"o":true,"pt":$n[1].Boolean,"ps":1}],"sn":"CreateNewPaintingPixelReal","rt":PaintingPixel,"p":[PaintingPixelConfig,$n[1].Boolean]},{"a":2,"n":"CreatePipeObject","t":8,"pi":[{"n":"pipeSetup","pt":PipeObjectSetup,"ps":0}],"sn":"CreatePipeObject","rt":PipeObject,"p":[PipeObjectSetup]},{"a":1,"n":"CreatePipePixel","t":8,"pi":[{"n":"stock","pt":PaintingPixel,"ps":0},{"n":"sharedMaterial","pt":$n[2].Material,"ps":1}],"sn":"CreatePipePixel","rt":PaintingPixel,"p":[PaintingPixel,$n[2].Material]},{"a":2,"n":"CreateWallObject","t":8,"pi":[{"n":"wallSetup","pt":WallObjectSetup,"ps":0}],"sn":"CreateWallObject","rt":WallObject,"p":[WallObjectSetup]},{"a":2,"n":"DestroyAllPixelsObjects","t":8,"sn":"DestroyAllPixelsObjects","rt":$n[1].Void},{"a":2,"n":"GenerateGrid","t":8,"pi":[{"n":"yoffset","dv":0.0,"o":true,"pt":$n[1].Single,"ps":0}],"sn":"GenerateGrid","rt":$n[1].Void,"p":[$n[1].Single]},{"a":1,"n":"GetCenterByBoundingBox","t":8,"pi":[{"n":"points","pt":$n[6].List$1(PaintingPixelComponent),"ps":0}],"sn":"GetCenterByBoundingBox$1","rt":$n[2].Vector3,"p":[$n[6].List$1(PaintingPixelComponent)]},{"a":1,"n":"GetCenterByBoundingBox","t":8,"pi":[{"n":"points","pt":$n[6].List$1(PaintingPixel),"ps":0}],"sn":"GetCenterByBoundingBox","rt":$n[2].Vector3,"p":[$n[6].List$1(PaintingPixel)]},{"a":2,"n":"GetLocalBorderPositions","t":8,"pi":[{"n":"regionPixels","pt":$n[6].List$1(PaintingPixel),"ps":0}],"sn":"GetLocalBorderPositions","rt":$n[6].List$1(UnityEngine.Vector2),"p":[$n[6].List$1(PaintingPixel)]},{"a":2,"n":"GetMaterialByColorCode","t":8,"pi":[{"n":"colorCode","pt":$n[1].String,"ps":0}],"sn":"GetMaterialByColorCode","rt":$n[2].Material,"p":[$n[1].String]},{"a":2,"n":"GetOriginalPixelAt","t":8,"pi":[{"n":"column","pt":$n[1].Int32,"ps":0},{"n":"row","pt":$n[1].Int32,"ps":1}],"sn":"GetOriginalPixelAt","rt":PaintingPixel,"p":[$n[1].Int32,$n[1].Int32]},{"a":2,"n":"GetPixelAtGridPosition","t":8,"pi":[{"n":"column","pt":$n[1].Int32,"ps":0},{"n":"row","pt":$n[1].Int32,"ps":1}],"sn":"GetPixelAtGridPosition","rt":PaintingPixel,"p":[$n[1].Int32,$n[1].Int32]},{"a":2,"n":"GetPixelBasedOnPosition","t":8,"pi":[{"n":"_pos","pt":$n[2].Vector3,"ps":0},{"n":"presicion","dv":0.5,"o":true,"pt":$n[1].Single,"ps":1}],"sn":"GetPixelBasedOnPosition","rt":PaintingPixelComponent,"p":[$n[2].Vector3,$n[1].Single]},{"a":2,"n":"GetPixelBasedOnPositionNewNeeded","t":8,"pi":[{"n":"_pos","pt":$n[2].Vector3,"ps":0},{"n":"paintingConfig","pt":PaintingConfig,"ps":1},{"n":"presicion","dv":0.25,"o":true,"pt":$n[1].Single,"ps":2},{"n":"addToAdditional","dv":false,"o":true,"pt":$n[1].Boolean,"ps":3}],"sn":"GetPixelBasedOnPositionNewNeeded","rt":PaintingPixelComponent,"p":[$n[2].Vector3,PaintingConfig,$n[1].Single,$n[1].Boolean]},{"a":2,"n":"GetPixelComponentNeighbor","t":8,"pi":[{"n":"_origin","pt":PaintingPixel,"ps":0}],"sn":"GetPixelComponentNeighbor","rt":$n[6].List$1(PaintingPixelComponent),"p":[PaintingPixel]},{"a":2,"n":"GetPixelsInColumn","t":8,"pi":[{"n":"column","pt":$n[1].Int32,"ps":0}],"sn":"GetPixelsInColumn","rt":$n[6].List$1(PaintingPixel),"p":[$n[1].Int32]},{"a":2,"n":"GetPixelsInRow","t":8,"pi":[{"n":"row","pt":$n[1].Int32,"ps":0}],"sn":"GetPixelsInRow","rt":$n[6].List$1(PaintingPixel),"p":[$n[1].Int32]},{"a":2,"n":"GetPredictedPixel","t":8,"pi":[{"n":"pos","pt":$n[2].Vector3,"ps":0}],"sn":"GetPredictedPixel","rt":$n[1].ValueTuple$3(System.Int32,System.Int32,UnityEngine.Vector3),"p":[$n[2].Vector3]},{"a":2,"n":"GetShapeSize","t":8,"pi":[{"n":"pixels","pt":$n[6].List$1(PaintingPixel),"ps":0}],"sn":"GetShapeSize","rt":$n[1].ValueTuple$2(System.Int32,System.Int32),"p":[$n[6].List$1(PaintingPixel)]},{"a":2,"n":"GetTotalPixels","t":8,"sn":"GetTotalPixels","rt":$n[1].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"InitializeGrid","t":8,"pi":[{"n":"size","pt":$n[2].Vector2,"ps":0},{"n":"arrangeSpace","pt":$n[1].Single,"ps":1},{"n":"prefab","pt":$n[2].GameObject,"ps":2},{"n":"blockScale","pt":$n[2].Vector3,"ps":3},{"n":"prefabSrc","pt":LevelMechanicObjectPrefabs,"ps":4},{"n":"pixelSharedMaterial","pt":$n[2].Material,"ps":5}],"sn":"InitializeGrid","rt":$n[1].Void,"p":[$n[2].Vector2,$n[1].Single,$n[2].GameObject,$n[2].Vector3,LevelMechanicObjectPrefabs,$n[2].Material]},{"a":2,"n":"InitializeLevel","t":8,"pi":[{"n":"paintingConfig","pt":PaintingConfig,"ps":0}],"sn":"InitializeLevel","rt":$n[1].Void,"p":[PaintingConfig]},{"a":1,"n":"InitializePixelMappings","t":8,"sn":"InitializePixelMappings","rt":$n[1].Void},{"a":2,"n":"IsPixelDestroyed","t":8,"pi":[{"n":"col","pt":$n[1].Int32,"ps":0},{"n":"row","pt":$n[1].Int32,"ps":1}],"sn":"IsPixelDestroyed","rt":$n[1].Boolean,"p":[$n[1].Int32,$n[1].Int32],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"OnAPipePixelDestroyed","t":8,"sn":"OnAPipePixelDestroyed","rt":$n[1].Void},{"a":2,"n":"OnAPixelDestroyed","t":8,"pi":[{"n":"_pixel","pt":PaintingPixel,"ps":0}],"sn":"OnAPixelDestroyed","rt":$n[1].Void,"p":[PaintingPixel]},{"a":1,"n":"OnBlockDissapear","t":8,"sn":"OnBlockDissapear","rt":$n[1].Void},{"a":2,"n":"OnCollectorsFormationChanged","t":8,"pi":[{"n":"_collectors","pt":CollectorColumnController,"ps":0}],"sn":"OnCollectorsFormationChanged","rt":$n[1].Void,"p":[CollectorColumnController]},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[1].Void},{"a":1,"n":"PixelExists","t":8,"pi":[{"n":"col","pt":$n[1].Int32,"ps":0},{"n":"row","pt":$n[1].Int32,"ps":1}],"sn":"PixelExists","rt":$n[1].Boolean,"p":[$n[1].Int32,$n[1].Int32],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"RegisterEvent","t":8,"sn":"RegisterEvent","rt":$n[1].Void},{"a":2,"n":"RemoveKeyObject","t":8,"pi":[{"n":"_key","pt":KeyObject,"ps":0}],"sn":"RemoveKeyObject","rt":$n[1].Void,"p":[KeyObject]},{"a":2,"n":"RemoveKeyObject","t":8,"pi":[{"n":"_key","pt":KeyObjectSetup,"ps":0}],"sn":"RemoveKeyObject$1","rt":$n[1].Void,"p":[KeyObjectSetup]},{"a":2,"n":"RemovePipeObject","t":8,"pi":[{"n":"_pipe","pt":PipeObject,"ps":0}],"sn":"RemovePipeObject","rt":$n[1].Void,"p":[PipeObject]},{"a":2,"n":"RemoveWallObject","t":8,"pi":[{"n":"_wall","pt":WallObject,"ps":0}],"sn":"RemoveWallObject","rt":$n[1].Void,"p":[WallObject]},{"a":2,"n":"RemoveWallObject","t":8,"pi":[{"n":"_wall","pt":WallObjectSetup,"ps":0}],"sn":"RemoveWallObject$1","rt":$n[1].Void,"p":[WallObjectSetup]},{"a":2,"n":"SelectOutlinePixels","t":8,"sn":"SelectOutlinePixels","rt":$n[6].List$1(PaintingPixel)},{"a":2,"n":"SelectOutlinePixelsWithColor","t":8,"pi":[{"n":"colorCode","pt":$n[1].String,"ps":0}],"sn":"SelectOutlinePixelsWithColor","rt":$n[6].List$1(PaintingPixel),"p":[$n[1].String]},{"a":2,"n":"SetUpMechanicDependencies","t":8,"sn":"SetUpMechanicDependencies","rt":$n[1].Void},{"a":2,"n":"SetupPixelObject","t":8,"pi":[{"n":"column","pt":$n[1].Int32,"ps":0},{"n":"row","pt":$n[1].Int32,"ps":1},{"n":"newColor","pt":$n[2].Color,"ps":2},{"n":"colorCode","pt":$n[1].String,"ps":3},{"n":"hidden","pt":$n[1].Boolean,"ps":4}],"sn":"SetupPixelObject","rt":$n[1].Void,"p":[$n[1].Int32,$n[1].Int32,$n[2].Color,$n[1].String,$n[1].Boolean]},{"a":1,"n":"ShakeNeighborPixelsOnDestroyed","t":8,"pi":[{"n":"_pixel","pt":PaintingPixel,"ps":0}],"sn":"ShakeNeighborPixelsOnDestroyed","rt":$n[1].Void,"p":[PaintingPixel]},{"a":2,"n":"ShootPixel","t":8,"pi":[{"n":"pixel","pt":PaintingPixel,"ps":0}],"sn":"ShootPixel","rt":$n[1].Void,"p":[PaintingPixel]},{"a":1,"n":"UnregisterEvent","t":8,"sn":"UnregisterEvent","rt":$n[1].Void},{"a":2,"n":"UpdateOutlinePixels","t":8,"sn":"UpdateOutlinePixels","rt":$n[1].Void},{"a":2,"n":"UpdatePixelDestroyedCount","t":8,"pi":[{"n":"_amount","pt":$n[1].Int32,"ps":0}],"sn":"UpdatePixelDestroyedCount","rt":$n[1].Void,"p":[$n[1].Int32]},{"a":2,"n":"UpdatePixelWorldPos","t":8,"sn":"UpdatePixelWorldPos","rt":$n[1].Void},{"a":1,"n":"ActivePalette","t":16,"rt":ColorPalleteData,"g":{"a":1,"n":"get_ActivePalette","t":8,"rt":ColorPalleteData,"fg":"ActivePalette"},"fn":"ActivePalette"},{"a":2,"n":"PixelByColor","t":16,"rt":$n[6].Dictionary$2(System.String,System.Collections.Generic.List$1(PaintingPixel)),"g":{"a":2,"n":"get_PixelByColor","t":8,"rt":$n[6].Dictionary$2(System.String,System.Collections.Generic.List$1(PaintingPixel)),"fg":"PixelByColor"},"fn":"PixelByColor"},{"a":2,"n":"PixelsByColumn","t":16,"rt":$n[6].Dictionary$2(System.Int32,System.Collections.Generic.List$1(PaintingPixel)),"g":{"a":2,"n":"get_PixelsByColumn","t":8,"rt":$n[6].Dictionary$2(System.Int32,System.Collections.Generic.List$1(PaintingPixel)),"fg":"PixelsByColumn"},"fn":"PixelsByColumn"},{"a":2,"n":"PixelsByRow","t":16,"rt":$n[6].Dictionary$2(System.Int32,System.Collections.Generic.List$1(PaintingPixel)),"g":{"a":2,"n":"get_PixelsByRow","t":8,"rt":$n[6].Dictionary$2(System.Int32,System.Collections.Generic.List$1(PaintingPixel)),"fg":"PixelsByRow"},"fn":"PixelsByRow"},{"at":[new UnityEngine.HeaderAttribute("Addition Pixels")],"a":2,"n":"AdditionPaintingPixels","t":4,"rt":$n[6].List$1(PaintingPixel),"sn":"AdditionPaintingPixels"},{"a":2,"n":"ColorPalette","t":4,"rt":ColorPalleteData,"sn":"ColorPalette"},{"a":2,"n":"CurrentLevelColor","t":4,"rt":$n[6].List$1(System.String),"sn":"CurrentLevelColor"},{"a":2,"n":"EffectHandler","t":4,"rt":PaintingGridEffects,"sn":"EffectHandler"},{"a":2,"n":"EffectOptions","t":4,"rt":InGameEffectOptions,"sn":"EffectOptions"},{"a":2,"n":"GridTransform","t":4,"rt":$n[2].Transform,"sn":"GridTransform"},{"at":[new UnityEngine.HeaderAttribute("Keys")],"a":2,"n":"KeyObjects","t":4,"rt":$n[6].List$1(KeyObject),"sn":"KeyObjects"},{"a":2,"n":"MaxColumn","t":4,"rt":$n[1].Int32,"sn":"MaxColumn","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"MaxRow","t":4,"rt":$n[1].Int32,"sn":"MaxRow","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"MinColumn","t":4,"rt":$n[1].Int32,"sn":"MinColumn","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SpaceAttribute.ctor()],"a":2,"n":"MinRow","t":4,"rt":$n[1].Int32,"sn":"MinRow","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.HeaderAttribute("Pipes")],"a":2,"n":"PipeObjects","t":4,"rt":$n[6].List$1(PipeObject),"sn":"PipeObjects"},{"at":[new UnityEngine.SpaceAttribute.ctor()],"a":2,"n":"PixelCount","t":4,"rt":$n[1].Int32,"sn":"PixelCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"PixelDestroyed","t":4,"rt":$n[1].Int32,"sn":"PixelDestroyed","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.HeaderAttribute("Default Prefabs")],"a":2,"n":"PrefabSource","t":4,"rt":LevelMechanicObjectPrefabs,"sn":"PrefabSource"},{"at":[new UnityEngine.HeaderAttribute("Walls")],"a":2,"n":"WallObjects","t":4,"rt":$n[6].List$1(WallObject),"sn":"WallObjects"},{"a":2,"n":"YOffset","t":4,"rt":$n[1].Single,"sn":"YOffset","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("Shared Material for Pixels")],"a":2,"n":"basePixelSharedMaterial","t":4,"rt":$n[2].Material,"sn":"basePixelSharedMaterial"},{"a":2,"n":"blockScale","t":4,"rt":$n[2].Vector3,"sn":"blockScale"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"colorCodeMaterials","t":4,"rt":$n[6].Dictionary$2(System.String,UnityEngine.Material),"sn":"colorCodeMaterials"},{"at":[new UnityEngine.HeaderAttribute("Color Variation"),new UnityEngine.RangeAttribute(0.0, 1.0)],"a":2,"n":"colorVariationAmount","t":4,"rt":$n[1].Single,"sn":"colorVariationAmount","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"currentOutlinePixels","t":4,"rt":$n[6].List$1(PaintingPixel),"sn":"currentOutlinePixels"},{"at":[new UnityEngine.HeaderAttribute("Grid Properties")],"a":2,"n":"gridSize","t":4,"rt":$n[2].Vector2,"sn":"gridSize"},{"at":[new UnityEngine.HeaderAttribute("Key Object Pixels")],"a":2,"n":"keyObjectsPixels","t":4,"rt":$n[6].List$1(PaintingPixel),"sn":"keyObjectsPixels"},{"a":2,"n":"paintingPixels","t":4,"rt":$n[6].List$1(PaintingPixel),"sn":"paintingPixels"},{"at":[new UnityEngine.HeaderAttribute("Pipe Object Pixels")],"a":2,"n":"pipeObjectsPixels","t":4,"rt":$n[6].List$1(PaintingPixel),"sn":"pipeObjectsPixels"},{"at":[new UnityEngine.HeaderAttribute("Grid Settings")],"a":2,"n":"pixelArrangeSpace","t":4,"rt":$n[1].Single,"sn":"pixelArrangeSpace","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"pixelByColors","t":4,"rt":$n[6].Dictionary$2(System.String,System.Collections.Generic.List$1(PaintingPixel)),"sn":"pixelByColors"},{"a":2,"n":"pixelPrefab","t":4,"rt":$n[2].GameObject,"sn":"pixelPrefab"},{"a":1,"n":"pixelsByColumn","t":4,"rt":$n[6].Dictionary$2(System.Int32,System.Collections.Generic.List$1(PaintingPixel)),"sn":"pixelsByColumn"},{"a":1,"n":"pixelsByRow","t":4,"rt":$n[6].Dictionary$2(System.Int32,System.Collections.Generic.List$1(PaintingPixel)),"sn":"pixelsByRow"},{"at":[new UnityEngine.HeaderAttribute("Wall Object Pixels")],"a":2,"n":"wallObjectsPixels","t":4,"rt":$n[6].List$1(PaintingPixel),"sn":"wallObjectsPixels"}]}; }, $n);
    /*PaintingGridObject end.*/

    /*PipeObject start.*/
    $m("PipeObject", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ApplyOrientationRotation","t":8,"sn":"ApplyOrientationRotation","rt":$n[1].Void},{"a":2,"n":"ApplyPosition","t":8,"sn":"ApplyPosition","rt":$n[1].Void},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[1].Void},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"pipePixels","pt":$n[6].List$1(PaintingPixel),"ps":0},{"n":"colorCode","pt":$n[1].String,"ps":1},{"n":"hearts","pt":$n[1].Int32,"ps":2},{"n":"isHorizontal","dv":false,"o":true,"pt":$n[1].Boolean,"ps":3}],"sn":"Initialize","rt":$n[1].Void,"p":[$n[6].List$1(PaintingPixel),$n[1].String,$n[1].Int32,$n[1].Boolean]},{"a":2,"n":"OnAPixelDestroyed","t":8,"sn":"OnAPixelDestroyed","rt":$n[1].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[1].Void},{"a":2,"n":"SelfDestroy","t":8,"sn":"SelfDestroy","rt":$n[1].Void},{"a":2,"n":"SelfDestroyGameobject","t":8,"sn":"SelfDestroyGameobject","rt":$n[1].Void},{"a":2,"n":"ColorCode","t":4,"rt":$n[1].String,"sn":"ColorCode"},{"a":2,"n":"Destroyed","t":4,"rt":$n[1].Boolean,"sn":"Destroyed$1","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"HeartLoss","t":4,"rt":$n[1].Int32,"sn":"HeartLoss","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"HeartText","t":4,"rt":$n[4].TMP_Text,"sn":"HeartText"},{"at":[new UnityEngine.HeaderAttribute("Pipe Properties")],"a":2,"n":"Hearts","t":4,"rt":$n[1].Int32,"sn":"Hearts","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"IsHorizontal","t":4,"rt":$n[1].Boolean,"sn":"IsHorizontal","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("Pipe Structure")],"a":2,"n":"PaintingPixelsCovered","t":4,"rt":$n[6].List$1(PaintingPixel),"sn":"PaintingPixelsCovered"},{"a":2,"n":"PipeBodyDefaultScale","t":4,"rt":$n[2].Vector3,"sn":"PipeBodyDefaultScale"},{"a":2,"n":"PipeBodyTransform","t":4,"rt":$n[2].Transform,"sn":"PipeBodyTransform"},{"at":[new UnityEngine.HeaderAttribute("Default scale values")],"a":2,"n":"PipeHeadDefaultScale","t":4,"rt":$n[2].Vector3,"sn":"PipeHeadDefaultScale"},{"at":[new UnityEngine.HeaderAttribute("OBJECT(s)")],"a":2,"n":"PipeTransform","t":4,"rt":$n[2].Transform,"sn":"PipeTransform"},{"a":2,"n":"PixelDestroyed","t":4,"rt":$n[1].Int32,"sn":"PixelDestroyed","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"RemainingHearts","t":4,"rt":$n[1].Int32,"sn":"RemainingHearts","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"ScaleDownValuePerHeart","t":4,"rt":$n[1].Single,"sn":"ScaleDownValuePerHeart","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"VisualHandler","t":4,"rt":PipePartVisualHandle,"sn":"VisualHandler"},{"a":2,"n":"WorldPos","t":4,"rt":$n[2].Vector3,"sn":"WorldPos"},{"a":1,"n":"heartLossFromLastPixelDestroyed","t":4,"rt":$n[1].Single,"sn":"heartLossFromLastPixelDestroyed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"heartPerPixel","t":4,"rt":$n[1].Single,"sn":"heartPerPixel","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"scaleOriginalZ","t":4,"rt":$n[1].Single,"sn":"scaleOriginalZ","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*PipeObject end.*/

    /*PipePartVisualHandle start.*/
    $m("PipePartVisualHandle", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[1].Void},{"a":1,"n":"CacheFlashTween","t":8,"sn":"CacheFlashTween","rt":$n[1].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[1].Void},{"a":2,"n":"PlayFlash","t":8,"sn":"PlayFlash","rt":$n[1].Void},{"a":1,"n":"SetBrightness","t":8,"pi":[{"n":"_brightness","pt":$n[1].Single,"ps":0}],"sn":"SetBrightness","rt":$n[1].Void,"p":[$n[1].Single]},{"a":2,"n":"SetColor","t":8,"pi":[{"n":"color","pt":$n[2].Color,"ps":0}],"sn":"SetColor","rt":$n[1].Void,"p":[$n[2].Color]},{"a":2,"n":"StopFlash","t":8,"sn":"StopFlash","rt":$n[1].Void},{"at":[new UnityEngine.HeaderAttribute("BLINKS")],"a":2,"n":"BrightnessRange","t":4,"rt":$n[2].Vector2,"sn":"BrightnessRange"},{"a":2,"n":"FlashDuration","t":4,"rt":$n[1].Single,"sn":"FlashDuration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"PipeScaleBody","t":4,"rt":$n[2].Renderer,"sn":"PipeScaleBody"},{"a":2,"n":"TextureScaler","t":4,"rt":AutoTextureScale,"sn":"TextureScaler"},{"a":1,"n":"cachedFlashTween","t":4,"rt":$n[5].Tween,"sn":"cachedFlashTween"},{"a":1,"n":"currentBrightness","t":4,"rt":$n[1].Single,"sn":"currentBrightness","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"pipeRenderers","t":4,"rt":$n[6].List$1(UnityEngine.Renderer),"sn":"pipeRenderers"}]}; }, $n);
    /*PipePartVisualHandle end.*/

    /*WallObject start.*/
    $m("WallObject", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ApplyPosition","t":8,"sn":"ApplyPosition","rt":$n[1].Void},{"a":1,"n":"AssignPaletteSharedMaterial","t":8,"sn":"AssignPaletteSharedMaterial","rt":$n[1].Void},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"pipePixels","pt":$n[6].List$1(PaintingPixel),"ps":0},{"n":"heart","pt":$n[1].Int32,"ps":1},{"n":"color","pt":$n[2].Color,"ps":2},{"n":"colorCode","pt":$n[1].String,"ps":3}],"sn":"Initialize","rt":$n[1].Void,"p":[$n[6].List$1(PaintingPixel),$n[1].Int32,$n[2].Color,$n[1].String]},{"a":2,"n":"OnAPixelDestroyed","t":8,"sn":"OnAPixelDestroyed","rt":$n[1].Void},{"a":2,"n":"OnDestroyed","t":8,"sn":"OnDestroyed","rt":$n[1].Void},{"a":2,"n":"RefreshPaletteMaterial","t":8,"sn":"RefreshPaletteMaterial","rt":$n[1].Void},{"a":2,"n":"SelfDestroy","t":8,"sn":"SelfDestroy","rt":$n[1].Void},{"a":2,"n":"SelfDestroyGameObject","t":8,"sn":"SelfDestroyGameObject","rt":$n[1].Void},{"a":2,"n":"ColorCode","t":4,"rt":$n[1].String,"sn":"ColorCode"},{"a":2,"n":"Destroyed","t":4,"rt":$n[1].Boolean,"sn":"Destroyed$1","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("STAT(s)")],"a":2,"n":"Hearts","t":4,"rt":$n[1].Int32,"sn":"Hearts","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"HeartsLoss","t":4,"rt":$n[1].Int32,"sn":"HeartsLoss","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"HeartsText","t":4,"rt":$n[4].TMP_Text,"sn":"HeartsText"},{"a":2,"n":"PaintingPixelsCovered","t":4,"rt":$n[6].List$1(PaintingPixel),"sn":"PaintingPixelsCovered"},{"a":2,"n":"RemainingHearts","t":4,"rt":$n[1].Int32,"sn":"RemainingHearts","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.HeaderAttribute("VISUAL")],"a":2,"n":"WallRenderer","t":4,"rt":$n[2].Renderer,"sn":"WallRenderer"},{"at":[new UnityEngine.HeaderAttribute("Wall Structure")],"a":2,"n":"WallTransform","t":4,"rt":$n[2].Transform,"sn":"WallTransform"},{"a":2,"n":"WorldPos","t":4,"rt":$n[2].Vector3,"sn":"WorldPos"}]}; }, $n);
    /*WallObject end.*/

    /*PlayNowButtonAnim start.*/
    $m("PlayNowButtonAnim", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"GotoStore","t":8,"sn":"GotoStore","rt":$n[1].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[1].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[1].Void},{"a":1,"n":"StartScalingAnimation","t":8,"sn":"StartScalingAnimation","rt":$n[1].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_autoStart","t":4,"rt":$n[1].Boolean,"sn":"m_autoStart","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"maxScale","t":4,"rt":$n[2].Vector3,"sn":"maxScale"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"minScale","t":4,"rt":$n[2].Vector3,"sn":"minScale"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"playerNowButton","t":4,"rt":$n[3].Button,"sn":"playerNowButton"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"scaleDuration","t":4,"rt":$n[1].Single,"sn":"scaleDuration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*PlayNowButtonAnim end.*/

    /*BigBlockObjectConfigSetup start.*/
    $m("BigBlockObjectConfigSetup", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddWallSetup","t":8,"pi":[{"n":"wallSetup","pt":WallObjectSetup,"ps":0}],"sn":"AddWallSetup","rt":$n[1].Void,"p":[WallObjectSetup]},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[1].Void},{"a":2,"n":"ClearWallSetups","t":8,"sn":"ClearWallSetups","rt":$n[1].Void},{"a":2,"n":"CreateBigBlock","t":8,"sn":"CreateBigBlock","rt":$n[1].Void},{"a":2,"n":"CreateBigBlock","t":8,"pi":[{"n":"_startPixel","pt":PaintingPixel,"ps":0},{"n":"_endPixel","pt":PaintingPixel,"ps":1},{"n":"colorCode","pt":$n[1].String,"ps":2},{"n":"hearts","pt":$n[1].Int32,"ps":3}],"sn":"CreateBigBlock$1","rt":WallObjectSetup,"p":[PaintingPixel,PaintingPixel,$n[1].String,$n[1].Int32]},{"a":1,"n":"GetCenterByBoundingBox","t":8,"pi":[{"n":"points","pt":$n[6].List$1(PaintingPixelComponent),"ps":0}],"sn":"GetCenterByBoundingBox","rt":$n[2].Vector3,"p":[$n[6].List$1(PaintingPixelComponent)]},{"a":2,"n":"GetPixelsBetweenRectangle","t":8,"pi":[{"n":"a","pt":PaintingPixel,"ps":0},{"n":"b","pt":PaintingPixel,"ps":1}],"sn":"GetPixelsBetweenRectangle","rt":$n[6].List$1(PaintingPixel),"p":[PaintingPixel,PaintingPixel]},{"a":2,"n":"ImportWallsToPaintingConfig","t":8,"pi":[{"n":"paintingConfig","pt":PaintingConfig,"ps":0}],"sn":"ImportWallsToPaintingConfig","rt":$n[1].Void,"p":[PaintingConfig]},{"a":2,"n":"IsValidWallOrientation","t":8,"pi":[{"n":"_wallPixels","pt":$n[6].List$1(PaintingPixelComponent),"ps":0}],"sn":"IsValidWallOrientation$1","rt":$n[1].Boolean,"p":[$n[6].List$1(PaintingPixelComponent)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsValidWallOrientation","t":8,"pi":[{"n":"_wallPixels","pt":$n[6].List$1(PaintingPixel),"ps":0}],"sn":"IsValidWallOrientation","rt":$n[1].Boolean,"p":[$n[6].List$1(PaintingPixel)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Reload","t":8,"sn":"Reload","rt":$n[1].Void},{"a":2,"n":"RemoveWallObjectAndItConfig","t":8,"pi":[{"n":"_object","pt":WallObject,"ps":0},{"n":"save","pt":$n[1].Boolean,"ps":1}],"sn":"RemoveWallObjectAndItConfig","rt":$n[1].Void,"p":[WallObject,$n[1].Boolean]},{"a":2,"n":"RemoveWallObjectAndItConfig","t":8,"pi":[{"n":"_wallSetup","pt":WallObjectSetup,"ps":0},{"n":"save","pt":$n[1].Boolean,"ps":1}],"sn":"RemoveWallObjectAndItConfig$1","rt":$n[1].Void,"p":[WallObjectSetup,$n[1].Boolean]},{"a":2,"n":"RemoveWallSetup","t":8,"pi":[{"n":"wallSetup","pt":WallObjectSetup,"ps":0}],"sn":"RemoveWallSetup","rt":$n[1].Void,"p":[WallObjectSetup]},{"a":2,"n":"Save","t":8,"sn":"Save","rt":$n[1].Void},{"a":1,"n":"SetupNewWallInScene","t":8,"pi":[{"n":"setup","pt":WallObjectSetup,"ps":0}],"sn":"SetupNewWallInScene","rt":WallObject,"p":[WallObjectSetup]},{"at":[new UnityEngine.HeaderAttribute("Wall Properties")],"a":2,"n":"ColorCode","t":4,"rt":$n[1].String,"sn":"ColorCode"},{"at":[new UnityEngine.HeaderAttribute("Wall Configuration")],"a":2,"n":"CurrentLevelWallObjectSetups","t":4,"rt":$n[6].List$1(WallObjectSetup),"sn":"CurrentLevelWallObjectSetups"},{"a":2,"n":"PaintingSetupModule","t":4,"rt":PaintingConfigSetup,"sn":"PaintingSetupModule"},{"a":2,"n":"WallHearts","t":4,"rt":$n[1].Int32,"sn":"WallHearts","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.HeaderAttribute("Wall Setup")],"a":2,"n":"WallPixelComponents","t":4,"rt":$n[6].List$1(PaintingPixelComponent),"sn":"WallPixelComponents"},{"at":[new UnityEngine.HeaderAttribute("Wall Positioning")],"a":2,"n":"WallSpaceFromGrid","t":4,"rt":$n[1].Int32,"sn":"WallSpaceFromGrid","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"wallObjectSetups","t":4,"rt":$n[6].List$1(WallObjectSetup),"sn":"wallObjectSetups"}]}; }, $n);
    /*BigBlockObjectConfigSetup end.*/

    /*CachedSplineTransformPath start.*/
    $m("CachedSplineTransformPath", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "CachedSplineTransformPath", menuName: "Curvy/Cached Spline Transform Path", order: 2
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"CalculateCumulativeDistances","t":8,"sn":"CalculateCumulativeDistances","rt":$n[1].Void},{"a":2,"n":"CalculateTotalDistance","t":8,"sn":"CalculateTotalDistance","rt":$n[1].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"ConvertDistanceToTf","t":8,"pi":[{"n":"distance","pt":$n[1].Single,"ps":0}],"sn":"ConvertDistanceToTf","rt":$n[1].Single,"p":[$n[1].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"ConvertTfToDistance","t":8,"pi":[{"n":"tf","pt":$n[1].Single,"ps":0}],"sn":"ConvertTfToDistance","rt":$n[1].Single,"p":[$n[1].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GetPositionAtDistance","t":8,"pi":[{"n":"distance","pt":$n[1].Single,"ps":0}],"sn":"GetPositionAtDistance","rt":$n[2].Vector3,"p":[$n[1].Single]},{"a":2,"n":"GetPositionAtTF","t":8,"pi":[{"n":"tf","pt":$n[1].Single,"ps":0}],"sn":"GetPositionAtTF","rt":$n[2].Vector3,"p":[$n[1].Single]},{"a":2,"n":"GetTangentAtDistance","t":8,"pi":[{"n":"distance","pt":$n[1].Single,"ps":0}],"sn":"GetTangentAtDistance","rt":$n[2].Vector3,"p":[$n[1].Single]},{"a":2,"n":"GetTangentAtTF","t":8,"pi":[{"n":"tf","pt":$n[1].Single,"ps":0}],"sn":"GetTangentAtTF","rt":$n[2].Vector3,"p":[$n[1].Single]},{"a":1,"n":"GetTransformForwardVector","t":8,"pi":[{"n":"t","pt":$n[2].Transform,"ps":0}],"sn":"GetTransformForwardVector","rt":$n[2].Vector3,"p":[$n[2].Transform]},{"a":1,"n":"GetTransformPosition","t":8,"pi":[{"n":"t","pt":$n[2].Transform,"ps":0}],"sn":"GetTransformPosition","rt":$n[2].Vector3,"p":[$n[2].Transform]},{"a":1,"n":"GetTransformUpVector","t":8,"pi":[{"n":"t","pt":$n[2].Transform,"ps":0}],"sn":"GetTransformUpVector","rt":$n[2].Vector3,"p":[$n[2].Transform]},{"a":1,"n":"GetTrueTfFromNormalizedTf","t":8,"pi":[{"n":"normalizedTf","pt":$n[1].Single,"ps":0}],"sn":"GetTrueTfFromNormalizedTf","rt":$n[1].Single,"p":[$n[1].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GetUpVectorAtDistance","t":8,"pi":[{"n":"distance","pt":$n[1].Single,"ps":0}],"sn":"GetUpVectorAtDistance","rt":$n[2].Vector3,"p":[$n[1].Single]},{"a":2,"n":"GetUpVectorAtTF","t":8,"pi":[{"n":"tf","pt":$n[1].Single,"ps":0}],"sn":"GetUpVectorAtTF","rt":$n[2].Vector3,"p":[$n[1].Single]},{"a":2,"n":"IsValid","t":8,"sn":"IsValid","rt":$n[1].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"MarkDistanceCacheDirty","t":8,"sn":"MarkDistanceCacheDirty","rt":$n[1].Void},{"a":1,"n":"cumulativeDistances","t":4,"rt":$n[6].List$1(System.Single),"sn":"cumulativeDistances"},{"a":1,"n":"isDistanceCacheDirty","t":4,"rt":$n[1].Boolean,"sn":"isDistanceCacheDirty","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("Coordinate Space")],"a":2,"n":"isLocalSpace","t":4,"rt":$n[1].Boolean,"sn":"isLocalSpace","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("Spline Path Transforms"),new UnityEngine.TooltipAttribute("List of transforms that define the cached spline path. These can be in world or local space.")],"a":2,"n":"pathTransforms","t":4,"rt":$n[6].List$1(UnityEngine.Transform),"sn":"pathTransforms"},{"a":2,"n":"resolution","t":4,"rt":$n[1].Single,"sn":"resolution","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"sampleCount","t":4,"rt":$n[1].Int32,"sn":"sampleCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"spaceReference","t":4,"rt":$n[2].Transform,"sn":"spaceReference"},{"at":[new UnityEngine.HeaderAttribute("Spline Metadata")],"a":2,"n":"totalDistance","t":4,"rt":$n[1].Single,"sn":"totalDistance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"version","t":4,"rt":$n[1].String,"sn":"version"}]}; }, $n);
    /*CachedSplineTransformPath end.*/

    /*GridGenerator start.*/
    $m("GridGenerator", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ClearGrid","t":8,"sn":"ClearGrid","rt":$n[1].Void},{"a":2,"n":"ContextClearGrid","t":8,"sn":"ContextClearGrid","rt":$n[1].Void},{"a":2,"n":"ContextGenerateGrid","t":8,"sn":"ContextGenerateGrid","rt":$n[1].Void},{"a":2,"n":"GenerateGrid","t":8,"sn":"GenerateGrid","rt":$n[1].Void},{"a":2,"n":"GetTotalPixels","t":8,"sn":"GetTotalPixels","rt":$n[1].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"Reset","t":8,"sn":"Reset","rt":$n[1].Void},{"at":[new UnityEngine.SpaceAttribute.ctor()],"a":2,"n":"AlreadyHave","t":4,"rt":$n[6].List$1(PaintingGridObject),"sn":"AlreadyHave"},{"a":2,"n":"BlockScale","t":4,"rt":$n[2].Vector3,"sn":"BlockScale"},{"a":2,"n":"PrefabSource","t":4,"rt":LevelMechanicObjectPrefabs,"sn":"PrefabSource"},{"a":2,"n":"YOffset","t":4,"rt":$n[1].Single,"sn":"YOffset","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("Grid Settings")],"a":2,"n":"gridSize","t":4,"rt":$n[2].Vector2,"sn":"gridSize"},{"at":[new UnityEngine.HeaderAttribute("Generated Grid")],"a":2,"n":"paintingGridObject","t":4,"rt":PaintingGridObject,"sn":"paintingGridObject"},{"a":2,"n":"pixelArrangeSpace","t":4,"rt":$n[1].Single,"sn":"pixelArrangeSpace","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"pixelMaterial","t":4,"rt":$n[2].Material,"sn":"pixelMaterial"},{"a":2,"n":"pixelsParent","t":4,"rt":$n[2].Transform,"sn":"pixelsParent"}]}; }, $n);
    /*GridGenerator end.*/

    /*KeyObjectConfigSetup start.*/
    $m("KeyObjectConfigSetup", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddKeySetup","t":8,"pi":[{"n":"keySetup","pt":KeyObjectSetup,"ps":0}],"sn":"AddKeySetup","rt":$n[1].Void,"p":[KeyObjectSetup]},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[1].Void},{"a":2,"n":"ClearAllKeySetups","t":8,"sn":"ClearAllKeySetups","rt":$n[1].Void},{"a":2,"n":"ClearKeySetups","t":8,"sn":"ClearKeySetups","rt":$n[1].Void},{"a":2,"n":"CreateKey","t":8,"sn":"CreateKey$1","rt":$n[1].Void},{"a":2,"n":"CreateKey","t":8,"pi":[{"n":"_keyPixels","pt":$n[6].List$1(PaintingPixelComponent),"ps":0}],"sn":"CreateKey$2","rt":$n[1].Void,"p":[$n[6].List$1(PaintingPixelComponent)]},{"a":2,"n":"CreateKey","t":8,"pi":[{"n":"_startPixel","pt":PaintingPixel,"ps":0},{"n":"_endPixel","pt":PaintingPixel,"ps":1}],"sn":"CreateKey","rt":KeyObjectSetup,"p":[PaintingPixel,PaintingPixel]},{"a":1,"n":"GetCenterByBoundingBox","t":8,"pi":[{"n":"points","pt":$n[6].List$1(PaintingPixelComponent),"ps":0}],"sn":"GetCenterByBoundingBox","rt":$n[2].Vector3,"p":[$n[6].List$1(PaintingPixelComponent)]},{"a":2,"n":"GetPixelsBetweenRectangle","t":8,"pi":[{"n":"a","pt":PaintingPixel,"ps":0},{"n":"b","pt":PaintingPixel,"ps":1}],"sn":"GetPixelsBetweenRectangle","rt":$n[6].List$1(PaintingPixel),"p":[PaintingPixel,PaintingPixel]},{"a":2,"n":"IsValidKeyOrientation","t":8,"pi":[{"n":"_keyPixels","pt":$n[6].List$1(PaintingPixelComponent),"ps":0}],"sn":"IsValidKeyOrientation$1","rt":$n[1].Boolean,"p":[$n[6].List$1(PaintingPixelComponent)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsValidKeyOrientation","t":8,"pi":[{"n":"_wallPixels","pt":$n[6].List$1(PaintingPixel),"ps":0}],"sn":"IsValidKeyOrientation","rt":$n[1].Boolean,"p":[$n[6].List$1(PaintingPixel)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"RemoveKeyObjectAndItConfig","t":8,"pi":[{"n":"_keyObject","pt":KeyObject,"ps":0},{"n":"save","pt":$n[1].Boolean,"ps":1}],"sn":"RemoveKeyObjectAndItConfig","rt":$n[1].Void,"p":[KeyObject,$n[1].Boolean]},{"a":2,"n":"RemoveKeyObjectAndItConfig","t":8,"pi":[{"n":"_keySetup","pt":KeyObjectSetup,"ps":0},{"n":"save","pt":$n[1].Boolean,"ps":1}],"sn":"RemoveKeyObjectAndItConfig$1","rt":$n[1].Void,"p":[KeyObjectSetup,$n[1].Boolean]},{"a":2,"n":"RemoveKeySetup","t":8,"pi":[{"n":"keySetup","pt":KeyObjectSetup,"ps":0}],"sn":"RemoveKeySetup","rt":$n[1].Void,"p":[KeyObjectSetup]},{"a":1,"n":"SetupNewKeyInScene","t":8,"pi":[{"n":"setup","pt":KeyObjectSetup,"ps":0}],"sn":"SetupNewKeyInScene","rt":KeyObject,"p":[KeyObjectSetup]},{"at":[new UnityEngine.HeaderAttribute("Key Configuration")],"a":2,"n":"CurrentLevelKeyObjectSetups","t":4,"rt":$n[6].List$1(KeyObjectSetup),"sn":"CurrentLevelKeyObjectSetups"},{"at":[new UnityEngine.HeaderAttribute("Pipe Setup")],"a":2,"n":"KeyPixelComponents","t":4,"rt":$n[6].List$1(PaintingPixelComponent),"sn":"KeyPixelComponents"},{"a":2,"n":"PaintingSetupModule","t":4,"rt":PaintingConfigSetup,"sn":"PaintingSetupModule"},{"a":2,"n":"keyObjectSetups","t":4,"rt":$n[6].List$1(KeyObjectSetup),"sn":"keyObjectSetups"}]}; }, $n);
    /*KeyObjectConfigSetup end.*/

    /*LevelCollectorsConfigSetup start.*/
    $m("LevelCollectorsConfigSetup", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"BakeCollectorsPositionInTool","t":8,"sn":"BakeCollectorsPositionInTool","rt":$n[1].Void},{"a":1,"n":"CleanupZeroCollectors","t":8,"pi":[{"n":"list","pt":$n[6].List$1(SingleColorCollectorConfig),"ps":0}],"sn":"CleanupZeroCollectors","rt":$n[1].Void,"p":[$n[6].List$1(SingleColorCollectorConfig)]},{"a":2,"n":"CountGunnersAsSet","t":8,"sn":"CountGunnersAsSet","rt":$n[1].Void},{"a":1,"n":"Diff","t":8,"pi":[{"n":"oldDict","pt":$n[6].Dictionary$2(System.String,System.Int32),"ps":0},{"n":"newDict","pt":$n[6].Dictionary$2(System.String,System.Int32),"ps":1}],"sn":"Diff","rt":$n[6].Dictionary$2(System.String,System.Int32),"p":[$n[6].Dictionary$2(System.String,System.Int32),$n[6].Dictionary$2(System.String,System.Int32)]},{"a":2,"n":"EnsureBidirectionalConnections","t":8,"pi":[{"n":"save","dv":true,"o":true,"pt":$n[1].Boolean,"ps":0}],"sn":"EnsureBidirectionalConnections","rt":$n[1].Void,"p":[$n[1].Boolean]},{"a":1,"n":"ExtractOutlinesByDepth","t":8,"pi":[{"n":"allPixels","pt":$n[6].List$1(PaintingPixel),"ps":0},{"n":"paintingSize","pt":$n[2].Vector2,"ps":1}],"sn":"ExtractOutlinesByDepth","rt":$n[6].List$1(System.Collections.Generic.List$1(PaintingPixel)),"p":[$n[6].List$1(PaintingPixel),$n[2].Vector2]},{"a":2,"n":"ExtractOutlinesByDepth_Custom","t":8,"pi":[{"n":"allPixels","pt":$n[6].List$1(PaintingPixel),"ps":0}],"sn":"ExtractOutlinesByDepth_Custom","rt":$n[6].List$1(System.Collections.Generic.List$1(PaintingPixel)),"p":[$n[6].List$1(PaintingPixel)]},{"a":1,"n":"FindNonHiddenPixelsAt","t":8,"pi":[{"n":"pixels","pt":$n[6].List$1(PaintingPixel),"ps":0},{"n":"column","pt":$n[1].Int32,"ps":1},{"n":"row","pt":$n[1].Int32,"ps":2}],"sn":"FindNonHiddenPixelsAt","rt":$n[6].List$1(PaintingPixel),"p":[$n[6].List$1(PaintingPixel),$n[1].Int32,$n[1].Int32]},{"a":2,"n":"GenerateCollectorsFromPaintingConfig","t":8,"sn":"GenerateCollectorsFromPaintingConfig","rt":$n[1].Void},{"a":2,"n":"ImportCollectorsFromScene","t":8,"sn":"ImportCollectorsFromScene","rt":$n[1].Void},{"a":2,"n":"InsertAmongOtherCollector","t":8,"pi":[{"n":"itemToInsert","pt":CollectorMachanicObjectBase,"ps":0},{"n":"originItem","pt":CollectorMachanicObjectBase,"ps":1},{"n":"higher","pt":$n[1].Boolean,"ps":2}],"sn":"InsertAmongOtherCollector","rt":$n[1].Void,"p":[CollectorMachanicObjectBase,CollectorMachanicObjectBase,$n[1].Boolean]},{"a":2,"n":"InsertNewToOtherCollector","t":8,"pi":[{"n":"itemToInsert","pt":CollectorMachanicObjectBase,"ps":0},{"n":"originItem","pt":CollectorMachanicObjectBase,"ps":1},{"n":"higher","pt":$n[1].Boolean,"ps":2}],"sn":"InsertNewToOtherCollector","rt":$n[1].Void,"p":[CollectorMachanicObjectBase,CollectorMachanicObjectBase,$n[1].Boolean]},{"a":2,"n":"LoadConfigAsset","t":8,"pi":[{"n":"sourceConfig","pt":LevelColorCollectorsConfig,"ps":0}],"sn":"LoadConfigAsset","rt":$n[1].Void,"p":[LevelColorCollectorsConfig]},{"a":2,"n":"ReApplyCollectorsPosition","t":8,"sn":"ReApplyCollectorsPosition","rt":$n[1].Void},{"a":2,"n":"ReArrangeCollectorBullets","t":8,"pi":[{"n":"_collectors","pt":$n[6].List$1(SingleColorCollectorConfig),"ps":0},{"n":"maxBullets","dv":20,"o":true,"pt":$n[1].Int32,"ps":1}],"sn":"ReArrangeCollectorBullets","rt":$n[6].List$1(SingleColorCollectorConfig),"p":[$n[6].List$1(SingleColorCollectorConfig),$n[1].Int32]},{"a":2,"n":"ReCountCollectors","t":8,"sn":"ReCountCollectors","rt":$n[1].Void},{"a":2,"n":"Save","t":8,"sn":"Save","rt":$n[1].Void},{"a":2,"n":"SelectOutlinePixelsFromList","t":8,"pi":[{"n":"pixels","pt":$n[6].List$1(PaintingPixel),"ps":0}],"sn":"SelectOutlinePixelsFromList","rt":$n[6].List$1(PaintingPixel),"p":[$n[6].List$1(PaintingPixel)]},{"a":2,"n":"SplitACollector","t":8,"pi":[{"n":"originItem","pt":ColorPixelsCollectorObject,"ps":0}],"sn":"SplitACollector","rt":$n[1].Void,"p":[ColorPixelsCollectorObject]},{"a":2,"n":"StartUpTool","t":8,"sn":"StartUpTool","rt":$n[1].Void},{"a":1,"n":"SumColorBullets","t":8,"pi":[{"n":"collectors","pt":$n[6].List$1(SingleColorCollectorConfig),"ps":0}],"sn":"SumColorBullets","rt":$n[6].Dictionary$2(System.String,System.Int32),"p":[$n[6].List$1(SingleColorCollectorConfig)]},{"a":2,"n":"SwapCollectors","t":8,"pi":[{"n":"a","pt":CollectorMachanicObjectBase,"ps":0},{"n":"b","pt":CollectorMachanicObjectBase,"ps":1}],"sn":"SwapCollectors","rt":$n[1].Void,"p":[CollectorMachanicObjectBase,CollectorMachanicObjectBase]},{"a":2,"n":"UpdateCollectorsFromPaintingConfig","t":8,"sn":"UpdateCollectorsFromPaintingConfig","rt":$n[1].Void},{"a":2,"n":"BGColor","t":4,"rt":$n[2].Color,"sn":"BGColor"},{"a":2,"n":"CollectorObjectLayerMask","t":4,"rt":$n[2].LayerMask,"sn":"CollectorObjectLayerMask"},{"a":2,"n":"CollisionRadius","t":4,"rt":$n[1].Single,"sn":"CollisionRadius","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"CombineModule","t":4,"rt":CombinesCollector,"sn":"CombineModule"},{"a":2,"n":"ConnectModule","t":4,"rt":ConnectCollectors,"sn":"ConnectModule"},{"at":[new UnityEngine.HeaderAttribute("Configuration")],"a":2,"n":"CurentCollectorsConfig","t":4,"rt":LevelColorCollectorsConfig,"sn":"CurentCollectorsConfig"},{"a":2,"n":"MaxBulletPerCollector","t":4,"rt":$n[1].Int32,"sn":"MaxBulletPerCollector","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.HeaderAttribute("TOOL MODULE(s)")],"a":2,"n":"MoveModule","t":4,"rt":MoveCollector,"sn":"MoveModule"},{"at":[new UnityEngine.HeaderAttribute("Setup Parameters")],"a":2,"n":"NumberOfColumns","t":4,"rt":$n[1].Int32,"sn":"NumberOfColumns","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"NumberOfLockedCollector","t":4,"rt":$n[1].Int32,"sn":"NumberOfLockedCollector","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"NumberOfWorkingPixels","t":4,"rt":$n[1].Int32,"sn":"NumberOfWorkingPixels","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"OriginalCollectorPosition","t":4,"rt":$n[6].List$1(UnityEngine.Vector3),"sn":"OriginalCollectorPosition"},{"a":2,"n":"OriginalLocksPosition","t":4,"rt":$n[6].List$1(UnityEngine.Vector3),"sn":"OriginalLocksPosition"},{"a":2,"n":"SplitModule","t":4,"rt":SplitCollector,"sn":"SplitModule"},{"a":2,"n":"SwapModule","t":4,"rt":SwapCollectors,"sn":"SwapModule"},{"at":[new UnityEngine.HeaderAttribute("Tool")],"a":2,"n":"ToolActive","t":4,"rt":$n[1].Boolean,"sn":"ToolActive","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"TotalBulletsCount","t":4,"rt":$n[1].Int32,"sn":"TotalBulletsCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"collectorSetCounters","t":4,"rt":$n[6].Dictionary$2(System.String,System.Int32),"sn":"collectorSetCounters"},{"a":2,"n":"colorSetCounters","t":4,"rt":$n[6].Dictionary$2(System.String,System.Int32),"sn":"colorSetCounters"},{"a":2,"n":"defaultHidden","t":4,"rt":$n[1].Boolean,"sn":"defaultHidden","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("Default States")],"a":2,"n":"defaultLocked","t":4,"rt":$n[1].Boolean,"sn":"defaultLocked","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"paintingConfig","t":4,"rt":PaintingConfig,"sn":"paintingConfig"},{"at":[new UnityEngine.HeaderAttribute("Preview")],"a":2,"n":"previewSystem","t":4,"rt":LevelCollectorsSystem,"sn":"previewSystem"}]}; }, $n);
    /*LevelCollectorsConfigSetup end.*/

    /*LevelConfigSetup start.*/
    $m("LevelConfigSetup", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"at":[new UnityEngine.ContextMenu.ctor("CLEAR LEVEL")],"a":2,"n":"ClearLevel","t":8,"sn":"ClearLevel","rt":$n[1].Void},{"at":[new UnityEngine.ContextMenu.ctor("LOAD LEVEL")],"a":2,"n":"LoadLevel","t":8,"sn":"LoadLevel","rt":$n[1].Void},{"a":2,"n":"LoadLevel","t":8,"pi":[{"n":"levelConfig","pt":LevelConfig,"ps":0}],"sn":"LoadLevel$1","rt":$n[1].Void,"p":[LevelConfig]},{"at":[new UnityEngine.ContextMenu.ctor("Refresh")],"a":1,"n":"OnValidate","t":8,"sn":"OnValidate","rt":$n[1].Void},{"a":2,"n":"SelectGridObject","t":8,"sn":"SelectGridObject","rt":$n[1].Void},{"a":2,"n":"SetUpComponents","t":8,"sn":"SetUpComponents","rt":$n[1].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[1].Void},{"a":2,"n":"ColorCodesUsed","t":4,"rt":$n[6].List$1(System.String),"sn":"ColorCodesUsed"},{"a":2,"n":"CurrentGridObject","t":4,"rt":PaintingGridObject,"sn":"CurrentGridObject"},{"a":2,"n":"CurrentGridObjects","t":4,"rt":$n[6].List$1(PaintingGridObject),"sn":"CurrentGridObjects"},{"at":[new UnityEngine.HeaderAttribute("LEVEL DATA(s)")],"a":2,"n":"CurrentLevel","t":4,"rt":LevelConfig,"sn":"CurrentLevel"},{"a":2,"n":"CurrentLevelCollectorConfig","t":4,"rt":LevelColorCollectorsConfig,"sn":"CurrentLevelCollectorConfig"},{"a":2,"n":"CurrentLevelColorCodes","t":4,"rt":$n[6].List$1(System.String),"sn":"CurrentLevelColorCodes"},{"a":2,"n":"CurrentLevelPainting","t":4,"rt":$n[2].Sprite,"sn":"CurrentLevelPainting"},{"a":2,"n":"CurrentLevelPaintingConfig","t":4,"rt":PaintingConfig,"sn":"CurrentLevelPaintingConfig"},{"a":2,"n":"EDITOR","t":4,"rt":$n[1].Boolean,"sn":"EDITOR","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"KeyObjectSetup","t":4,"rt":KeyObjectConfigSetup,"sn":"KeyObjectSetup"},{"at":[new UnityEngine.SpaceAttribute.ctor()],"a":2,"n":"LevelCollectorsManager","t":4,"rt":LevelCollectorsSystem,"sn":"LevelCollectorsManager"},{"a":2,"n":"LevelCollectorsSetup","t":4,"rt":LevelCollectorsConfigSetup,"sn":"LevelCollectorsSetup"},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.HeaderAttribute("INPUT(s)")],"a":2,"n":"NewTargetPainting","t":4,"rt":$n[2].Sprite,"sn":"NewTargetPainting"},{"at":[new UnityEngine.HeaderAttribute("CONTROLLER(s)")],"a":2,"n":"PaintingSetup","t":4,"rt":PaintingConfigSetup,"sn":"PaintingSetup"},{"a":2,"n":"PipeObjectSetup","t":4,"rt":PipeObjectConfigSetup,"sn":"PipeObjectSetup"},{"a":2,"n":"WallObjectSetup","t":4,"rt":BigBlockObjectConfigSetup,"sn":"WallObjectSetup"},{"a":1,"n":"tempColorList","is":true,"t":4,"rt":$n[6].List$1(System.String),"sn":"tempColorList","ro":true}]}; }, $n);
    /*LevelConfigSetup end.*/

    /*CombinesCollector start.*/
    $m("CombinesCollector", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"at":[new UnityEngine.ContextMenu.ctor("COMBINE")],"a":2,"n":"Combine","t":8,"sn":"Combine","rt":$n[1].Void},{"a":2,"n":"Combine","t":8,"pi":[{"n":"first","pt":ColorPixelsCollectorObject,"ps":0},{"n":"second","pt":ColorPixelsCollectorObject,"ps":1}],"sn":"Combine$1","rt":$n[1].Void,"p":[ColorPixelsCollectorObject,ColorPixelsCollectorObject]},{"a":1,"n":"OnValidate","t":8,"sn":"OnValidate","rt":$n[1].Void},{"a":2,"n":"CombineIndexOne","t":4,"rt":$n[1].Int32,"sn":"CombineIndexOne","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"CombineIndexTwo","t":4,"rt":$n[1].Int32,"sn":"CombineIndexTwo","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"Gunner0ne","t":4,"rt":ColorPixelsCollectorObject,"sn":"Gunner0ne"},{"a":2,"n":"GunnerTwo","t":4,"rt":ColorPixelsCollectorObject,"sn":"GunnerTwo"},{"a":2,"n":"LevelCollectorsSetup","t":4,"rt":LevelCollectorsConfigSetup,"sn":"LevelCollectorsSetup"}]}; }, $n);
    /*CombinesCollector end.*/

    /*ConnectCollectors start.*/
    $m("ConnectCollectors", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"at":[new UnityEngine.ContextMenu.ctor("CONNECT")],"a":2,"n":"Connect","t":8,"sn":"Connect","rt":$n[1].Void},{"a":2,"n":"Connect","t":8,"pi":[{"n":"first","pt":ColorPixelsCollectorObject,"ps":0},{"n":"second","pt":ColorPixelsCollectorObject,"ps":1}],"sn":"Connect$1","rt":$n[1].Void,"p":[ColorPixelsCollectorObject,ColorPixelsCollectorObject]},{"a":1,"n":"OnValidate","t":8,"sn":"OnValidate","rt":$n[1].Void},{"a":2,"n":"ConnectIndexOne","t":4,"rt":$n[1].Int32,"sn":"ConnectIndexOne","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ConnectIndexTwo","t":4,"rt":$n[1].Int32,"sn":"ConnectIndexTwo","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"Gunner0ne","t":4,"rt":ColorPixelsCollectorObject,"sn":"Gunner0ne"},{"a":2,"n":"GunnerTwo","t":4,"rt":ColorPixelsCollectorObject,"sn":"GunnerTwo"},{"a":2,"n":"LevelCollectorsSetup","t":4,"rt":LevelCollectorsConfigSetup,"sn":"LevelCollectorsSetup"}]}; }, $n);
    /*ConnectCollectors end.*/

    /*MoveCollector start.*/
    $m("MoveCollector", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"IsInFrontOf","t":8,"pi":[{"n":"first","pt":$n[2].Transform,"ps":0},{"n":"second","pt":$n[2].Transform,"ps":1}],"sn":"IsInFrontOf","rt":$n[1].Boolean,"p":[$n[2].Transform,$n[2].Transform],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.ContextMenu.ctor("MOVE")],"a":2,"n":"Move","t":8,"sn":"Move","rt":$n[1].Void},{"a":2,"n":"Move","t":8,"pi":[{"n":"first","pt":CollectorMachanicObjectBase,"ps":0},{"n":"second","pt":CollectorMachanicObjectBase,"ps":1}],"sn":"Move$1","rt":$n[1].Void,"p":[CollectorMachanicObjectBase,CollectorMachanicObjectBase]},{"a":1,"n":"OnValidate","t":8,"sn":"OnValidate","rt":$n[1].Void},{"a":2,"n":"Gunner0ne","t":4,"rt":ColorPixelsCollectorObject,"sn":"Gunner0ne"},{"a":2,"n":"GunnerTwo","t":4,"rt":ColorPixelsCollectorObject,"sn":"GunnerTwo"},{"a":2,"n":"LevelCollectorsSetup","t":4,"rt":LevelCollectorsConfigSetup,"sn":"LevelCollectorsSetup"},{"a":2,"n":"MoveIndexOne","t":4,"rt":$n[1].Int32,"sn":"MoveIndexOne","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"MoveIndexTwo","t":4,"rt":$n[1].Int32,"sn":"MoveIndexTwo","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*MoveCollector end.*/

    /*SplitCollector start.*/
    $m("SplitCollector", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"IsInFrontOf","t":8,"pi":[{"n":"first","pt":$n[2].Transform,"ps":0},{"n":"second","pt":$n[2].Transform,"ps":1}],"sn":"IsInFrontOf","rt":$n[1].Boolean,"p":[$n[2].Transform,$n[2].Transform],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"OnValidate","t":8,"sn":"OnValidate","rt":$n[1].Void},{"at":[new UnityEngine.ContextMenu.ctor("SPLIT")],"a":2,"n":"Split","t":8,"sn":"Split","rt":$n[1].Void},{"a":2,"n":"Split","t":8,"pi":[{"n":"target","pt":ColorPixelsCollectorObject,"ps":0}],"sn":"Split$1","rt":$n[1].Void,"p":[ColorPixelsCollectorObject]},{"a":2,"n":"LevelCollectorsSetup","t":4,"rt":LevelCollectorsConfigSetup,"sn":"LevelCollectorsSetup"},{"a":2,"n":"SplitIndex","t":4,"rt":$n[1].Int32,"sn":"SplitIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"TargetGunner","t":4,"rt":ColorPixelsCollectorObject,"sn":"TargetGunner"}]}; }, $n);
    /*SplitCollector end.*/

    /*SwapCollectors start.*/
    $m("SwapCollectors", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnValidate","t":8,"sn":"OnValidate","rt":$n[1].Void},{"at":[new UnityEngine.ContextMenu.ctor("SWAP")],"a":2,"n":"Swap","t":8,"sn":"Swap","rt":$n[1].Void},{"a":2,"n":"Swap","t":8,"pi":[{"n":"first","pt":CollectorMachanicObjectBase,"ps":0},{"n":"second","pt":CollectorMachanicObjectBase,"ps":1}],"sn":"Swap$1","rt":$n[1].Void,"p":[CollectorMachanicObjectBase,CollectorMachanicObjectBase]},{"a":2,"n":"Gunner0ne","t":4,"rt":ColorPixelsCollectorObject,"sn":"Gunner0ne"},{"a":2,"n":"GunnerTwo","t":4,"rt":ColorPixelsCollectorObject,"sn":"GunnerTwo"},{"a":2,"n":"LevelCollectorsSetup","t":4,"rt":LevelCollectorsConfigSetup,"sn":"LevelCollectorsSetup"},{"a":2,"n":"SwapIndexOne","t":4,"rt":$n[1].Int32,"sn":"SwapIndexOne","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"SwapIndexTwo","t":4,"rt":$n[1].Int32,"sn":"SwapIndexTwo","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*SwapCollectors end.*/

    /*PaintingAdvancedSetup start.*/
    $m("PaintingAdvancedSetup", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"BGColor","t":4,"rt":$n[2].Color,"sn":"BGColor"},{"a":2,"n":"BlockObjectLayermask","t":4,"rt":$n[2].LayerMask,"sn":"BlockObjectLayermask"},{"a":2,"n":"CollectorSetupModule","t":4,"rt":LevelCollectorsConfigSetup,"sn":"CollectorSetupModule"},{"a":2,"n":"KeySetupModule","t":4,"rt":KeyObjectConfigSetup,"sn":"KeySetupModule"},{"at":[new UnityEngine.HeaderAttribute("MODULE(s)")],"a":2,"n":"LevelManager","t":4,"rt":LevelConfigSetup,"sn":"LevelManager"},{"a":2,"n":"PaintModule","t":4,"rt":PaintingLayoutAdjustModule,"sn":"PaintModule"},{"a":2,"n":"PaintingSetup","t":4,"rt":PaintingConfigSetup,"sn":"PaintingSetup"},{"a":2,"n":"PipeSetupModule","t":4,"rt":PipeObjectConfigSetup,"sn":"PipeSetupModule"},{"a":2,"n":"SelectedItems","t":4,"rt":$n[6].List$1(PaintingPixelComponent),"sn":"SelectedItems"},{"at":[new UnityEngine.HeaderAttribute("TOOL(s)")],"a":2,"n":"ToolActive","t":4,"rt":$n[1].Boolean,"sn":"ToolActive","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"WallSetupModule","t":4,"rt":BigBlockObjectConfigSetup,"sn":"WallSetupModule"},{"at":[new UnityEngine.HeaderAttribute("TOOL RUNTIME DATA: PIPE")],"a":2,"n":"currentSelectedColorCode","t":4,"rt":$n[1].Int32,"sn":"currentSelectedColorCode","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"heartInput","t":4,"rt":$n[1].Int32,"sn":"heartInput","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*PaintingAdvancedSetup end.*/

    /*PaintingConfigSetup start.*/
    $m("PaintingConfigSetup", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"CanSample","t":8,"sn":"CanSample","rt":$n[1].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ColorDistanceLAB","t":8,"pi":[{"n":"color1","pt":$n[2].Color,"ps":0},{"n":"color2","pt":$n[2].Color,"ps":1}],"sn":"ColorDistanceLAB","rt":$n[1].Single,"p":[$n[2].Color,$n[2].Color],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"CreatePaintingConfigAsset","t":8,"pi":[{"n":"pixels","pt":$n[6].List$1(PaintingPixelConfig),"ps":0},{"n":"gridSize","pt":$n[2].Vector2,"ps":1},{"n":"originalSprite","pt":$n[2].Sprite,"ps":2}],"sn":"CreatePaintingConfigAsset","rt":PaintingConfig,"p":[$n[6].List$1(PaintingPixelConfig),$n[2].Vector2,$n[2].Sprite]},{"a":2,"n":"ExtractColorCodesFromPainting","t":8,"pi":[{"n":"_sprite","dv":null,"o":true,"pt":$n[2].Sprite,"ps":0}],"sn":"ExtractColorCodesFromPainting","rt":$n[1].Void,"p":[$n[2].Sprite]},{"a":1,"n":"FindClosestColorInPalette","t":8,"pi":[{"n":"targetColor","pt":$n[2].Color,"ps":0},{"n":"palette","pt":ColorPalleteData,"ps":1}],"sn":"FindClosestColorInPalette","rt":$n[1].ValueTuple$2(UnityEngine.Color,System.String),"p":[$n[2].Color,ColorPalleteData]},{"a":1,"n":"FindClosestColorInPaletteIgnoreRules","t":8,"pi":[{"n":"targetColor","pt":$n[2].Color,"ps":0},{"n":"palette","pt":ColorPalleteData,"ps":1}],"sn":"FindClosestColorInPaletteIgnoreRules","rt":$n[1].ValueTuple$2(UnityEngine.Color,System.String),"p":[$n[2].Color,ColorPalleteData]},{"a":1,"n":"GetTextureFromSprite","t":8,"pi":[{"n":"sprite","pt":$n[2].Sprite,"ps":0}],"sn":"GetTextureFromSprite","rt":$n[2].Texture2D,"p":[$n[2].Sprite]},{"a":1,"n":"RGBToLAB","t":8,"pi":[{"n":"color","pt":$n[2].Color,"ps":0}],"sn":"RGBToLAB","rt":$n[2].Vector3,"p":[$n[2].Color]},{"a":2,"n":"SamplePaintingToGrid","t":8,"pi":[{"n":"_sprite","dv":null,"o":true,"pt":$n[2].Sprite,"ps":0}],"sn":"SamplePaintingToGrid","rt":$n[1].Void,"p":[$n[2].Sprite]},{"a":2,"n":"Save","t":8,"sn":"Save","rt":$n[1].Void},{"a":2,"n":"ColorCodeInUse","t":4,"rt":$n[6].List$1(System.String),"sn":"ColorCodeInUse"},{"a":2,"n":"CurrentGridObject","t":4,"rt":PaintingGridObject,"sn":"CurrentGridObject"},{"at":[new UnityEngine.HeaderAttribute("Result")],"a":2,"n":"CurrentPaintingConfig","t":4,"rt":PaintingConfig,"sn":"CurrentPaintingConfig"},{"a":2,"n":"PrefabSource","t":4,"rt":LevelMechanicObjectPrefabs,"sn":"PrefabSource"},{"at":[new UnityEngine.HeaderAttribute("Input Settings")],"a":2,"n":"TargetPainting","t":4,"rt":$n[2].Sprite,"sn":"TargetPainting"},{"at":[new UnityEngine.HeaderAttribute("Color Filter Settings")],"a":2,"n":"useColorFilter","t":4,"rt":$n[1].Boolean,"sn":"useColorFilter","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*PaintingConfigSetup end.*/

    /*PaintingLayoutAdjustModule start.*/
    $m("PaintingLayoutAdjustModule", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"at":[new UnityEngine.ContextMenu.ctor("Add Line Above")],"a":2,"n":"AddLineAbove","t":8,"sn":"AddLineAbove","rt":$n[1].Void},{"at":[new UnityEngine.ContextMenu.ctor("Add Line Below")],"a":2,"n":"AddLineBelow","t":8,"sn":"AddLineBelow","rt":$n[1].Void},{"at":[new UnityEngine.ContextMenu.ctor("Add Line Left")],"a":2,"n":"AddLineLeft","t":8,"sn":"AddLineLeft","rt":$n[1].Void},{"at":[new UnityEngine.ContextMenu.ctor("Add Line Right")],"a":2,"n":"AddLineRight","t":8,"sn":"AddLineRight","rt":$n[1].Void},{"a":2,"n":"AddPixel","t":8,"pi":[{"n":"_pos","pt":$n[2].Vector3,"ps":0},{"n":"save","dv":true,"o":true,"pt":$n[1].Boolean,"ps":1}],"sn":"AddPixel","rt":$n[1].Void,"p":[$n[2].Vector3,$n[1].Boolean]},{"a":2,"n":"AddPixel","t":8,"pi":[{"n":"_pos","pt":$n[2].Vector3,"ps":0},{"n":"_colorCode","pt":$n[1].String,"ps":1},{"n":"save","dv":true,"o":true,"pt":$n[1].Boolean,"ps":2}],"sn":"AddPixel$1","rt":$n[1].Void,"p":[$n[2].Vector3,$n[1].String,$n[1].Boolean]},{"a":1,"n":"GetBounds","t":8,"sn":"GetBounds","rt":$n[1].ValueTuple$4(System.Int32,System.Int32,System.Int32,System.Int32)},{"a":2,"n":"GetCurrentColor","t":8,"sn":"GetCurrentColor","rt":$n[2].Color},{"a":2,"n":"HidePixel","t":8,"pi":[{"n":"_pos","pt":$n[2].Vector3,"ps":0}],"sn":"HidePixel","rt":$n[1].Void,"p":[$n[2].Vector3]},{"a":2,"n":"Save","t":8,"sn":"Save","rt":$n[1].Void},{"a":2,"n":"SetActiveDeleteTool","t":8,"sn":"SetActiveDeleteTool","rt":$n[1].Void},{"a":2,"n":"SetActivePaintingTool","t":8,"sn":"SetActivePaintingTool","rt":$n[1].Void},{"at":[new UnityEngine.ContextMenu.ctor("Set Color Selected Pixels")],"a":2,"n":"SetColor","t":8,"sn":"SetColor","rt":$n[1].Void},{"at":[new UnityEngine.ContextMenu.ctor("Set Hide Selected Pixels")],"a":2,"n":"SetHideSelected","t":8,"sn":"SetHideSelected","rt":$n[1].Void},{"a":2,"n":"ColorCode","t":4,"rt":$n[1].String,"sn":"ColorCode"},{"at":[new UnityEngine.HeaderAttribute("CREATE BLOCK")],"a":2,"n":"GridLayerMask","t":4,"rt":$n[2].LayerMask,"sn":"GridLayerMask"},{"a":2,"n":"IsDeleteToolActive","t":4,"rt":$n[1].Boolean,"sn":"IsDeleteToolActive","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsPaintingToolActive","t":4,"rt":$n[1].Boolean,"sn":"IsPaintingToolActive","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"PaintingSetup","t":4,"rt":PaintingConfigSetup,"sn":"PaintingSetup"},{"a":2,"n":"SelectedPixels","t":4,"rt":$n[6].List$1(PaintingPixelComponent),"sn":"SelectedPixels"}]}; }, $n);
    /*PaintingLayoutAdjustModule end.*/

    /*PathTransformBasedCached start.*/
    $m("PathTransformBasedCached", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[1].Void},{"a":1,"n":"CalculateCumulativeDistances","t":8,"sn":"CalculateCumulativeDistances","rt":$n[1].Void},{"a":2,"n":"CalculateTotalDistance","t":8,"sn":"CalculateTotalDistance","rt":$n[1].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"ConvertDistanceToTf","t":8,"pi":[{"n":"distance","pt":$n[1].Single,"ps":0}],"sn":"ConvertDistanceToTf","rt":$n[1].Single,"p":[$n[1].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"ConvertTfToDistance","t":8,"pi":[{"n":"tf","pt":$n[1].Single,"ps":0}],"sn":"ConvertTfToDistance","rt":$n[1].Single,"p":[$n[1].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GetPositionAtDistance","t":8,"pi":[{"n":"distance","pt":$n[1].Single,"ps":0}],"sn":"GetPositionAtDistance","rt":$n[2].Vector3,"p":[$n[1].Single]},{"a":2,"n":"GetPositionAtTF","t":8,"pi":[{"n":"tf","pt":$n[1].Single,"ps":0}],"sn":"GetPositionAtTF","rt":$n[2].Vector3,"p":[$n[1].Single]},{"a":2,"n":"GetTangentAtDistance","t":8,"pi":[{"n":"distance","pt":$n[1].Single,"ps":0}],"sn":"GetTangentAtDistance","rt":$n[2].Vector3,"p":[$n[1].Single]},{"a":2,"n":"GetTangentAtTF","t":8,"pi":[{"n":"tf","pt":$n[1].Single,"ps":0}],"sn":"GetTangentAtTF","rt":$n[2].Vector3,"p":[$n[1].Single]},{"a":1,"n":"GetTransformForwardVector","t":8,"pi":[{"n":"t","pt":$n[2].Transform,"ps":0}],"sn":"GetTransformForwardVector","rt":$n[2].Vector3,"p":[$n[2].Transform]},{"a":1,"n":"GetTransformPosition","t":8,"pi":[{"n":"t","pt":$n[2].Transform,"ps":0}],"sn":"GetTransformPosition","rt":$n[2].Vector3,"p":[$n[2].Transform]},{"a":1,"n":"GetTransformUpVector","t":8,"pi":[{"n":"t","pt":$n[2].Transform,"ps":0}],"sn":"GetTransformUpVector","rt":$n[2].Vector3,"p":[$n[2].Transform]},{"a":1,"n":"GetTrueTfFromNormalizedTf","t":8,"pi":[{"n":"normalizedTf","pt":$n[1].Single,"ps":0}],"sn":"GetTrueTfFromNormalizedTf","rt":$n[1].Single,"p":[$n[1].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GetUpVectorAtDistance","t":8,"pi":[{"n":"distance","pt":$n[1].Single,"ps":0}],"sn":"GetUpVectorAtDistance","rt":$n[2].Vector3,"p":[$n[1].Single]},{"a":2,"n":"GetUpVectorAtTF","t":8,"pi":[{"n":"tf","pt":$n[1].Single,"ps":0}],"sn":"GetUpVectorAtTF","rt":$n[2].Vector3,"p":[$n[1].Single]},{"a":2,"n":"IsValid","t":8,"sn":"IsValid","rt":$n[1].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"MarkDistanceCacheDirty","t":8,"sn":"MarkDistanceCacheDirty","rt":$n[1].Void},{"a":2,"n":"Instance","is":true,"t":16,"rt":PathTransformBasedCached,"g":{"a":2,"n":"get_Instance","t":8,"rt":PathTransformBasedCached,"fg":"Instance","is":true},"s":{"a":1,"n":"set_Instance","t":8,"p":[PathTransformBasedCached],"rt":$n[1].Void,"fs":"Instance","is":true},"fn":"Instance"},{"a":2,"n":"PathPoints","t":4,"rt":$n[6].List$1(UnityEngine.Transform),"sn":"PathPoints"},{"a":1,"n":"cumulativeDistances","t":4,"rt":$n[6].List$1(System.Single),"sn":"cumulativeDistances"},{"a":1,"n":"isDistanceCacheDirty","t":4,"rt":$n[1].Boolean,"sn":"isDistanceCacheDirty","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"totalDistance","t":4,"rt":$n[1].Single,"sn":"totalDistance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<Instance>k__BackingField","is":true,"t":4,"rt":PathTransformBasedCached,"sn":"Instance"}]}; }, $n);
    /*PathTransformBasedCached end.*/

    /*PipeObjectConfigSetup start.*/
    $m("PipeObjectConfigSetup", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddPipeSetup","t":8,"pi":[{"n":"pipeSetup","pt":PipeObjectSetup,"ps":0}],"sn":"AddPipeSetup","rt":$n[1].Void,"p":[PipeObjectSetup]},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[1].Void},{"a":2,"n":"ClearAllPipeSetups","t":8,"sn":"ClearAllPipeSetups","rt":$n[1].Void},{"a":2,"n":"ClearPipeSetups","t":8,"sn":"ClearPipeSetups","rt":$n[1].Void},{"a":2,"n":"CreatePipe","t":8,"sn":"CreatePipe$1","rt":$n[1].Void},{"a":2,"n":"CreatePipe","t":8,"pi":[{"n":"startPixel","pt":PaintingPixel,"ps":0},{"n":"endPixel","pt":PaintingPixel,"ps":1},{"n":"colorCode","pt":$n[1].String,"ps":2},{"n":"hearts","pt":$n[1].Int32,"ps":3}],"sn":"CreatePipe","rt":PipeObjectSetup,"p":[PaintingPixel,PaintingPixel,$n[1].String,$n[1].Int32]},{"a":2,"n":"GetPaintingPixelsInBetween","t":8,"pi":[{"n":"startPixel","pt":PaintingPixel,"ps":0},{"n":"endPixel","pt":PaintingPixel,"ps":1}],"sn":"GetPaintingPixelsInBetween","rt":$n[6].List$1(PaintingPixelConfig),"p":[PaintingPixel,PaintingPixel]},{"a":2,"n":"GetPaintingPixelsInBetweenithSpace","t":8,"pi":[{"n":"startPixel","pt":PaintingPixel,"ps":0},{"n":"endPixel","pt":PaintingPixel,"ps":1}],"sn":"GetPaintingPixelsInBetweenithSpace","rt":$n[6].List$1(PaintingPixelConfig),"p":[PaintingPixel,PaintingPixel]},{"a":2,"n":"ImportPipesToPaintingConfig","t":8,"pi":[{"n":"paintingConfig","pt":PaintingConfig,"ps":0}],"sn":"ImportPipesToPaintingConfig","rt":$n[1].Void,"p":[PaintingConfig]},{"a":2,"n":"IsValidPipeOrientation","t":8,"pi":[{"n":"startPixel","pt":PaintingPixel,"ps":0},{"n":"endPixel","pt":PaintingPixel,"ps":1}],"sn":"IsValidPipeOrientation","rt":$n[1].Boolean,"p":[PaintingPixel,PaintingPixel],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"IsValidPipeOrientation","t":8,"pi":[{"n":"startPixelComponent","pt":PaintingPixelComponent,"ps":0},{"n":"endPixelComponent","pt":PaintingPixelComponent,"ps":1}],"sn":"IsValidPipeOrientation$1","rt":$n[1].Boolean,"p":[PaintingPixelComponent,PaintingPixelComponent],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Reload","t":8,"sn":"Reload","rt":$n[1].Void},{"a":2,"n":"RemovePipeSetup","t":8,"pi":[{"n":"pipeSetup","pt":PipeObjectSetup,"ps":0}],"sn":"RemovePipeSetup","rt":$n[1].Void,"p":[PipeObjectSetup]},{"a":2,"n":"Save","t":8,"sn":"Save","rt":$n[1].Void},{"a":1,"n":"SetupNewPipeInScene","t":8,"pi":[{"n":"setup","pt":PipeObjectSetup,"ps":0}],"sn":"SetupNewPipeInScene","rt":PipeObject,"p":[PipeObjectSetup]},{"a":2,"n":"ColorCode","t":4,"rt":$n[1].String,"sn":"ColorCode"},{"at":[new UnityEngine.HeaderAttribute("Pipe Configuration")],"a":2,"n":"CurrentLevelObjectSetups","t":4,"rt":$n[6].List$1(PipeObjectSetup),"sn":"CurrentLevelObjectSetups"},{"a":2,"n":"EndPixelComponent","t":4,"rt":PaintingPixelComponent,"sn":"EndPixelComponent"},{"a":2,"n":"PaintingSetupModule","t":4,"rt":PaintingConfigSetup,"sn":"PaintingSetupModule"},{"a":2,"n":"PipeBodyPrefab","t":4,"rt":$n[2].GameObject,"sn":"PipeBodyPrefab"},{"at":[new UnityEngine.HeaderAttribute("Prefabs")],"a":2,"n":"PipeHeadPrefab","t":4,"rt":$n[2].GameObject,"sn":"PipeHeadPrefab"},{"at":[new UnityEngine.HeaderAttribute("Pipe Properties")],"a":2,"n":"PipeHeart","t":4,"rt":$n[1].Int32,"sn":"PipeHeart","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.HeaderAttribute("Pipe Positioning")],"a":2,"n":"PipeSpaceFromGrid","t":4,"rt":$n[1].Int32,"sn":"PipeSpaceFromGrid","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"PipeTailPrefab","t":4,"rt":$n[2].GameObject,"sn":"PipeTailPrefab"},{"at":[new UnityEngine.HeaderAttribute("Pipe Scale")],"a":2,"n":"Scale","t":4,"rt":$n[2].Vector3,"sn":"Scale"},{"at":[new UnityEngine.HeaderAttribute("Pipe Setup")],"a":2,"n":"StartPixelComponent","t":4,"rt":PaintingPixelComponent,"sn":"StartPixelComponent"},{"a":2,"n":"pipeObjectSetups","t":4,"rt":$n[6].List$1(PipeObjectSetup),"sn":"pipeObjectSetups"}]}; }, $n);
    /*PipeObjectConfigSetup end.*/

    /*SplineDataContainerToTransformConverter start.*/
    $m("SplineDataContainerToTransformConverter", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"PathCachedObj","t":4,"rt":PathTransformBasedCached,"sn":"PathCachedObj"},{"at":[new UnityEngine.HeaderAttribute("Conversion Output"),new UnityEngine.TooltipAttribute("The resulting CachedSplineTransformPath asset")],"a":2,"n":"outputTransformPath","t":4,"rt":CachedSplineTransformPath,"sn":"outputTransformPath"},{"at":[new UnityEngine.TooltipAttribute("Name for the created path GameObject")],"a":2,"n":"pathName","t":4,"rt":$n[1].String,"sn":"pathName"},{"at":[new UnityEngine.TooltipAttribute("Parent GameObject for the created path transforms (optional)")],"a":2,"n":"pathParent","t":4,"rt":$n[2].Transform,"sn":"pathParent"},{"at":[new UnityEngine.TooltipAttribute("Prefab to use for each path point (optional, will create empty GameObject if null)")],"a":2,"n":"pathPointPrefab","t":4,"rt":$n[2].GameObject,"sn":"pathPointPrefab"},{"at":[new UnityEngine.HeaderAttribute("Conversion Settings"),new UnityEngine.TooltipAttribute("The SplineDataContainer asset to convert to transforms")],"a":2,"n":"splineDataContainer","t":4,"rt":SplineDataContainer,"sn":"splineDataContainer"},{"at":[new UnityEngine.HeaderAttribute("Options"),new UnityEngine.TooltipAttribute("If true, will create the path in world space. If false, will create in local space relative to pathParent")],"a":2,"n":"worldSpace","t":4,"rt":$n[1].Boolean,"sn":"worldSpace","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*SplineDataContainerToTransformConverter end.*/

    /*UiEndGame start.*/
    $m("UiEndGame", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"FadeInEndGame","t":8,"sn":"FadeInEndGame","rt":$n[1].Void},{"a":1,"n":"LoadingDotsCoroutine","t":8,"sn":"LoadingDotsCoroutine","rt":$n[0].IEnumerator},{"at":[new UnityEngine.ContextMenu.ctor("Show Lose")],"v":true,"a":2,"n":"ShowEndGameLose","t":8,"sn":"ShowEndGameLose","rt":$n[1].Void},{"at":[new UnityEngine.ContextMenu.ctor("Show Win")],"v":true,"a":2,"n":"ShowEndGameWin","t":8,"sn":"ShowEndGameWin","rt":$n[1].Void},{"v":true,"a":3,"n":"Start","t":8,"sn":"Start","rt":$n[1].Void},{"a":2,"n":"StartLevelTransition","t":8,"pi":[{"n":"onComplete","dv":null,"o":true,"pt":Function,"ps":0},{"n":"delayBeforeFadeOut","dv":0.25,"o":true,"pt":$n[1].Single,"ps":1}],"sn":"StartLevelTransition","rt":$n[1].Void,"p":[Function,$n[1].Single]},{"a":1,"n":"StartLoadingDots","t":8,"sn":"StartLoadingDots","rt":$n[1].Void},{"a":1,"n":"StopLoadingDots","t":8,"sn":"StopLoadingDots","rt":$n[1].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_buttonText","t":4,"rt":$n[3].Text,"sn":"m_buttonText"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_buttonText1","t":4,"rt":$n[3].Text,"sn":"m_buttonText1"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_endGameCanvas","t":4,"rt":$n[2].CanvasGroup,"sn":"m_endGameCanvas"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_endGameSound","t":4,"rt":System.Array.type(UnityEngine.AudioClip),"sn":"m_endGameSound"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_endText","t":4,"rt":$n[3].Text,"sn":"m_endText"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_endText1","t":4,"rt":$n[3].Text,"sn":"m_endText1"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_headerCanvas","t":4,"rt":$n[2].CanvasGroup,"sn":"m_headerCanvas"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_levelTransitionOverlay","t":4,"rt":$n[2].CanvasGroup,"sn":"m_levelTransitionOverlay"},{"a":1,"n":"m_loadingCoroutine","t":4,"rt":$n[2].Coroutine,"sn":"m_loadingCoroutine"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_loadingText","t":4,"rt":$n[4].TextMeshProUGUI,"sn":"m_loadingText"}]}; }, $n);
    /*UiEndGame end.*/

    /*UIEndGameXmas start.*/
    $m("UIEndGameXmas", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"at":[new UnityEngine.ContextMenu.ctor("Show Lose 1")],"ov":true,"a":2,"n":"ShowEndGameLose","t":8,"sn":"ShowEndGameLose","rt":$n[1].Void},{"at":[new UnityEngine.ContextMenu.ctor("Show Win 1")],"ov":true,"a":2,"n":"ShowEndGameWin","t":8,"sn":"ShowEndGameWin","rt":$n[1].Void},{"ov":true,"a":3,"n":"Start","t":8,"sn":"Start","rt":$n[1].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_xmasFooterImage","t":4,"rt":$n[3].Image,"sn":"m_xmasFooterImage"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_xmasFooterSprite","t":4,"rt":System.Array.type(UnityEngine.Sprite),"sn":"m_xmasFooterSprite"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_xmasHeaderImage","t":4,"rt":$n[3].Image,"sn":"m_xmasHeaderImage"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_xmasLoseSprite","t":4,"rt":$n[2].Sprite,"sn":"m_xmasLoseSprite"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_xmasWinSprite","t":4,"rt":$n[2].Sprite,"sn":"m_xmasWinSprite"}]}; }, $n);
    /*UIEndGameXmas end.*/

    /*SingleColorCollectorConfig start.*/
    $m("SingleColorCollectorConfig", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[SingleColorCollectorConfig],"pi":[{"n":"_stock","pt":SingleColorCollectorConfig,"ps":0}],"sn":"$ctor1"},{"a":2,"n":".ctor","t":1,"p":[$n[1].String,$n[1].Int32,$n[1].Boolean,$n[1].Boolean],"pi":[{"n":"colorCode","pt":$n[1].String,"ps":0},{"n":"bullets","pt":$n[1].Int32,"ps":1},{"n":"locked","dv":false,"o":true,"pt":$n[1].Boolean,"ps":2},{"n":"hidden","dv":false,"o":true,"pt":$n[1].Boolean,"ps":3}],"sn":"$ctor2"},{"a":2,"n":"Bullets","t":4,"rt":$n[1].Int32,"sn":"Bullets","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.HeaderAttribute("Color and Ammunition")],"a":2,"n":"ColorCode","t":4,"rt":$n[1].String,"sn":"ColorCode"},{"at":[new UnityEngine.HeaderAttribute("Connections")],"a":2,"n":"ConnectedCollectorsIDs","t":4,"rt":$n[6].List$1(System.Int32),"sn":"ConnectedCollectorsIDs"},{"a":2,"n":"Hidden","t":4,"rt":$n[1].Boolean,"sn":"Hidden","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"ID","t":4,"rt":$n[1].Int32,"sn":"ID","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.HeaderAttribute("Collector State")],"a":2,"n":"Locked","t":4,"rt":$n[1].Boolean,"sn":"Locked","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*SingleColorCollectorConfig end.*/

    /*LockObjectConfig start.*/
    $m("LockObjectConfig", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ID","t":4,"rt":$n[1].Int32,"sn":"ID","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"Row","t":4,"rt":$n[1].Int32,"sn":"Row","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*LockObjectConfig end.*/

    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty start.*/
    $m("IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty end.*/

    /*DG.Tweening.DOTweenModuleAudio start.*/
    $m("DG.Tweening.DOTweenModuleAudio", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOComplete","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].AudioMixer,"ps":0},{"n":"withCallbacks","dv":false,"o":true,"pt":$n[1].Boolean,"ps":1}],"sn":"DOComplete","rt":$n[1].Int32,"p":[$n[8].AudioMixer,$n[1].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].AudioSource,"ps":0},{"n":"endValue","pt":$n[1].Single,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2}],"sn":"DOFade","rt":$n[10].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[2].AudioSource,$n[1].Single,$n[1].Single]},{"a":2,"n":"DOFlip","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].AudioMixer,"ps":0}],"sn":"DOFlip","rt":$n[1].Int32,"p":[$n[8].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOGoto","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].AudioMixer,"ps":0},{"n":"to","pt":$n[1].Single,"ps":1},{"n":"andPlay","dv":false,"o":true,"pt":$n[1].Boolean,"ps":2}],"sn":"DOGoto","rt":$n[1].Int32,"p":[$n[8].AudioMixer,$n[1].Single,$n[1].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOKill","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].AudioMixer,"ps":0},{"n":"complete","dv":false,"o":true,"pt":$n[1].Boolean,"ps":1}],"sn":"DOKill","rt":$n[1].Int32,"p":[$n[8].AudioMixer,$n[1].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPause","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].AudioMixer,"ps":0}],"sn":"DOPause","rt":$n[1].Int32,"p":[$n[8].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPitch","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].AudioSource,"ps":0},{"n":"endValue","pt":$n[1].Single,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2}],"sn":"DOPitch","rt":$n[10].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[2].AudioSource,$n[1].Single,$n[1].Single]},{"a":2,"n":"DOPlay","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].AudioMixer,"ps":0}],"sn":"DOPlay","rt":$n[1].Int32,"p":[$n[8].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPlayBackwards","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].AudioMixer,"ps":0}],"sn":"DOPlayBackwards","rt":$n[1].Int32,"p":[$n[8].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPlayForward","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].AudioMixer,"ps":0}],"sn":"DOPlayForward","rt":$n[1].Int32,"p":[$n[8].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DORestart","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].AudioMixer,"ps":0}],"sn":"DORestart","rt":$n[1].Int32,"p":[$n[8].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DORewind","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].AudioMixer,"ps":0}],"sn":"DORewind","rt":$n[1].Int32,"p":[$n[8].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOSetFloat","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].AudioMixer,"ps":0},{"n":"floatName","pt":$n[1].String,"ps":1},{"n":"endValue","pt":$n[1].Single,"ps":2},{"n":"duration","pt":$n[1].Single,"ps":3}],"sn":"DOSetFloat","rt":$n[10].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[8].AudioMixer,$n[1].String,$n[1].Single,$n[1].Single]},{"a":2,"n":"DOSmoothRewind","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].AudioMixer,"ps":0}],"sn":"DOSmoothRewind","rt":$n[1].Int32,"p":[$n[8].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOTogglePause","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].AudioMixer,"ps":0}],"sn":"DOTogglePause","rt":$n[1].Int32,"p":[$n[8].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*DG.Tweening.DOTweenModuleAudio end.*/

    /*DG.Tweening.DOTweenModulePhysics start.*/
    $m("DG.Tweening.DOTweenModulePhysics", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOJump","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Rigidbody,"ps":0},{"n":"endValue","pt":$n[2].Vector3,"ps":1},{"n":"jumpPower","pt":$n[1].Single,"ps":2},{"n":"numJumps","pt":$n[1].Int32,"ps":3},{"n":"duration","pt":$n[1].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[1].Boolean,"ps":5}],"sn":"DOJump","rt":$n[5].Sequence,"p":[$n[2].Rigidbody,$n[2].Vector3,$n[1].Single,$n[1].Int32,$n[1].Single,$n[1].Boolean]},{"a":4,"n":"DOLocalPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Rigidbody,"ps":0},{"n":"path","pt":$n[11].Path,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"pathMode","dv":1,"o":true,"pt":$n[5].PathMode,"ps":3}],"sn":"DOLocalPath$1","rt":$n[10].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[2].Rigidbody,$n[11].Path,$n[1].Single,$n[5].PathMode]},{"a":2,"n":"DOLocalPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Rigidbody,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector3),"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[5].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[5].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[1].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[1].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOLocalPath","rt":$n[10].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[2].Rigidbody,System.Array.type(UnityEngine.Vector3),$n[1].Single,$n[5].PathType,$n[5].PathMode,$n[1].Int32,$n[1].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DOLookAt","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Rigidbody,"ps":0},{"n":"towards","pt":$n[2].Vector3,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"axisConstraint","dv":0,"o":true,"pt":$n[5].AxisConstraint,"ps":3},{"n":"up","dv":null,"o":true,"pt":$n[1].Nullable$1(UnityEngine.Vector3),"ps":4}],"sn":"DOLookAt","rt":$n[10].TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions),"p":[$n[2].Rigidbody,$n[2].Vector3,$n[1].Single,$n[5].AxisConstraint,$n[1].Nullable$1(UnityEngine.Vector3)]},{"a":2,"n":"DOMove","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Rigidbody,"ps":0},{"n":"endValue","pt":$n[2].Vector3,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[1].Boolean,"ps":3}],"sn":"DOMove","rt":$n[10].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].Rigidbody,$n[2].Vector3,$n[1].Single,$n[1].Boolean]},{"a":2,"n":"DOMoveX","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Rigidbody,"ps":0},{"n":"endValue","pt":$n[1].Single,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[1].Boolean,"ps":3}],"sn":"DOMoveX","rt":$n[10].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].Rigidbody,$n[1].Single,$n[1].Single,$n[1].Boolean]},{"a":2,"n":"DOMoveY","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Rigidbody,"ps":0},{"n":"endValue","pt":$n[1].Single,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[1].Boolean,"ps":3}],"sn":"DOMoveY","rt":$n[10].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].Rigidbody,$n[1].Single,$n[1].Single,$n[1].Boolean]},{"a":2,"n":"DOMoveZ","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Rigidbody,"ps":0},{"n":"endValue","pt":$n[1].Single,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[1].Boolean,"ps":3}],"sn":"DOMoveZ","rt":$n[10].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].Rigidbody,$n[1].Single,$n[1].Single,$n[1].Boolean]},{"a":4,"n":"DOPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Rigidbody,"ps":0},{"n":"path","pt":$n[11].Path,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"pathMode","dv":1,"o":true,"pt":$n[5].PathMode,"ps":3}],"sn":"DOPath$1","rt":$n[10].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[2].Rigidbody,$n[11].Path,$n[1].Single,$n[5].PathMode]},{"a":2,"n":"DOPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Rigidbody,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector3),"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[5].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[5].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[1].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[1].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOPath","rt":$n[10].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[2].Rigidbody,System.Array.type(UnityEngine.Vector3),$n[1].Single,$n[5].PathType,$n[5].PathMode,$n[1].Int32,$n[1].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DORotate","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Rigidbody,"ps":0},{"n":"endValue","pt":$n[2].Vector3,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"mode","dv":0,"o":true,"pt":$n[5].RotateMode,"ps":3}],"sn":"DORotate","rt":$n[10].TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions),"p":[$n[2].Rigidbody,$n[2].Vector3,$n[1].Single,$n[5].RotateMode]}]}; }, $n);
    /*DG.Tweening.DOTweenModulePhysics end.*/

    /*DG.Tweening.DOTweenModulePhysics2D start.*/
    $m("DG.Tweening.DOTweenModulePhysics2D", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOJump","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[2].Vector2,"ps":1},{"n":"jumpPower","pt":$n[1].Single,"ps":2},{"n":"numJumps","pt":$n[1].Int32,"ps":3},{"n":"duration","pt":$n[1].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[1].Boolean,"ps":5}],"sn":"DOJump","rt":$n[5].Sequence,"p":[$n[2].Rigidbody2D,$n[2].Vector2,$n[1].Single,$n[1].Int32,$n[1].Single,$n[1].Boolean]},{"a":4,"n":"DOLocalPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Rigidbody2D,"ps":0},{"n":"path","pt":$n[11].Path,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"pathMode","dv":1,"o":true,"pt":$n[5].PathMode,"ps":3}],"sn":"DOLocalPath$1","rt":$n[10].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[2].Rigidbody2D,$n[11].Path,$n[1].Single,$n[5].PathMode]},{"a":2,"n":"DOLocalPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Rigidbody2D,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[5].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[5].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[1].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[1].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOLocalPath","rt":$n[10].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[2].Rigidbody2D,System.Array.type(UnityEngine.Vector2),$n[1].Single,$n[5].PathType,$n[5].PathMode,$n[1].Int32,$n[1].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DOMove","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[2].Vector2,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[1].Boolean,"ps":3}],"sn":"DOMove","rt":$n[10].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].Rigidbody2D,$n[2].Vector2,$n[1].Single,$n[1].Boolean]},{"a":2,"n":"DOMoveX","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[1].Single,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[1].Boolean,"ps":3}],"sn":"DOMoveX","rt":$n[10].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].Rigidbody2D,$n[1].Single,$n[1].Single,$n[1].Boolean]},{"a":2,"n":"DOMoveY","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[1].Single,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[1].Boolean,"ps":3}],"sn":"DOMoveY","rt":$n[10].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].Rigidbody2D,$n[1].Single,$n[1].Single,$n[1].Boolean]},{"a":4,"n":"DOPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Rigidbody2D,"ps":0},{"n":"path","pt":$n[11].Path,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"pathMode","dv":1,"o":true,"pt":$n[5].PathMode,"ps":3}],"sn":"DOPath$1","rt":$n[10].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[2].Rigidbody2D,$n[11].Path,$n[1].Single,$n[5].PathMode]},{"a":2,"n":"DOPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Rigidbody2D,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[5].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[5].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[1].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[1].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOPath","rt":$n[10].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[2].Rigidbody2D,System.Array.type(UnityEngine.Vector2),$n[1].Single,$n[5].PathType,$n[5].PathMode,$n[1].Int32,$n[1].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DORotate","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[1].Single,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2}],"sn":"DORotate","rt":$n[10].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[2].Rigidbody2D,$n[1].Single,$n[1].Single]}]}; }, $n);
    /*DG.Tweening.DOTweenModulePhysics2D end.*/

    /*DG.Tweening.DOTweenModuleSprite start.*/
    $m("DG.Tweening.DOTweenModuleSprite", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[2].Color,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2}],"sn":"DOBlendableColor","rt":$n[5].Tweener,"p":[$n[2].SpriteRenderer,$n[2].Color,$n[1].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[2].Color,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2}],"sn":"DOColor","rt":$n[10].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[2].SpriteRenderer,$n[2].Color,$n[1].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[1].Single,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2}],"sn":"DOFade","rt":$n[10].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[2].SpriteRenderer,$n[1].Single,$n[1].Single]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].SpriteRenderer,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[5].Sequence,"p":[$n[2].SpriteRenderer,pc.ColorGradient,$n[1].Single]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleSprite end.*/

    /*DG.Tweening.DOTweenModuleUI start.*/
    $m("DG.Tweening.DOTweenModuleUI", function () { return {"nested":[$n[5].DOTweenModuleUI.Utils],"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOAnchorMax","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"endValue","pt":$n[2].Vector2,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[1].Boolean,"ps":3}],"sn":"DOAnchorMax","rt":$n[10].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].RectTransform,$n[2].Vector2,$n[1].Single,$n[1].Boolean]},{"a":2,"n":"DOAnchorMin","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"endValue","pt":$n[2].Vector2,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[1].Boolean,"ps":3}],"sn":"DOAnchorMin","rt":$n[10].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].RectTransform,$n[2].Vector2,$n[1].Single,$n[1].Boolean]},{"a":2,"n":"DOAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"endValue","pt":$n[2].Vector2,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[1].Boolean,"ps":3}],"sn":"DOAnchorPos","rt":$n[10].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].RectTransform,$n[2].Vector2,$n[1].Single,$n[1].Boolean]},{"a":2,"n":"DOAnchorPos3D","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"endValue","pt":$n[2].Vector3,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[1].Boolean,"ps":3}],"sn":"DOAnchorPos3D","rt":$n[10].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].RectTransform,$n[2].Vector3,$n[1].Single,$n[1].Boolean]},{"a":2,"n":"DOAnchorPos3DX","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Single,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[1].Boolean,"ps":3}],"sn":"DOAnchorPos3DX","rt":$n[10].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].RectTransform,$n[1].Single,$n[1].Single,$n[1].Boolean]},{"a":2,"n":"DOAnchorPos3DY","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Single,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[1].Boolean,"ps":3}],"sn":"DOAnchorPos3DY","rt":$n[10].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].RectTransform,$n[1].Single,$n[1].Single,$n[1].Boolean]},{"a":2,"n":"DOAnchorPos3DZ","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Single,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[1].Boolean,"ps":3}],"sn":"DOAnchorPos3DZ","rt":$n[10].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].RectTransform,$n[1].Single,$n[1].Single,$n[1].Boolean]},{"a":2,"n":"DOAnchorPosX","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Single,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[1].Boolean,"ps":3}],"sn":"DOAnchorPosX","rt":$n[10].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].RectTransform,$n[1].Single,$n[1].Single,$n[1].Boolean]},{"a":2,"n":"DOAnchorPosY","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Single,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[1].Boolean,"ps":3}],"sn":"DOAnchorPosY","rt":$n[10].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].RectTransform,$n[1].Single,$n[1].Single,$n[1].Boolean]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Graphic,"ps":0},{"n":"endValue","pt":$n[2].Color,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2}],"sn":"DOBlendableColor","rt":$n[5].Tweener,"p":[$n[3].Graphic,$n[2].Color,$n[1].Single]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Image,"ps":0},{"n":"endValue","pt":$n[2].Color,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2}],"sn":"DOBlendableColor$1","rt":$n[5].Tweener,"p":[$n[3].Image,$n[2].Color,$n[1].Single]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Text,"ps":0},{"n":"endValue","pt":$n[2].Color,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2}],"sn":"DOBlendableColor$2","rt":$n[5].Tweener,"p":[$n[3].Text,$n[2].Color,$n[1].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Graphic,"ps":0},{"n":"endValue","pt":$n[2].Color,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2}],"sn":"DOColor","rt":$n[10].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[3].Graphic,$n[2].Color,$n[1].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Image,"ps":0},{"n":"endValue","pt":$n[2].Color,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2}],"sn":"DOColor$1","rt":$n[10].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[3].Image,$n[2].Color,$n[1].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Outline,"ps":0},{"n":"endValue","pt":$n[2].Color,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2}],"sn":"DOColor$2","rt":$n[10].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[3].Outline,$n[2].Color,$n[1].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Text,"ps":0},{"n":"endValue","pt":$n[2].Color,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2}],"sn":"DOColor$3","rt":$n[10].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[3].Text,$n[2].Color,$n[1].Single]},{"a":2,"n":"DOCounter","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Text,"ps":0},{"n":"fromValue","pt":$n[1].Int32,"ps":1},{"n":"endValue","pt":$n[1].Int32,"ps":2},{"n":"duration","pt":$n[1].Single,"ps":3},{"n":"addThousandsSeparator","dv":true,"o":true,"pt":$n[1].Boolean,"ps":4},{"n":"culture","dv":null,"o":true,"pt":$n[12].CultureInfo,"ps":5}],"sn":"DOCounter","rt":$n[10].TweenerCore$3(System.Int32,System.Int32,DG.Tweening.Plugins.Options.NoOptions),"p":[$n[3].Text,$n[1].Int32,$n[1].Int32,$n[1].Single,$n[1].Boolean,$n[12].CultureInfo]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].CanvasGroup,"ps":0},{"n":"endValue","pt":$n[1].Single,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2}],"sn":"DOFade","rt":$n[10].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[2].CanvasGroup,$n[1].Single,$n[1].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Graphic,"ps":0},{"n":"endValue","pt":$n[1].Single,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2}],"sn":"DOFade$1","rt":$n[10].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[3].Graphic,$n[1].Single,$n[1].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Image,"ps":0},{"n":"endValue","pt":$n[1].Single,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2}],"sn":"DOFade$2","rt":$n[10].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[3].Image,$n[1].Single,$n[1].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Outline,"ps":0},{"n":"endValue","pt":$n[1].Single,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2}],"sn":"DOFade$3","rt":$n[10].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[3].Outline,$n[1].Single,$n[1].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Text,"ps":0},{"n":"endValue","pt":$n[1].Single,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2}],"sn":"DOFade$4","rt":$n[10].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[3].Text,$n[1].Single,$n[1].Single]},{"a":2,"n":"DOFillAmount","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Image,"ps":0},{"n":"endValue","pt":$n[1].Single,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2}],"sn":"DOFillAmount","rt":$n[10].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[3].Image,$n[1].Single,$n[1].Single]},{"a":2,"n":"DOFlexibleSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].LayoutElement,"ps":0},{"n":"endValue","pt":$n[2].Vector2,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[1].Boolean,"ps":3}],"sn":"DOFlexibleSize","rt":$n[10].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].LayoutElement,$n[2].Vector2,$n[1].Single,$n[1].Boolean]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Image,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[5].Sequence,"p":[$n[3].Image,pc.ColorGradient,$n[1].Single]},{"a":2,"n":"DOHorizontalNormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].ScrollRect,"ps":0},{"n":"endValue","pt":$n[1].Single,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[1].Boolean,"ps":3}],"sn":"DOHorizontalNormalizedPos","rt":$n[5].Tweener,"p":[$n[3].ScrollRect,$n[1].Single,$n[1].Single,$n[1].Boolean]},{"a":2,"n":"DOJumpAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"endValue","pt":$n[2].Vector2,"ps":1},{"n":"jumpPower","pt":$n[1].Single,"ps":2},{"n":"numJumps","pt":$n[1].Int32,"ps":3},{"n":"duration","pt":$n[1].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[1].Boolean,"ps":5}],"sn":"DOJumpAnchorPos","rt":$n[5].Sequence,"p":[$n[2].RectTransform,$n[2].Vector2,$n[1].Single,$n[1].Int32,$n[1].Single,$n[1].Boolean]},{"a":2,"n":"DOMinSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].LayoutElement,"ps":0},{"n":"endValue","pt":$n[2].Vector2,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[1].Boolean,"ps":3}],"sn":"DOMinSize","rt":$n[10].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].LayoutElement,$n[2].Vector2,$n[1].Single,$n[1].Boolean]},{"a":2,"n":"DONormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].ScrollRect,"ps":0},{"n":"endValue","pt":$n[2].Vector2,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[1].Boolean,"ps":3}],"sn":"DONormalizedPos","rt":$n[5].Tweener,"p":[$n[3].ScrollRect,$n[2].Vector2,$n[1].Single,$n[1].Boolean]},{"a":2,"n":"DOPivot","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"endValue","pt":$n[2].Vector2,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2}],"sn":"DOPivot","rt":$n[10].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].RectTransform,$n[2].Vector2,$n[1].Single]},{"a":2,"n":"DOPivotX","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Single,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2}],"sn":"DOPivotX","rt":$n[10].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].RectTransform,$n[1].Single,$n[1].Single]},{"a":2,"n":"DOPivotY","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Single,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2}],"sn":"DOPivotY","rt":$n[10].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].RectTransform,$n[1].Single,$n[1].Single]},{"a":2,"n":"DOPreferredSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].LayoutElement,"ps":0},{"n":"endValue","pt":$n[2].Vector2,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[1].Boolean,"ps":3}],"sn":"DOPreferredSize","rt":$n[10].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].LayoutElement,$n[2].Vector2,$n[1].Single,$n[1].Boolean]},{"a":2,"n":"DOPunchAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"punch","pt":$n[2].Vector2,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[1].Int32,"ps":3},{"n":"elasticity","dv":1.0,"o":true,"pt":$n[1].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[1].Boolean,"ps":5}],"sn":"DOPunchAnchorPos","rt":$n[5].Tweener,"p":[$n[2].RectTransform,$n[2].Vector2,$n[1].Single,$n[1].Int32,$n[1].Single,$n[1].Boolean]},{"a":2,"n":"DOScale","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Outline,"ps":0},{"n":"endValue","pt":$n[2].Vector2,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2}],"sn":"DOScale","rt":$n[10].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].Outline,$n[2].Vector2,$n[1].Single]},{"a":2,"n":"DOShakeAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"duration","pt":$n[1].Single,"ps":1},{"n":"strength","dv":100.0,"o":true,"pt":$n[1].Single,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[1].Int32,"ps":3},{"n":"randomness","dv":90.0,"o":true,"pt":$n[1].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[1].Boolean,"ps":5},{"n":"fadeOut","dv":true,"o":true,"pt":$n[1].Boolean,"ps":6},{"n":"randomnessMode","dv":0,"o":true,"pt":$n[5].ShakeRandomnessMode,"ps":7}],"sn":"DOShakeAnchorPos","rt":$n[5].Tweener,"p":[$n[2].RectTransform,$n[1].Single,$n[1].Single,$n[1].Int32,$n[1].Single,$n[1].Boolean,$n[1].Boolean,$n[5].ShakeRandomnessMode]},{"a":2,"n":"DOShakeAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"duration","pt":$n[1].Single,"ps":1},{"n":"strength","pt":$n[2].Vector2,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[1].Int32,"ps":3},{"n":"randomness","dv":90.0,"o":true,"pt":$n[1].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[1].Boolean,"ps":5},{"n":"fadeOut","dv":true,"o":true,"pt":$n[1].Boolean,"ps":6},{"n":"randomnessMode","dv":0,"o":true,"pt":$n[5].ShakeRandomnessMode,"ps":7}],"sn":"DOShakeAnchorPos$1","rt":$n[5].Tweener,"p":[$n[2].RectTransform,$n[1].Single,$n[2].Vector2,$n[1].Int32,$n[1].Single,$n[1].Boolean,$n[1].Boolean,$n[5].ShakeRandomnessMode]},{"a":2,"n":"DOShapeCircle","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"center","pt":$n[2].Vector2,"ps":1},{"n":"endValueDegrees","pt":$n[1].Single,"ps":2},{"n":"duration","pt":$n[1].Single,"ps":3},{"n":"relativeCenter","dv":false,"o":true,"pt":$n[1].Boolean,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[1].Boolean,"ps":5}],"sn":"DOShapeCircle","rt":$n[10].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.CircleOptions),"p":[$n[2].RectTransform,$n[2].Vector2,$n[1].Single,$n[1].Single,$n[1].Boolean,$n[1].Boolean]},{"a":2,"n":"DOSizeDelta","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"endValue","pt":$n[2].Vector2,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[1].Boolean,"ps":3}],"sn":"DOSizeDelta","rt":$n[10].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].RectTransform,$n[2].Vector2,$n[1].Single,$n[1].Boolean]},{"a":2,"n":"DOText","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Text,"ps":0},{"n":"endValue","pt":$n[1].String,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"richTextEnabled","dv":true,"o":true,"pt":$n[1].Boolean,"ps":3},{"n":"scrambleMode","dv":0,"o":true,"pt":$n[5].ScrambleMode,"ps":4},{"n":"scrambleChars","dv":null,"o":true,"pt":$n[1].String,"ps":5}],"sn":"DOText","rt":$n[10].TweenerCore$3(System.String,System.String,DG.Tweening.Plugins.Options.StringOptions),"p":[$n[3].Text,$n[1].String,$n[1].Single,$n[1].Boolean,$n[5].ScrambleMode,$n[1].String]},{"a":2,"n":"DOValue","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Slider,"ps":0},{"n":"endValue","pt":$n[1].Single,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[1].Boolean,"ps":3}],"sn":"DOValue","rt":$n[10].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[3].Slider,$n[1].Single,$n[1].Single,$n[1].Boolean]},{"a":2,"n":"DOVerticalNormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].ScrollRect,"ps":0},{"n":"endValue","pt":$n[1].Single,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[1].Boolean,"ps":3}],"sn":"DOVerticalNormalizedPos","rt":$n[5].Tweener,"p":[$n[3].ScrollRect,$n[1].Single,$n[1].Single,$n[1].Boolean]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUI end.*/

    /*DG.Tweening.DOTweenModuleUI+Utils start.*/
    $m("DG.Tweening.DOTweenModuleUI.Utils", function () { return {"td":$n[5].DOTweenModuleUI,"att":1048962,"a":2,"s":true,"m":[{"a":2,"n":"SwitchToRectTransform","is":true,"t":8,"pi":[{"n":"from","pt":$n[2].RectTransform,"ps":0},{"n":"to","pt":$n[2].RectTransform,"ps":1}],"sn":"SwitchToRectTransform","rt":$n[2].Vector2,"p":[$n[2].RectTransform,$n[2].RectTransform]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUI+Utils end.*/

    /*DG.Tweening.DOTweenModuleUnityVersion start.*/
    $m("DG.Tweening.DOTweenModuleUnityVersion", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Material,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"duration","pt":$n[1].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[5].Sequence,"p":[$n[2].Material,pc.ColorGradient,$n[1].Single]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Material,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"property","pt":$n[1].String,"ps":2},{"n":"duration","pt":$n[1].Single,"ps":3}],"sn":"DOGradientColor$1","rt":$n[5].Sequence,"p":[$n[2].Material,pc.ColorGradient,$n[1].String,$n[1].Single]},{"a":2,"n":"DOOffset","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Material,"ps":0},{"n":"endValue","pt":$n[2].Vector2,"ps":1},{"n":"propertyID","pt":$n[1].Int32,"ps":2},{"n":"duration","pt":$n[1].Single,"ps":3}],"sn":"DOOffset","rt":$n[10].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].Material,$n[2].Vector2,$n[1].Int32,$n[1].Single]},{"a":2,"n":"DOTiling","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Material,"ps":0},{"n":"endValue","pt":$n[2].Vector2,"ps":1},{"n":"propertyID","pt":$n[1].Int32,"ps":2},{"n":"duration","pt":$n[1].Single,"ps":3}],"sn":"DOTiling","rt":$n[10].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].Material,$n[2].Vector2,$n[1].Int32,$n[1].Single]},{"a":2,"n":"WaitForCompletion","is":true,"t":8,"pi":[{"n":"t","pt":$n[5].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[1].Boolean,"ps":1}],"sn":"WaitForCompletion","rt":$n[2].CustomYieldInstruction,"p":[$n[5].Tween,$n[1].Boolean]},{"a":2,"n":"WaitForElapsedLoops","is":true,"t":8,"pi":[{"n":"t","pt":$n[5].Tween,"ps":0},{"n":"elapsedLoops","pt":$n[1].Int32,"ps":1},{"n":"returnCustomYieldInstruction","pt":$n[1].Boolean,"ps":2}],"sn":"WaitForElapsedLoops","rt":$n[2].CustomYieldInstruction,"p":[$n[5].Tween,$n[1].Int32,$n[1].Boolean]},{"a":2,"n":"WaitForKill","is":true,"t":8,"pi":[{"n":"t","pt":$n[5].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[1].Boolean,"ps":1}],"sn":"WaitForKill","rt":$n[2].CustomYieldInstruction,"p":[$n[5].Tween,$n[1].Boolean]},{"a":2,"n":"WaitForPosition","is":true,"t":8,"pi":[{"n":"t","pt":$n[5].Tween,"ps":0},{"n":"position","pt":$n[1].Single,"ps":1},{"n":"returnCustomYieldInstruction","pt":$n[1].Boolean,"ps":2}],"sn":"WaitForPosition","rt":$n[2].CustomYieldInstruction,"p":[$n[5].Tween,$n[1].Single,$n[1].Boolean]},{"a":2,"n":"WaitForRewind","is":true,"t":8,"pi":[{"n":"t","pt":$n[5].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[1].Boolean,"ps":1}],"sn":"WaitForRewind","rt":$n[2].CustomYieldInstruction,"p":[$n[5].Tween,$n[1].Boolean]},{"a":2,"n":"WaitForStart","is":true,"t":8,"pi":[{"n":"t","pt":$n[5].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[1].Boolean,"ps":1}],"sn":"WaitForStart","rt":$n[2].CustomYieldInstruction,"p":[$n[5].Tween,$n[1].Boolean]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUnityVersion end.*/

    /*DG.Tweening.DOTweenCYInstruction start.*/
    $m("DG.Tweening.DOTweenCYInstruction", function () { return {"nested":[$n[5].DOTweenCYInstruction.WaitForCompletion,$n[5].DOTweenCYInstruction.WaitForRewind,$n[5].DOTweenCYInstruction.WaitForKill,$n[5].DOTweenCYInstruction.WaitForElapsedLoops,$n[5].DOTweenCYInstruction.WaitForPosition,$n[5].DOTweenCYInstruction.WaitForStart],"att":1048961,"a":2,"s":true}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForCompletion", function () { return {"td":$n[5].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[5].Tween],"pi":[{"n":"tween","pt":$n[5].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[1].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[1].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[5].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForRewind", function () { return {"td":$n[5].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[5].Tween],"pi":[{"n":"tween","pt":$n[5].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[1].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[1].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[5].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForKill start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForKill", function () { return {"td":$n[5].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[5].Tween],"pi":[{"n":"tween","pt":$n[5].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[1].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[1].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[5].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForKill end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops", function () { return {"td":$n[5].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[5].Tween,$n[1].Int32],"pi":[{"n":"tween","pt":$n[5].Tween,"ps":0},{"n":"elapsedLoops","pt":$n[1].Int32,"ps":1}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[1].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[1].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"elapsedLoops","t":4,"rt":$n[1].Int32,"sn":"elapsedLoops","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"t","t":4,"rt":$n[5].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForPosition", function () { return {"td":$n[5].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[5].Tween,$n[1].Single],"pi":[{"n":"tween","pt":$n[5].Tween,"ps":0},{"n":"position","pt":$n[1].Single,"ps":1}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[1].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[1].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"position","t":4,"rt":$n[1].Single,"sn":"position","ro":true,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"t","t":4,"rt":$n[5].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForStart start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForStart", function () { return {"td":$n[5].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[5].Tween],"pi":[{"n":"tween","pt":$n[5].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[1].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[1].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[5].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForStart end.*/

    /*DG.Tweening.DOTweenModuleUtils start.*/
    $m("DG.Tweening.DOTweenModuleUtils", function () { return {"nested":[$n[5].DOTweenModuleUtils.Physics],"att":1048961,"a":2,"s":true,"m":[{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":2,"n":"Init","is":true,"t":8,"sn":"Init","rt":$n[1].Void},{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":1,"n":"Preserver","is":true,"t":8,"sn":"Preserver","rt":$n[1].Void},{"a":1,"n":"_initialized","is":true,"t":4,"rt":$n[1].Boolean,"sn":"_initialized","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUtils end.*/

    /*DG.Tweening.DOTweenModuleUtils+Physics start.*/
    $m("DG.Tweening.DOTweenModuleUtils.Physics", function () { return {"td":$n[5].DOTweenModuleUtils,"att":1048962,"a":2,"s":true,"m":[{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":2,"n":"CreateDOTweenPathTween","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].MonoBehaviour,"ps":0},{"n":"tweenRigidbody","pt":$n[1].Boolean,"ps":1},{"n":"isLocal","pt":$n[1].Boolean,"ps":2},{"n":"path","pt":$n[11].Path,"ps":3},{"n":"duration","pt":$n[1].Single,"ps":4},{"n":"pathMode","pt":$n[5].PathMode,"ps":5}],"sn":"CreateDOTweenPathTween","rt":$n[10].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[2].MonoBehaviour,$n[1].Boolean,$n[1].Boolean,$n[11].Path,$n[1].Single,$n[5].PathMode]},{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":2,"n":"HasRigidbody","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Component,"ps":0}],"sn":"HasRigidbody","rt":$n[1].Boolean,"p":[$n[2].Component],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"HasRigidbody2D","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Component,"ps":0}],"sn":"HasRigidbody2D","rt":$n[1].Boolean,"p":[$n[2].Component],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SetOrientationOnPath","is":true,"t":8,"pi":[{"n":"options","pt":$n[13].PathOptions,"ps":0},{"n":"t","pt":$n[5].Tween,"ps":1},{"n":"newRot","pt":$n[2].Quaternion,"ps":2},{"n":"trans","pt":$n[2].Transform,"ps":3}],"sn":"SetOrientationOnPath","rt":$n[1].Void,"p":[$n[13].PathOptions,$n[5].Tween,$n[2].Quaternion,$n[2].Transform]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUtils+Physics end.*/

    /*GogoGaga.OptimizedRopesAndCables.Rope start.*/
    $m("GogoGaga.OptimizedRopesAndCables.Rope", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(UnityEngine.LineRenderer)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AreEndPointsValid","t":8,"sn":"AreEndPointsValid","rt":$n[1].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"CalculateYFactorAdjustment","t":8,"pi":[{"n":"weight","pt":$n[1].Single,"ps":0}],"sn":"CalculateYFactorAdjustment","rt":$n[1].Single,"p":[$n[1].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[1].Void},{"a":1,"n":"GetMidPoint","t":8,"sn":"GetMidPoint","rt":$n[2].Vector3},{"a":2,"n":"GetPointAt","t":8,"pi":[{"n":"t","pt":$n[1].Single,"ps":0}],"sn":"GetPointAt","rt":$n[2].Vector3,"p":[$n[1].Single]},{"a":1,"n":"GetRationalBezierPoint","t":8,"pi":[{"n":"p0","pt":$n[2].Vector3,"ps":0},{"n":"p1","pt":$n[2].Vector3,"ps":1},{"n":"p2","pt":$n[2].Vector3,"ps":2},{"n":"t","pt":$n[1].Single,"ps":3},{"n":"w0","pt":$n[1].Single,"ps":4},{"n":"w1","pt":$n[1].Single,"ps":5},{"n":"w2","pt":$n[1].Single,"ps":6}],"sn":"GetRationalBezierPoint","rt":$n[2].Vector3,"p":[$n[2].Vector3,$n[2].Vector3,$n[2].Vector3,$n[1].Single,$n[1].Single,$n[1].Single,$n[1].Single]},{"a":1,"n":"InitializeLineRenderer","t":8,"sn":"InitializeLineRenderer","rt":$n[1].Void},{"a":1,"n":"IsPointsMoved","t":8,"sn":"IsPointsMoved","rt":$n[1].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"IsRopeSettingsChanged","t":8,"sn":"IsRopeSettingsChanged","rt":$n[1].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"NotifyPointsChanged","t":8,"sn":"NotifyPointsChanged","rt":$n[1].Void},{"a":1,"n":"OnDrawGizmos","t":8,"sn":"OnDrawGizmos","rt":$n[1].Void},{"a":1,"n":"OnValidate","t":8,"sn":"OnValidate","rt":$n[1].Void},{"a":2,"n":"RecalculateRope","t":8,"sn":"RecalculateRope","rt":$n[1].Void},{"a":2,"n":"SetEndPoint","t":8,"pi":[{"n":"newEndPoint","pt":$n[2].Transform,"ps":0},{"n":"instantAssign","dv":false,"o":true,"pt":$n[1].Boolean,"ps":1}],"sn":"SetEndPoint","rt":$n[1].Void,"p":[$n[2].Transform,$n[1].Boolean]},{"a":2,"n":"SetMidPoint","t":8,"pi":[{"n":"newMidPoint","pt":$n[2].Transform,"ps":0},{"n":"instantAssign","dv":false,"o":true,"pt":$n[1].Boolean,"ps":1}],"sn":"SetMidPoint","rt":$n[1].Void,"p":[$n[2].Transform,$n[1].Boolean]},{"a":1,"n":"SetSplinePoint","t":8,"sn":"SetSplinePoint","rt":$n[1].Void},{"a":2,"n":"SetStartPoint","t":8,"pi":[{"n":"newStartPoint","pt":$n[2].Transform,"ps":0},{"n":"instantAssign","dv":false,"o":true,"pt":$n[1].Boolean,"ps":1}],"sn":"SetStartPoint","rt":$n[1].Void,"p":[$n[2].Transform,$n[1].Boolean]},{"a":1,"n":"SimulatePhysics","t":8,"sn":"SimulatePhysics","rt":$n[1].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[1].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[1].Void},{"a":2,"n":"EndPoint","t":16,"rt":$n[2].Transform,"g":{"a":2,"n":"get_EndPoint","t":8,"rt":$n[2].Transform,"fg":"EndPoint"},"fn":"EndPoint"},{"a":2,"n":"IsPrefab","t":16,"rt":$n[1].Boolean,"g":{"a":2,"n":"get_IsPrefab","t":8,"rt":$n[1].Boolean,"fg":"IsPrefab","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsPrefab"},{"a":2,"n":"MidPoint","t":16,"rt":$n[2].Transform,"g":{"a":2,"n":"get_MidPoint","t":8,"rt":$n[2].Transform,"fg":"MidPoint"},"fn":"MidPoint"},{"a":2,"n":"StartPoint","t":16,"rt":$n[2].Transform,"g":{"a":2,"n":"get_StartPoint","t":8,"rt":$n[2].Transform,"fg":"StartPoint"},"fn":"StartPoint"},{"a":2,"n":"otherPhysicsFactors","t":16,"rt":$n[2].Vector3,"g":{"a":2,"n":"get_otherPhysicsFactors","t":8,"rt":$n[2].Vector3,"fg":"otherPhysicsFactors"},"s":{"a":2,"n":"set_otherPhysicsFactors","t":8,"p":[$n[2].Vector3],"rt":$n[1].Void,"fs":"otherPhysicsFactors"},"fn":"otherPhysicsFactors"},{"a":1,"n":"EndPointWeight","is":true,"t":4,"rt":$n[1].Single,"sn":"EndPointWeight","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"StartPointWeight","is":true,"t":4,"rt":$n[1].Single,"sn":"StartPointWeight","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"currentValue","t":4,"rt":$n[2].Vector3,"sn":"currentValue"},{"a":1,"n":"currentVelocity","t":4,"rt":$n[2].Vector3,"sn":"currentVelocity"},{"at":[new UnityEngine.TooltipAttribute("0 is no damping, 50 is a lot")],"a":2,"n":"damping","t":4,"rt":$n[1].Single,"sn":"damping","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The rope will end at this point"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"endPoint","t":4,"rt":$n[2].Transform,"sn":"endPoint"},{"a":1,"n":"isFirstFrame","t":4,"rt":$n[1].Boolean,"sn":"isFirstFrame","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("Rope Settings"),new UnityEngine.TooltipAttribute("How many points should the rope have, 2 would be a triangle with straight lines, 100 would be a very flexible rope with many parts"),new UnityEngine.RangeAttribute(2.0, 100.0)],"a":2,"n":"linePoints","t":4,"rt":$n[1].Int32,"sn":"linePoints","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"lineRenderer","t":4,"rt":$n[2].LineRenderer,"sn":"lineRenderer"},{"at":[new UnityEngine.TooltipAttribute("This will move at the center hanging from the rope, like a necklace, for example"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"midPoint","t":4,"rt":$n[2].Transform,"sn":"midPoint"},{"at":[new UnityEngine.HeaderAttribute("Midpoint Position"),new UnityEngine.TooltipAttribute("Position of the midpoint along the line between start and end points"),new UnityEngine.RangeAttribute(0.25, 0.75)],"a":2,"n":"midPointPosition","t":4,"rt":$n[1].Single,"sn":"midPointPosition","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("Rational Bezier Weight Control"),new UnityEngine.TooltipAttribute("Adjust the middle control point weight for the Rational Bezier curve"),new UnityEngine.RangeAttribute(1.0, 15.0)],"a":2,"n":"midPointWeight","t":4,"rt":$n[1].Single,"sn":"midPointWeight","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"prevDampness","t":4,"rt":$n[1].Single,"sn":"prevDampness","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"prevEndPointPosition","t":4,"rt":$n[2].Vector3,"sn":"prevEndPointPosition"},{"a":1,"n":"prevLineQuality","t":4,"rt":$n[1].Single,"sn":"prevLineQuality","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"prevMidPointPosition","t":4,"rt":$n[1].Single,"sn":"prevMidPointPosition","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"prevMidPointWeight","t":4,"rt":$n[1].Single,"sn":"prevMidPointWeight","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"prevRopeLength","t":4,"rt":$n[1].Single,"sn":"prevRopeLength","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"prevRopeWidth","t":4,"rt":$n[1].Single,"sn":"prevRopeWidth","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"prevStartPointPosition","t":4,"rt":$n[2].Vector3,"sn":"prevStartPointPosition"},{"a":1,"n":"prevstiffness","t":4,"rt":$n[1].Single,"sn":"prevstiffness","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("How long is the rope, it will hang more or less from starting point to end point depending on this value")],"a":2,"n":"ropeLength","t":4,"rt":$n[1].Single,"sn":"ropeLength","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The Rope width set at start (changing this value during run time will produce no effect)")],"a":2,"n":"ropeWidth","t":4,"rt":$n[1].Single,"sn":"ropeWidth","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("Rope Transforms"),new UnityEngine.TooltipAttribute("The rope will start at this point"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"startPoint","t":4,"rt":$n[2].Transform,"sn":"startPoint"},{"at":[new UnityEngine.TooltipAttribute("Value highly dependent on use case, a metal cable would have high stiffness, a rubber rope would have a low one")],"a":2,"n":"stiffness","t":4,"rt":$n[1].Single,"sn":"stiffness","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"targetValue","t":4,"rt":$n[2].Vector3,"sn":"targetValue"},{"a":1,"n":"valueThreshold","is":true,"t":4,"rt":$n[1].Single,"sn":"valueThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"velocityThreshold","is":true,"t":4,"rt":$n[1].Single,"sn":"velocityThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"OnPointsChanged","t":2,"ad":{"a":2,"n":"add_OnPointsChanged","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnPointsChanged","rt":$n[1].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnPointsChanged","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnPointsChanged","rt":$n[1].Void,"p":[Function]}},{"a":1,"backing":true,"n":"<otherPhysicsFactors>k__BackingField","t":4,"rt":$n[2].Vector3,"sn":"otherPhysicsFactors"}]}; }, $n);
    /*GogoGaga.OptimizedRopesAndCables.Rope end.*/

    /*GogoGaga.OptimizedRopesAndCables.RopeMesh start.*/
    $m("GogoGaga.OptimizedRopesAndCables.RopeMesh", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.MeshFilter),new UnityEngine.RequireComponent.ctor(UnityEngine.MeshRenderer),new UnityEngine.RequireComponent.ctor(GogoGaga.OptimizedRopesAndCables.Rope)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[1].Void},{"a":1,"n":"CacheOverrideColorID","t":8,"sn":"CacheOverrideColorID","rt":$n[1].Void},{"a":1,"n":"CheckEndPoints","t":8,"sn":"CheckEndPoints","rt":$n[1].Void},{"a":2,"n":"CreateRopeMesh","t":8,"pi":[{"n":"points","pt":System.Array.type(UnityEngine.Vector3),"ps":0},{"n":"radius","pt":$n[1].Single,"ps":1},{"n":"segmentsPerWire","pt":$n[1].Int32,"ps":2}],"sn":"CreateRopeMesh","rt":$n[1].Void,"p":[System.Array.type(UnityEngine.Vector3),$n[1].Single,$n[1].Int32]},{"a":1,"n":"DelayedGenerateMesh","t":8,"sn":"DelayedGenerateMesh","rt":$n[1].Void},{"a":1,"n":"GenerateMesh","t":8,"sn":"GenerateMesh","rt":$n[1].Void},{"a":1,"n":"InitializeComponents","t":8,"pi":[{"n":"assignMeshToFilter","dv":true,"o":true,"pt":$n[1].Boolean,"ps":0}],"sn":"InitializeComponents","rt":$n[1].Void,"p":[$n[1].Boolean]},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[1].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[1].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[1].Void},{"a":2,"n":"ReOffsetTextureTwoHalf","t":8,"sn":"ReOffsetTextureTwoHalf","rt":$n[1].Void},{"a":2,"n":"SetColor","t":8,"pi":[{"n":"_color","pt":$n[2].Color,"ps":0}],"sn":"SetColor","rt":$n[1].Void,"p":[$n[2].Color]},{"a":2,"n":"SetColor","t":8,"pi":[{"n":"_firstColor","pt":$n[2].Color,"ps":0},{"n":"_secondColor","pt":$n[2].Color,"ps":1}],"sn":"SetColor$1","rt":$n[1].Void,"p":[$n[2].Color,$n[2].Color]},{"at":[new UnityEngine.ContextMenu.ctor("Green")],"a":2,"n":"SetColorGreen","t":8,"sn":"SetColorGreen","rt":$n[1].Void},{"at":[new UnityEngine.ContextMenu.ctor("Red")],"a":2,"n":"SetColorRed","t":8,"sn":"SetColorRed","rt":$n[1].Void},{"a":1,"n":"SubscribeToRopeEvents","t":8,"sn":"SubscribeToRopeEvents","rt":$n[1].Void},{"at":[new UnityEngine.ContextMenu.ctor("Test Random Color")],"a":1,"n":"TestRandomColor","t":8,"sn":"TestRandomColor","rt":$n[1].Void},{"a":1,"n":"TrySetSingleColor","t":8,"pi":[{"n":"mat","pt":$n[2].Material,"ps":0},{"n":"color","pt":$n[2].Color,"ps":1}],"sn":"TrySetSingleColor","rt":$n[1].Boolean,"p":[$n[2].Material,$n[2].Color],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"UnsubscribeFromRopeEvents","t":8,"sn":"UnsubscribeFromRopeEvents","rt":$n[1].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[1].Void},{"a":1,"n":"BaseColorID","is":true,"t":4,"rt":$n[1].Int32,"sn":"BaseColorID","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"ColorID","is":true,"t":4,"rt":$n[1].Int32,"sn":"ColorID","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"EmissionColorID","is":true,"t":4,"rt":$n[1].Int32,"sn":"EmissionColorID","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.HeaderAttribute("Debug / Color Application")],"a":2,"n":"EnableDebugColorLogs","t":4,"rt":$n[1].Boolean,"sn":"EnableDebugColorLogs","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"EndPoint","t":4,"rt":$n[2].Transform,"sn":"EndPoint"},{"a":2,"n":"FirstHalfColor","t":4,"rt":$n[2].Color,"sn":"FirstHalfColor"},{"a":1,"n":"MainColorID","is":true,"t":4,"rt":$n[1].Int32,"sn":"MainColorID","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.TooltipAttribute("Minimum seconds between automatic rebuilds when settings move rapidly."),new UnityEngine.RangeAttribute(0.0, 0.25)],"a":2,"n":"MinSecondsBetweenRebuilds","t":4,"rt":$n[1].Single,"sn":"MinSecondsBetweenRebuilds","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(3.0, 25.0)],"a":2,"n":"OverallDivision","t":4,"rt":$n[1].Int32,"sn":"OverallDivision","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.TooltipAttribute("T\u00f9y ch\u1ecdn: t\u00ean property m\u00e0u ch\u00ednh c\u1ee7a shader (v\u00ed d\u1ee5 _BaseColor, _Color, _TintColor...). N\u1ebfu \u0111i\u1ec1n \u0111\u00fang, s\u1ebd \u01b0u ti\u00ean d\u00f9ng property n\u00e0y.")],"a":2,"n":"OverrideColorProperty","t":4,"rt":$n[1].String,"sn":"OverrideColorProperty"},{"at":[new UnityEngine.TooltipAttribute("Distance threshold to consider endpoints moved enough to rebuild.")],"a":2,"n":"RebuildMovementThreshold","t":4,"rt":$n[1].Single,"sn":"RebuildMovementThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("Performance Optimization"),new UnityEngine.TooltipAttribute("If true, always rebuild mesh each frame (debug). If false, rebuild only when endpoints or rope settings change.")],"a":2,"n":"RebuildOnEveryFrame","t":4,"rt":$n[1].Boolean,"sn":"RebuildOnEveryFrame","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Whether to recalculate normals each rebuild (disable if using flat shader for perf). ")],"a":2,"n":"RecalculateNormals","t":4,"rt":$n[1].Boolean,"sn":"RecalculateNormals","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("ROPE TEXTURE EQUALIZER")],"a":2,"n":"RopeLogic","t":4,"rt":$n[7].Rope,"sn":"RopeLogic"},{"a":2,"n":"SecondHalfColor","t":4,"rt":$n[2].Color,"sn":"SecondHalfColor"},{"a":2,"n":"StartPoint","t":4,"rt":$n[2].Transform,"sn":"StartPoint"},{"a":2,"n":"ThresholdDistance","t":4,"rt":$n[1].Single,"sn":"ThresholdDistance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"ThresholdOffsetY","t":4,"rt":$n[1].Single,"sn":"ThresholdOffsetY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"TintColorID","is":true,"t":4,"rt":$n[1].Int32,"sn":"TintColorID","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"TintID","is":true,"t":4,"rt":$n[1].Int32,"sn":"TintID","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"TwoHalfColor1ID","is":true,"t":4,"rt":$n[1].Int32,"sn":"TwoHalfColor1ID","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"TwoHalfColor2ID","is":true,"t":4,"rt":$n[1].Int32,"sn":"TwoHalfColor2ID","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"TwoHalfMaskSTID","is":true,"t":4,"rt":$n[1].Int32,"sn":"TwoHalfMaskSTID","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"UpdateRate","t":4,"rt":$n[1].Int32,"sn":"UpdateRate","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"firstRuntimeFrame","t":4,"rt":$n[1].Boolean,"sn":"firstRuntimeFrame","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"frameCounter","t":4,"rt":$n[1].Int32,"sn":"frameCounter","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"isStartOrEndPointMissing","t":4,"rt":$n[1].Boolean,"sn":"isStartOrEndPointMissing","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"lastColorPropertyUsed","t":4,"rt":$n[1].String,"sn":"lastColorPropertyUsed"},{"a":1,"n":"lastEndPointPos","t":4,"rt":$n[2].Vector3,"sn":"lastEndPointPos"},{"a":1,"n":"lastOverallDivision","t":4,"rt":$n[1].Int32,"sn":"lastOverallDivision","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"lastRadialDivision","t":4,"rt":$n[1].Int32,"sn":"lastRadialDivision","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"lastRebuildTime","t":4,"rt":$n[1].Single,"sn":"lastRebuildTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"lastRopeWidth","t":4,"rt":$n[1].Single,"sn":"lastRopeWidth","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"lastStartPointPos","t":4,"rt":$n[2].Vector3,"sn":"lastStartPointPos"},{"a":1,"n":"lastTilingPerMeter","t":4,"rt":$n[1].Single,"sn":"lastTilingPerMeter","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("For now only base color is applied")],"a":2,"n":"material","t":4,"rt":$n[2].Material,"sn":"material"},{"a":1,"n":"meshFilter","t":4,"rt":$n[2].MeshFilter,"sn":"meshFilter"},{"a":1,"n":"meshRenderer","t":4,"rt":$n[2].MeshRenderer,"sn":"meshRenderer"},{"a":1,"n":"overrideColorID","t":4,"rt":$n[1].Int32,"sn":"overrideColorID","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"points","t":4,"rt":System.Array.type(UnityEngine.Vector3),"sn":"points"},{"at":[new UnityEngine.RangeAttribute(3.0, 20.0)],"a":2,"n":"radialDivision","t":4,"rt":$n[1].Int32,"sn":"radialDivision","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"rope","t":4,"rt":$n[7].Rope,"sn":"rope"},{"a":1,"n":"ropeMesh","t":4,"rt":$n[2].Mesh,"sn":"ropeMesh"},{"at":[new UnityEngine.RangeAttribute(0.01, 10.0)],"a":2,"n":"ropeWidth","t":4,"rt":$n[1].Single,"sn":"ropeWidth","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("Tiling density per meter of the rope")],"a":2,"n":"tilingPerMeter","t":4,"rt":$n[1].Single,"sn":"tilingPerMeter","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"triangles","t":4,"rt":$n[6].List$1(System.Int32),"sn":"triangles"},{"a":1,"n":"uvs","t":4,"rt":$n[6].List$1(UnityEngine.Vector2),"sn":"uvs"},{"a":1,"n":"vertices","t":4,"rt":$n[6].List$1(UnityEngine.Vector3),"sn":"vertices"}]}; }, $n);
    /*GogoGaga.OptimizedRopesAndCables.RopeMesh end.*/

    }});
